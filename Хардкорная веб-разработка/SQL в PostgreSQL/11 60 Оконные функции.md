# 11.60 Оконные функции

Что, если нам нужно показать все книги и их категории, но при этом мы хотим в каждой категории все книги пронумеровать? Вот прям один, два, три и так далее.

То есть нам нужен вот такой результат:

```sql
|category_name                 |book_name                    |number_in_category|
|------------------------------|-----------------------------|------------------|
|Художественая литература      |Голова профессора Доуэля     |1                 |
|Художественая литература      |Дети капитана Гранта         |2                 |
|Художественая литература      |Капитанская дочка            |3                 |
|Художественая литература      |Остров погибших кораблей     |4                 |
|Художественая литература      |Продавец воздуха             |5                 |
|Художественая литература      |Путешествие к центру Земли   |6                 |
|Художественая литература      |Сказка о рыбаке и рыбке      |7                 |
|Художественая литература      |Судьба человека              |8                 |
|Художественая литература      |Тихий Дон                    |9                 |
|Литература по программированию|Python. К вершинам мастерства|1                 |
|Научная фантастика            |Голова профессора Доуэля     |1                 |
|Научная фантастика            |Дети капитана Гранта         |2                 |
|Научная фантастика            |Остров погибших кораблей     |3                 |
|Научная фантастика            |Продавец воздуха             |4                 |
|Научная фантастика            |Путешествие к центру Земли   |5                 |
```

Как мы можем написать такой SQL-запрос? С помощью оконной функции **`row_number`**, которая как раз позволяет нумеровать строки в разделе.

```sql
select
    c.name category_name,
    b.name book_name,
    row_number() over (
        partition by c.category_id order by b.name
    ) number_in_category
from book b
join book_to_category btc using(book_id)
join book_category c using(category_id)
order by c.category_id, number_in_category;
```

Первые две столбца результирующей таблицы берутся из таблиц категорий и книг. Причём мы видим, что в запросе нет никакой группировки — не используется **`group by`** и сколько книг есть в таблице **`book`**, столько строк и в выходных данных. Просто перечислены все книги со своими категориями.

А третий столбец это номер книги в текущем разделе, то есть среди книг одинаковой категории.

После названия оконной функции всегда идёт слово **`OVER`**. Предложение после **`OVER`** в скобках определяет, на какие группы нужно разделить строки и как сортировать строки внутри группы для вычисления оконной функции. Предложение **`PARTITION BY`** как раз описывает это разделение на группы, а **`ORDER BY`** описывает сортировку. В нашем случае группы определяются одинаковым значением **`category_id`**. И оконная функция, в нашем случае **`ROW_NUMBER()`**, вычисляется по строкам, попадающим в один раздел с текущей строкой.

Порядок обработки строк оконной функцией определяется **`ORDER BY`** в предложении **`OVER`**. В данном случае строки обрабатываются в порядке сортировки колонки с названием книги.

При этом обратите внимание — эта сортировка внутри оконной функции никак не влияет на сортировку результатов запроса, они никак не связаны. Сортировка результатов запроса определяется блоком **`ORDER BY`** самого запроса.

**`ORDER BY`** является необязательным в предложении **`OVER`**, и **`PARTITION`** тоже не является обязательным.

Уберём **`ORDER BY`** — книги просто пронумеруются в каком-то другом порядке внутри каждой категории:

```sql
select
    c.name category_name,
    b.name book_name,
    row_number() over (
        partition by c.category_id *--order by b.name*
    ) number_in_category
from book b
join book_to_category btc using(book_id)
join book_category c using(category_id)
order by c.category_id, number_in_category;

|category_name                 |book_name                    |number_in_category|
|*------------------------------|-----------------------------|------------------|*|Художественая литература      |Тихий Дон                    |1                 |
|Художественая литература      |Сказка о рыбаке и рыбке      |2                 |
|Художественая литература      |Голова профессора Доуэля     |3                 |
|Художественая литература      |Остров погибших кораблей     |4                 |
|Художественая литература      |Путешествие к центру Земли   |5                 |
|Художественая литература      |Дети капитана Гранта         |6                 |
|Художественая литература      |Продавец воздуха             |7                 |
|Художественая литература      |Судьба человека              |8                 |
|Художественая литература      |Капитанская дочка            |9                 |
|Литература по программированию|Python. К вершинам мастерства|1                 |
|Научная фантастика            |Дети капитана Гранта         |1                 |
|Научная фантастика            |Продавец воздуха             |2                 |
|Научная фантастика            |Голова профессора Доуэля     |3                 |
|Научная фантастика            |Остров погибших кораблей     |4                 |
|Научная фантастика            |Путешествие к центру Земли   |5                 |
```

Уберём и **`PARTITION BY`** — тогда все результаты будут в одной группе и сквозняком все книги пронумеруются в каком-то порядке:

```sql
select
    c.name category_name,
    b.name book_name,
    row_number() over (
        *--partition by c.category_id --order by b.name*
    ) number_in_category
from book b
join book_to_category btc using(book_id)
join book_category c using(category_id)
order by c.category_id, number_in_category;

|category_name                 |book_name                    |number_in_category|
|*------------------------------|-----------------------------|------------------|*|Художественая литература      |Тихий Дон                    |1                 |
|Художественая литература      |Судьба человека              |3                 |
|Художественая литература      |Капитанская дочка            |4                 |
|Художественая литература      |Сказка о рыбаке и рыбке      |5                 |
|Художественая литература      |Голова профессора Доуэля     |6                 |
|Художественая литература      |Остров погибших кораблей     |7                 |
|Художественая литература      |Путешествие к центру Земли   |8                 |
|Художественая литература      |Дети капитана Гранта         |9                 |
|Художественая литература      |Продавец воздуха             |14                |
|Литература по программированию|Python. К вершинам мастерства|2                 |
|Научная фантастика            |Голова профессора Доуэля     |10                |
|Научная фантастика            |Остров погибших кораблей     |11                |
|Научная фантастика            |Путешествие к центру Земли   |12                |
|Научная фантастика            |Дети капитана Гранта         |13                |
|Научная фантастика            |Продавец воздуха             |15                |
```

Можно оставить только **`ORDER BY`**, указав порядок обработки строк для оконной функции в одном большом разделе:

```sql
select
    c.name category_name,
    b.name book_name,
    row_number() over (
        *--partition by c.category_id*order by c.category_id
    ) number_in_category
from book b
join book_to_category btc using(book_id)
join book_category c using(category_id)
order by c.category_id, number_in_category;

|category_name                 |book_name                    |number_in_category|
|*------------------------------|-----------------------------|------------------|*|Художественая литература      |Тихий Дон                    |1                 |
|Художественая литература      |Сказка о рыбаке и рыбке      |2                 |
|Художественая литература      |Голова профессора Доуэля     |3                 |
|Художественая литература      |Остров погибших кораблей     |4                 |
|Художественая литература      |Путешествие к центру Земли   |5                 |
|Художественая литература      |Дети капитана Гранта         |6                 |
|Художественая литература      |Продавец воздуха             |7                 |
|Художественая литература      |Судьба человека              |8                 |
|Художественая литература      |Капитанская дочка            |9                 |
|Литература по программированию|Python. К вершинам мастерства|10                |
|Научная фантастика            |Дети капитана Гранта         |11                |
|Научная фантастика            |Продавец воздуха             |12                |
|Научная фантастика            |Голова профессора Доуэля     |13                |
|Научная фантастика            |Остров погибших кораблей     |14                |
|Научная фантастика            |Путешествие к центру Земли   |15                |
```

Также оконные функции можно использовать для задач, например, подсчёта накопительного итога. Есть понятие рамки окна, и некоторые оконные функции обрабатывают не весь раздел, а только строки, которые входят в рамку окна с текущей строкой. Фактически так работают по умолчанию обычные агрегатные функции, которые запускаются в режиме оконных, то есть со словом **`OVER`**.

Если используется **`ORDER BY`** в предложении **`OVER`**, то рамка состоит из всех строк от начала раздела до текущей строки, а также включает в себя строки с такими же значениями полей **`ORDER BY`**, как и текущая строка. Без **`ORDER BY`** рамка по умолчанию состоит из всех строк раздела.

Давайте для примера посмотрим, как по месяцам увеличивается количество книг на платформе. Дата создания книги у нас хранится в поле **`created_at`** таблицы **`book`**. Заполним это поле данными, чтобы было что использовать в запросе.

```sql
update book set created_at='2024-01-10' where book_id=1;
update book set created_at='2024-01-04' where book_id=2;
update book set created_at='2024-02-11' where book_id=3;
update book set created_at='2024-03-04' where book_id=4;
update book set created_at='2024-05-06' where book_id=5;
update book set created_at='2024-05-18' where book_id=6;
update book set created_at='2024-05-19' where book_id=7;
update book set created_at='2024-06-10' where book_id=8;
update book set created_at='2024-06-11' where book_id=9;
update book set created_at='2024-06-21' where book_id=10;

select date_trunc('month', created_at) created_month
from book b order by created_month;

|created_month          |
|*-----------------------|*|2024-01-01 00:00:00.000|
|2024-01-01 00:00:00.000|
|2024-02-01 00:00:00.000|
|2024-03-01 00:00:00.000|
|2024-05-01 00:00:00.000|
|2024-05-01 00:00:00.000|
|2024-05-01 00:00:00.000|
|2024-06-01 00:00:00.000|
|2024-06-01 00:00:00.000|
|2024-06-01 00:00:00.000|
```

Мы видим, что в апреле ни одна книга не была добавлена. Но в отчёте нам апрель нужен, просто для него количество книг должно быть равно количеству книг марта. Поэтому нам надо как-то достать список всех месяцев, такой список можно сделать с помощью встроенной функции **`generate_series`**:

`select month_series as m
from generate_series(
    date '2024-01-01',
    date '2024-06-01',
    interval '1 month'
) as month_series;

|m                            |
|*-----------------------------|*|2024-01-01 00:00:00.000 +0300|
|2024-02-01 00:00:00.000 +0300|
|2024-03-01 00:00:00.000 +0300|
|2024-04-01 00:00:00.000 +0300|
|2024-05-01 00:00:00.000 +0300|
|2024-06-01 00:00:00.000 +0300|`

Отлично, а как достать количество книг, добавленных в каждый месяц? Просто сгруппировать по месяцу добавления:

`select date_trunc('month', created_at) created_month, count(*) as cnt
from book b
group by date_trunc('month', created_at)
order by created_month;

|created_month          |cnt|
|*-----------------------|---|*|2024-01-01 00:00:00.000|2  |
|2024-02-01 00:00:00.000|1  |
|2024-03-01 00:00:00.000|1  |
|2024-05-01 00:00:00.000|3  |
|2024-06-01 00:00:00.000|3  |`

В январе добавлено 2 книги, в феврале одна, в марте одна, апреля вообще здесь нет, значит, в апреле книг не добавлялось, в мае и июне по 3 книги добавлено было.

Чтобы апрель у нас был в выборке, мы выполним **`LEFT JOIN`** таблицы со списком всех нужных месяцев с нашей таблицей добавляемых помесячно книг:

`SELECT ms as year_month,
    cnt
FROM generate_series(
    DATE '2024-01-01',
    DATE '2024-06-01',
    INTERVAL '1 month'
) AS ms
left join (
    select date_trunc('month', created_at) created_month, count(*) as cnt
    from book b
    group by date_trunc('month', created_at)
) books on ms = books.created_month
order by year_month;

|year_month                   |cnt|
|*-----------------------------|---|*|2024-01-01 00:00:00.000 +0300|2  |
|2024-02-01 00:00:00.000 +0300|1  |
|2024-03-01 00:00:00.000 +0300|1  |
|2024-04-01 00:00:00.000 +0300|   |
|2024-05-01 00:00:00.000 +0300|3  |
|2024-06-01 00:00:00.000 +0300|3  |`

Просто джоиним таблицу месяцев на таблицу с количеством книг, добавленных каждый месяц. Видим здесь **`NULL`** в колонке **`cnt`** для книг, добавленных в апреле — что логично. Используем функцию **`coalesce`**, чтобы этот **`NULL`** прибить к нулю, то есть преобразовать в ноль:

`SELECT ms as year_month,
    coalesce(cnt, 0) cnt
FROM generate_series(
    DATE '2024-01-01',
    DATE '2024-06-01',
    INTERVAL '1 month'
) AS ms
left join (
    select date_trunc('month', created_at) created_month, count(*) as cnt
    from book b
    group by date_trunc('month', created_at)
) books on ms = books.created_month
order by year_month;

|year_month                   |cnt|
|*-----------------------------|---|*|2024-01-01 00:00:00.000 +0300|2  |
|2024-02-01 00:00:00.000 +0300|1  |
|2024-03-01 00:00:00.000 +0300|1  |
|2024-04-01 00:00:00.000 +0300|0  |
|2024-05-01 00:00:00.000 +0300|3  |
|2024-06-01 00:00:00.000 +0300|3  |`

Супер! Мы подготовили данные по количеству книг, добавленных каждый месяц. И теперь надо посчитать накопительный итог по колонке **`cnt`**. Для этого вызываем агрегатную функцию **`sum`** как оконную, то есть со словом **`over`**. Каждую агрегатную функцию можно вызвать как оконную со словом **`OVER`**.

`select ms as year_month,
    coalesce(cnt, 0) cnt,
    sum(coalesce(cnt, 0)) over (order by ms) cumulative_count
from generate_series(
    DATE '2024-01-01',
    DATE '2024-06-01',
    INTERVAL '1 month'
) as ms
left join (
    select date_trunc('month', created_at) created_month, count(*) as cnt
    from book b
    group by date_trunc('month', created_at)
) books on ms = books.created_month
order by year_month;

|year_month                   |cnt|cumulative_count|
|*-----------------------------|---|----------------|*|2024-01-01 00:00:00.000 +0300|2  |2               |
|2024-02-01 00:00:00.000 +0300|1  |3               |
|2024-03-01 00:00:00.000 +0300|1  |4               |
|2024-04-01 00:00:00.000 +0300|0  |4               |
|2024-05-01 00:00:00.000 +0300|3  |7               |
|2024-06-01 00:00:00.000 +0300|3  |10              |`

Отлично!

Итак, любую агрегатную функцию можно использовать как оконную со словом **`OVER`**. Сумма, среднее значение, минимум, максимум и так далее.

И есть непосредственно оконные функции, для их использования тоже нужно слово **`OVER`**, но при этом эти функции специально предназначены для работы как оконные функции:

- **`row_number()`** мы уже видели, эта оконная функция выводит номер строки в текущем разделе
- **`rank()`** и **`dense_rank()`**, эти оконные функции выводят ранг в разделе, то есть место в разделе как в рейтинге. Если **`row_number()`** выводит уникальные номера строк, то **`rank()`** выводит так называемый ранг в разделе, то есть если значения колонок в оконном **`order by`** будут одинаковы, то и **`rank`** будет одинаковым. Например, есть таблица с игроками и их баллами в игре и мы хотим каждому игроку добавить рейтинг по его баллам. Понятно, что если баллы одинаковые, то и место в рейтинге должно быть одинаковое. Вот эту задачу решает **`rank()`** и **`dense_rank()`**. Посмотрим разницу:

`select
    gamer_id,
    gamer_name,
    game_points,
    row_number() OVER (ORDER BY game_points DESC) AS gamer_rating
from
    (values
        (1, 'Василий', 150),
        (2, 'Иван', 100),
        (3, 'Пётр', 150),
        (4, 'Иннокентий Иванович', 200)
    ) as gamers(gamer_id, gamer_name, game_points)
order by gamer_rating;

|gamer_id|gamer_name         |game_points|gamer_rating|
|*--------|-------------------|-----------|------------|*|4       |Иннокентий Иванович|200        |1           |
|1       |Василий            |150        |2           |
|3       |Пётр               |150        |3           |
|2       |Иван               |100        |4           |

select
    gamer_id,
    gamer_name,
    game_points,
    rank() OVER (ORDER BY game_points DESC) AS gamer_rating
from
    (values
        (1, 'Василий', 150),
        (2, 'Иван', 100),
        (3, 'Пётр', 150),
        (4, 'Иннокентий Иванович', 200)
    ) as gamers(gamer_id, gamer_name, game_points)
order by gamer_rating;

|gamer_id|gamer_name         |game_points|gamer_rating|
|*--------|-------------------|-----------|------------|*|4       |Иннокентий Иванович|200        |1           |
|1       |Василий            |150        |2           |
|3       |Пётр               |150        |2           |
|2       |Иван               |100        |4           |

select
    gamer_id,
    gamer_name,
    game_points,
    dense_rank() OVER (ORDER BY game_points DESC) AS gamer_rating
from
    (values
        (1, 'Василий', 150),
        (2, 'Иван', 100),
        (3, 'Пётр', 150),
        (4, 'Иннокентий Иванович', 200)
    ) as gamers(gamer_id, gamer_name, game_points)
order by gamer_rating;

|gamer_id|gamer_name         |game_points|gamer_rating|
|*--------|-------------------|-----------|------------|*|4       |Иннокентий Иванович|200        |1           |
|1       |Василий            |150        |2           |
|3       |Пётр               |150        |2           |
|2       |Иван               |100        |3           |`

Как видите, разница между **`rank()`** и **`dense_rank()`** только в том, пропускают ли они номера в рейтинге. **`rank()`** пропускает, а **`dense_rank()`** нет.

- **`first_value(column)`**. Оооочень удобная функция, потому что возвращает значение колонки из первой строки раздела.

Есть ещё и другие оконные функции, например, **`lead`**, **`lag`**, **`ntile`** и другие. О них можно почитать в документации.

Ещё стоит отметить, что окно можно задавать также в отдельном блоке, что удобно, если на одно и то же окно надо ссылаться несколько раз из запроса:

`select
    gamer_id,
    gamer_name,
    game_points,
    dense_rank() OVER (w) AS gamer_rating
from
    (values
        (1, 'Василий', 150),
        (2, 'Иван', 100),
        (3, 'Пётр', 150),
        (4, 'Иннокентий Иванович', 200)
    ) as gamers(gamer_id, gamer_name, game_points)
    window w as (ORDER BY game_points DESC)
order by gamer_rating;`

Как понять, что вам в вашей задаче нужна оконная функция?

Оконные функции помогают выполнять вычисления над группами строк, но при этом не схлопывая эти группы строк в одну строку, как это делает **`group by`**. Можно нумеровать строки, можно выбирать первое значение в группе, можно считать сумму группы целиком или накопительным итогом и другие операции. Если в вашей задаче нужно что-то такое — вам нужны оконные функции!

## Короткое уточнение про использование

Оконные функции в PostgreSQL используются для выполнения вычислений по строкам набора данных, разделённым на группы, называемые "окнами". Они позволяют выполнять такие задачи, как вычисление скользящих сумм, ранжирование строк и получение агрегатов по частям набора данных, сохраняя исходные строки в результате.

Основное отличие оконных функций от обычных агрегатных функций в том, что оконные функции не сокращают количество строк в результате.

### Основные примеры использования оконных функций

1. **Ранжирование строк**: можно использовать функции `ROW_NUMBER()`, `RANK()`, `DENSE_RANK()` для присвоения ранга строкам.
2. **Скользящее суммирование**: использование оконной функции для получения накопительной суммы.
3. **Разбиение на группы с сохранением строк**: агрегирование данных по группам, сохраняя при этом детали каждой строки.

### Примеры

1. **`ROW_NUMBER()`**: Присваивает уникальный порядковый номер строкам в каждой группе в зависимости от сортировки.

```sql
SELECT
    employee_id,
    department_id,
    salary,
    ROW_NUMBER() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank
FROM employees;
```

Здесь для каждого отдела (`department_id`) сотрудники будут ранжированы по их зарплатам. Функция `PARTITION BY` разделяет данные на окна по отделам, а `ORDER BY` внутри окна сортирует сотрудников по зарплатам.

1. **`RANK()` и `DENSE_RANK()`**: Обе функции также ранжируют строки, но работают по-разному при наличии одинаковых значений:

```sql
SELECT
    employee_id,
    department_id,
    salary,
    RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS rank,
    DENSE_RANK() OVER (PARTITION BY department_id ORDER BY salary DESC) AS dense_rank
FROM employees;
```

- `RANK()` пропускает ранги при наличии одинаковых значений (например, если две строки имеют одинаковую зарплату и занимают 1-е место, следующая строка получит 3-й ранг).
- `DENSE_RANK()` присваивает последовательные ранги без пропусков.
1. **Накопительная сумма (`SUM() OVER`)**:

```sql
SELECT
    employee_id,
    salary,
    SUM(salary) OVER (ORDER BY employee_id) AS cumulative_salary
FROM employees;
```

Эта функция возвращает накопительную сумму зарплат, отсортированных по `employee_id`.

1. **Агрегатная функция с сохранением строк**:

Допустим, нужно узнать максимальную зарплату по каждому отделу, но при этом сохранить все строки:

```sql
SELECT
    employee_id,
    department_id,
    salary,
    MAX(salary) OVER (PARTITION BY department_id) AS max_salary_in_department
FROM employees;
```

Здесь выводятся все сотрудники с их зарплатами, и для каждого сотрудника показывается максимальная зарплата в его отделе.

### Заключение

Оконные функции полезны, когда нужно выполнить вычисления над группами строк, сохраняя оригинальные строки. Это инструмент для анализа данных, который позволяет легко выполнять такие задачи, как ранжирование, скользящее суммирование и агрегирование по группам.