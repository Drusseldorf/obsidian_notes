# 11.31 Работа с массивами

Массивы в PostgreSQL позволяют хранить несколько значений одного типа данных в одном столбце таблицы. Однако, на практике использование массивов в базе данных не всегда оправдано, так как это нарушает принципы нормализации, где в поле должно храниться одно значение. Но в некоторых случаях, когда все данные в массиве используются совместно, такое использование может быть уместным.

### Создание таблицы с массивами

Для начала создадим таблицу, которая содержит массивы различных типов:

```sql
CREATE TABLE some_entity (
    entity_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    int_array INT[],       -- Массив с типом INTEGER
    text_array TEXT[],     -- Массив с типом TEXT
    date_array DATE[]      -- Массив с типом DATE
);
```

### Вставка данных в массивы

Данные в массивы вставляются в виде списка значений, заключенного в фигурные скобки `{}`:

```sql
INSERT INTO some_entity (int_array, text_array, date_array) VALUES (
    '{100, 255, 328}',
    '{"Алексей", "Пётр", "Василий"}', -- Для строк в массиве используются двойные кавычки
    '{"2024-06-25", "2024-06-26", "2024-01-01"}'
);
```

### Извлечение элементов из массива

Для извлечения элементов массива используется синтаксис с указанием индекса. Напоминаю, что в PostgreSQL индексация начинается с 1:

```sql
SELECT int_array[1], text_array[1], date_array[1] FROM some_entity;
```

Этот запрос вернет первые элементы из каждого массива.

### Добавление элементов в массив

Чтобы добавить элемент в массив, можно использовать функцию `array_append`:

```sql
UPDATE some_entity SET int_array = array_append(int_array, 777);
```

### Получение длины массива

Функция `array_length` позволяет узнать количество элементов в массиве:

```sql
SELECT array_length(int_array, 1) FROM some_entity;
```

Здесь `1` указывает на размерность массива.

### Проверка наличия элемента в массиве

Для проверки, содержится ли элемент в массиве, используется выражение `element = ANY(array)`:

```sql
SELECT int_array FROM some_entity WHERE 777 = ANY(int_array);

SELECT int_array FROM some_entity WHERE 12345 = ANY(int_array);
```

### Преобразование массива в строку

Функция `array_to_string` позволяет преобразовать массив в строку, используя заданный разделитель:

```sql
SELECT array_to_string('{10, 20, 30}'::INTEGER[], ', '); -- Вернет '10, 20, 30'

SELECT 'Список: ' || array_to_string('{10, 20, 30}'::INTEGER[], ', '); -- Вернет 'Список: 10, 20, 30'
```

### Преобразование строки в массив

Для преобразования строки в массив используется функция `string_to_array`:

```sql
SELECT string_to_array('100, 200, 333', ', '); -- Преобразует строку в массив

SELECT (string_to_array('100, 200, 333', ', '))[1]; -- Вернет 100
SELECT (string_to_array('100, 200, 333', ', '))[2]; -- Вернет 200
SELECT (string_to_array('100, 200, 333', ', '))[3]; -- Вернет 333
```

### Функция `unnest`

Функция `unnest` преобразует массив в набор строк, что позволяет работать с каждым элементом массива как с отдельной строкой в таблице:

```sql
SELECT '{Василий, Пётр, Алексей}'::TEXT[]; -- Есть массив

SELECT unnest('{Василий, Пётр, Алексей}'::TEXT[]); -- Преобразует массив в таблицу с тремя строками

SELECT unnest(string_to_array('Василий, Пётр, Алексей', ', ')); -- Преобразует строку в массив, затем в таблицу строк

SELECT unnest(string_to_array('Василий, Пётр, Алексей', ', ')) AS t
ORDER BY t; -- Чтобы отсортировать результат, нужно дать алиас и сортировать по нему
```

### Заключение

Массивы в PostgreSQL предоставляют мощные возможности для хранения и манипуляции множеством значений в одном столбце. Тем не менее, их использование следует ограничивать, чтобы избежать нарушения принципов нормализации и сложностей при работе с данными. В ситуациях, когда все элементы массива используются совместно, массивы могут быть оправданным выбором.