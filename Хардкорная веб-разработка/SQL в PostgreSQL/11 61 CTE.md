# 11.61 CTE

CTE (Common Table Expression) создаёт временную виртуальную таблицу, которая существует только во время запроса, и позволяет использовать эту таблицу в самом запросе:

```sql
WITH book_details AS (
    SELECT 
        b.book_id, 
        b.name AS book_name, 
        a.name AS author_name,
        c.name AS category_name
    FROM 
        book b
    JOIN 
        book_to_author ba ON b.book_id = ba.book_id
    JOIN 
        author a ON ba.author_id = a.author_id
    JOIN 
        book_to_category bc ON b.book_id = bc.book_id
    JOIN 
        book_category c ON bc.category_id = c.category_id
)
SELECT 
    book_id, 
    book_name, 
    author_name, 
    category_name
FROM 
    book_details;
```

CTE задаётся с помощью слова **`WITH`**. Здесь у нас создаётся та самая виртуальная таблица с именем **`book_details`**, она наполняется данными соответствующего запроса. И выборка производится уже из этой таблицы ниже. В таком случае CTE просто разделяет логику соединения данных и логику выборки данных, упрощая чтение и понимание длинного SQL-запроса.

Здесь мы из основного запроса только 1 раз ссылаемся на результаты запроса в CTE

В некоторых случаях CTE могут также увеличивать производительность запроса, но об этом мы поговорим в следующей главе, они бывают материализованные и нет, так же как и вьюшки-представления, вот дальше это всё выясним, и как оно влияет на производительность тоже.

Важно ещё то, что в CTE может быть не только **`SELECT`**, но и **`INSERT`**, и **`UPDATE`**, и **`DELETE`**. Мы это уже использовали здесь на курсе в уроке «Работа с boolean», напомню:

`with deleted_rows as (
    delete from some_entity
    where entity_id=3
    returning *
)
insert into some_entity_deleted select * from deleted_rows;`

Здесь мы удаляем записи из **`some_entity`**, с помощью **`returning *`** возвращаем из этого подзапроса удалённые строки и в основном запросе используем эти данные для вставки в **`some_entity_deleted`**. Таким образом в **`some_entity_deleted`** будут храниться удалённые из таблицы **`deleted_rows`** записи. Причём что круто — эта операция атомарна, то есть либо весь этот запрос выполнится, либо весь не выполнится. Не будет такого, что данные из одной таблицы удалятся, а в другую таблицу не вставятся.

Также CTE могут помогать писать рекурсивные запросы, когда CTE ссылается сам на себя же. Не использовал это на практике, не было необходимости, но знайте, что такая возможность есть — если пригодится, почитаете и сможете реализовать.