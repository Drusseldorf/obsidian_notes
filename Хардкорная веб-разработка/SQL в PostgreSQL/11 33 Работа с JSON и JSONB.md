# 11.33 Работа с JSON и JSONB

PostgreSQL поддерживает работу с JSON и JSONB — двумя типами данных, которые позволяют хранить неструктурированные данные в формате JSON.

### Разница между `json` и `jsonb`

1. **`jsonb`**:
    - Хранится в **бинарном виде**, что позволяет PostgreSQL парсить и хранить данные более эффективно.
    - Это лучший выбор для данных, с которыми предполагается активная работа (поиск, фильтрация и т.д.).
2. **`json`**:
    - Хранит данные **так, как они были переданы**, включая пробелы и форматирование.
    - Может быть полезен, если важна точная передача данных, включая формат.

### Пример создания таблицы с `jsonb`

Создадим временную таблицу `book_json`, где будем хранить данные о книгах в формате JSONB:

```sql
CREATE TEMP TABLE book_json (
    book_id BIGINT GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    data JSONB NOT NULL
);
```

### Вставка данных в формате JSONB

Пример вставки данных в таблицу:

```sql
INSERT INTO book_json (data) VALUES
    ('{"name": "Тихий Дон", "author_id": 1, "description": "Хорошая книга"}'),
    ('{"name": "Python. К вершинам мастерства", "author_id": 2, "description": "Лучшая книга по углубленному изучению Python.", "pages": 898}');
```

### Извлечение данных из JSON

Для работы с данными в формате JSON используется оператор `->>` для получения значения по ключу в виде строки.

- **`>`**: Этот оператор возвращает **JSON-объект** или **значение** в формате JSON. То есть, если вы используете `>`, PostgreSQL вернёт значение **как JSON**. Это полезно, если нужно работать с вложенными структурами JSON.
- **`>>`**: Этот оператор возвращает значение, преобразованное в тип **TEXT**. Это удобно, если вы хотите получить строковое представление значения для дальнейшей обработки, например, для сравнения или конкатенации.

1. **Выборка всех данных**:
    
    ```sql
    SELECT book_id, data FROM book_json;
    ```
    
2. **Извлечение конкретных полей**:
    
    ```sql
    SELECT
        book_id,
        data->>'name' AS name,
        data->>'description' AS description,
        data->>'pages' AS pages
    FROM book_json;
    ```
    
3. **Фильтрация данных по условию на поле внутри JSON**:
    - Получение всех книг, у которых количество страниц больше 500:
    
    ```sql
    SELECT *
    FROM book_json
    WHERE (data->>'pages')::int > 500;
    ```
    
    - Получение всех книг, у которых поле `pages` не пустое:
    
    ```sql
    SELECT *
    FROM book_json
    WHERE data->>'pages' IS NOT NULL;
    ```
    
4. **Проверка наличия ключа в JSON**:
    
    Для проверки наличия ключа в JSON используется оператор `?`. Например, проверим, что в данных книги есть ключ `name`:
    
    ```sql
    SELECT *
    FROM book_json
    WHERE data ? 'name';
    ```
    

### Примеры сложных запросов с JSONB

1. **Выборка и преобразование типов данных**:
    - Получение всех книг, где количество страниц больше 500, с преобразованием значения `pages` к типу `INT`:
    
    ```sql
    SELECT
        data->>'name' AS name,
        data->>'author_id' AS author_id,
        data->>'description' AS description,
        (data->>'pages')::int AS pages
    FROM book_json
    WHERE (data->>'pages')::int > 500;
    ```
    

### Дополнительные возможности `jsonb`

`jsonb` предоставляет множество возможностей для работы с неструктурированными данными:

1. **Проверка наличия ключа**:
    - `data ? 'name'` — проверяет наличие ключа `name` в JSON-объекте.
2. **Проверка на NULL**:
    - `data->>'name' IS NOT NULL` — проверяет, что значение по ключу `name` не является NULL.
3. **Преобразование типов**:
    - `(data->>'pages')::INT > 0` — проверяет, что значение по ключу `pages` можно привести к типу `INT` и оно больше нуля.

ps. Не знаю зачем, но вот тебе возможность наложить ограничения на джисон при создании таблицы:

```sql
create table book_json (
    book_id bigint generated always as identity primary key,
    data jsonb not null check (
        data->>'name' is not null and
        data->>'pages' is not null and
        (data->>'pages')::int > 0
    )
);
```