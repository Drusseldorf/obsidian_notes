# 11.28 Работа с перечислениями

В PostgreSQL можно создавать перечисления (enum), которые позволяют определять кастомные типы данных. 

### Создание перечисления

Перечисление создается с помощью команды `CREATE TYPE`. Оно определяет новый тип данных, который ограничен фиксированным набором строковых значений.

Пример:

```sql
CREATE TYPE day_of_week AS ENUM (
    'понедельник',
    'вторник',
    'среда',
    'четверг',
    'пятница',
    'суббота',
    'воскресенье'
);
```

Теперь этот кастомный тип данных `day_of_week` можно использовать в таблицах.

### Использование перечисления в таблице

Создадим таблицу, где один из столбцов будет иметь тип данных `day_of_week`:

```sql
CREATE TABLE advertiser_support_work_time (
    day_of_week day_of_week PRIMARY KEY,
    start_time TIME NOT NULL,
    end_time TIME NOT NULL
);
```

Здесь столбец `day_of_week` использует наш кастомный тип данных `day_of_week` и является первичным ключом.

### Вставка данных в таблицу с перечислением

Вставка значений в столбец с типом данных `ENUM` осуществляется аналогично строкам:

```sql
INSERT INTO advertiser_support_work_time (day_of_week, start_time, end_time) VALUES
    ('понедельник', '09:00:00', '19:00:00'),
    ('вторник', '09:00:00', '19:00:00'),
    ('среда', '09:00:00', '19:00:00'),
    ('четверг', '09:00:00', '19:00:00'),
    ('пятница', '09:00:00', '19:00:00'),
    ('суббота', '10:00:00', '19:00:00'),
    ('воскресенье', '10:00:00', '19:00:00');
```

### Особенности хранения перечислений

Хотя значения перечисления (ENUM) выглядят как строки, фактически они хранятся как числа. Это позволяет экономить память и делает работу с данными более эффективной:

```sql
SELECT pg_column_size('воскресенье'); -- 23 байта
SELECT pg_column_size('воскресенье'::day_of_week); -- 4 байта
```

Видно, что значение `ENUM` занимает значительно меньше места, чем строка.

**Важно:** При добавлении новых значений в существующий тип `ENUM` может возникнуть кратковременная блокировка таблиц, которые используют это перечисление. Поэтому стоит проектировать перечисления таким образом, чтобы минимизировать необходимость их изменения в будущем.

### Альтернативы перечислениям

Иногда использование перечислений может быть не самым гибким решением. Рассмотрим два альтернативных подхода.

1. **Использование ограничения `CHECK`**:
    
    Вместо использования перечисления можно создать столбец типа `VARCHAR` и добавить ограничение `CHECK`, которое будет проверять допустимость значений:
    
    ```sql
    CREATE TABLE advertiser_support_work_time (
        day_of_week VARCHAR(11) PRIMARY KEY CHECK(day_of_week IN (
            'понедельник',
            'вторник',
            'среда',
            'четверг',
            'пятница',
            'суббота',
            'воскресенье'
        )),
        start_time TIME NOT NULL,
        end_time TIME NOT NULL
    );
    ```
    
    Это позволяет ограничить допустимые значения для столбца, но при этом сохраняется гибкость работы с обычными строками.
    
2. **Создание справочника (lookup table)**:
    
    На практике часто создается отдельная таблица-справочник для хранения фиксированных наборов значений. Например, таблица `days_of_week`:
    
    ```sql
    CREATE TABLE days_of_week (
        id SERIAL PRIMARY KEY,
        day_name VARCHAR(11) UNIQUE NOT NULL
    );
    
    INSERT INTO days_of_week (day_name) VALUES
        ('понедельник'),
        ('вторник'),
        ('среда'),
        ('четверг'),
        ('пятница'),
        ('суббота'),
        ('воскресенье');
    ```
    
    Таблица `advertiser_support_work_time` будет ссылаться на эту справочную таблицу:
    
    ```sql
    CREATE TABLE advertiser_support_work_time (
        day_id INT REFERENCES days_of_week(id) PRIMARY KEY,
        start_time TIME NOT NULL,
        end_time TIME NOT NULL
    );
    ```
    
    Этот подход более гибкий, так как изменения в справочной таблице не требуют изменения структуры основной таблицы.