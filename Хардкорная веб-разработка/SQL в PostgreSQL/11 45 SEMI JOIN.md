# 11.45 SEMI JOIN

`SEMI JOIN` — это тип соединения, который возвращает строки из одной таблицы, если существует хотя бы одна соответствующая строка в другой таблице. В отличие от обычных соединений, он не возвращает данные из обеих таблиц, а только строки из первой таблицы.

Пример запроса:

```sql
SELECT b.name
FROM book b
WHERE EXISTS (
    SELECT 1 FROM author a WHERE a.author_id = b.author_id
);
```

Этот запрос вернёт названия книг, у которых есть соответствующий автор. Книги без авторов не будут возвращены.

### Альтернативный синтаксис через `IN`:

```sql
SELECT b.name
FROM book b
WHERE b.author_id IN (
    SELECT author_id FROM author
);
```

Хотя синтаксис с `IN` может работать, **`EXISTS`** более предпочтителен в таких ситуациях, так как лучше выражает намерения и может быть оптимизирован более эффективно.

### Пример задачи с SEMI JOIN:

**Задача:** Достать имена всех наблюдателей, которые наблюдали птиц семейства Синицевые, и дату наблюдения. Сортировка по имени наблюдателя.

### Пример решения в лоб, через EXISTS:

1. Найти семейство "Синицевые":
    
    ```sql
    SELECT family_id FROM family WHERE family_name = 'Синицевые';
    ```
    
2. Найти роды, связанные с этим семейством:
    
    ```sql
    SELECT genus_id FROM genus g WHERE EXISTS (
        SELECT 1 FROM family f WHERE family_name = 'Синицевые' AND f.family_id = g.family_id
    );
    ```
    
3. Найти виды, связанные с найденными родами:
    
    ```sql
    SELECT species_id FROM species s WHERE EXISTS (
        SELECT 1 FROM genus g WHERE EXISTS (
            SELECT 1 FROM family f WHERE family_name = 'Синицевые' AND f.family_id = g.family_id
        ) AND g.genus_id = s.genus_id
    );
    ```
    
4. Получить наблюдения:
    
    ```sql
    SELECT observer_name, observation_date
    FROM observations o
    WHERE EXISTS (
        SELECT 1 FROM species s WHERE EXISTS (
            SELECT 1 FROM genus g WHERE EXISTS (
                SELECT 1 FROM family f WHERE family_name = 'Синицевые' AND f.family_id = g.family_id
            ) AND g.genus_id = s.genus_id
        ) AND s.species_id = o.species_id
    )
    ORDER BY observer_name
    ```
    

### Альтернативный вариант без `EXISTS`:

```sql
SELECT observer_name, observation_date
FROM observations
JOIN species s USING(species_id)
JOIN genus g USING(genus_id)
JOIN family f USING(family_id)
WHERE family_name = 'Синицевые'
ORDER BY observer_name;
```

В этом варианте используется `JOIN` без `EXISTS` или `IN`, что делает запрос более лаконичным.

## Разбор второго решения по шагам

### 1. `FROM observations`

Запрос начинается с таблицы `observations`, в которой хранятся данные о наблюдениях птиц. Эта таблица содержит информацию о наблюдателях и датах их наблюдений, а также ссылки на виды птиц через колонку `species_id`.

**Пример данных:**

| observation_id | observer_name | observation_date | species_id |
| --- | --- | --- | --- |
| 1 | Иванов | 2024-07-01 | 1 |
| 2 | Сидоров | 2024-07-02 | 2 |

### 2. `JOIN species s USING(species_id)`

Теперь мы присоединяем таблицу `species`, которая содержит информацию о видах птиц. Она соединяется с таблицей наблюдений по столбцу `species_id`, чтобы связать каждое наблюдение с видом птицы.

**Пример данных:**

| species_id | species_name | genus_id |
| --- | --- | --- |
| 1 | Большая синица | 1 |
| 2 | Синица лазоревка | 1 |
| 3 | Ворон обыкновенный | 2 |

Здесь `species_id` связывает наблюдения с конкретным видом птицы.

### 3. `JOIN genus g USING(genus_id)`

Затем идёт соединение с таблицей `genus`, где хранится информация о родах птиц. Эта таблица связывается через `genus_id` с таблицей видов (`species`). Таким образом, для каждого вида мы находим его род.

**Пример данных:**

| genus_id | genus_name | family_id |
| --- | --- | --- |
| 1 | Синица | 1 |
| 2 | Ворон | 2 |

### 4. `JOIN family f USING(family_id)`

Следующим шагом присоединяем таблицу `family`, которая хранит информацию о семействах птиц. Мы соединяем её с таблицей родов по колонке `family_id`.

**Пример данных:**

| family_id | family_name |
| --- | --- |
| 1 | Синицевые |
| 2 | Врановые |

### 5. `WHERE family_name = 'Синицевые'`

Теперь, когда все таблицы соединены, мы можем применить фильтр: нам нужны только те наблюдения, где вид птиц относится к семейству "Синицевые". Мы выбираем только те записи, для которых `family_name = 'Синицевые'`.

Это условие фильтрует наблюдения, оставляя только тех птиц, которые относятся к семейству с названием "Синицевые".

### 6. `ORDER BY observer_name`

На последнем шаге мы сортируем результат по имени наблюдателя (`observer_name`), чтобы данные были выведены в удобном для анализа виде.

### Результат:

После всех соединений и фильтраций запрос возвращает наблюдения только тех видов, которые относятся к семейству "Синицевые", с указанием имени наблюдателя и даты наблюдения.

**Пример результата:**

| observer_name | observation_date |
| --- | --- |
| Иванов | 2024-07-01 |
| Сидоров | 2024-07-02 |

### Что происходит шаг за шагом:

1. **`observations`** – начинаем с таблицы наблюдений.
2. **`species`** – к каждому наблюдению находим соответствующий вид птицы.
3. **`genus`** – для каждого вида находим его род.
4. **`family`** – для каждого рода находим его семейство.
5. **Фильтр** – оставляем только те виды, которые принадлежат семейству "Синицевые".
6. **Сортировка** – сортируем по имени наблюдателя.

Запрос эффективен и лаконичен, так как использует стандартные `JOIN`, что даёт точный результат для связанной структуры данных.