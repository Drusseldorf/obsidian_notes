### Unittest в Django и проект YaNews

**Суть**: в Django встроен собственный модуль для тестирования, основанный на стандартной библиотеке `unittest`. Он расширен методами для тестирования Django-проектов (работа с моделями, шаблонами, URL’ами и т.п.).

---

#### Проект YaNews

- Сайт с новостями и комментариями.
    
- Главная страница показывает 10 последних новостей в сокращённом виде (только первые 15 слов).
    
- У каждой новости есть отдельная страница с полным текстом и комментариями.
    
- Любой может зарегистрироваться.
    
- Авторизованный пользователь:
    
    - может оставлять комментарии, редактировать и удалять **только свои** комментарии;
        
    - при попытке удалить или отредактировать чужие комментарии — получит ошибку.
        
- В проекте есть список запрещённых слов, например «редиска», «негодяй»; комментарий с такими словами не публикуется.
    
- Для работы с проектом:
    
    1. Склонировать репозиторий.
        
    2. Создать виртуальное окружение, установить зависимости из `requirements.txt`.
        
    3. Выполнить миграции, создать суперпользователя, загрузить фикстуры (новости) через `python manage.py loaddata news.json`.
        
    4. Запустить проект (`python manage.py runserver`).
        

---

### План тестирования YaNews

**Будем тестировать** (файлы и что проверяется):

1. **`test_routes.py`**
    
    - Главная страница доступна анониму.
        
    - Страница отдельной новости доступна анониму.
        
    - Страницы удаления и редактирования комментария доступны **только автору** комментария.
        
    - Аноним при попытке редактировать/удалять комментарий — перенаправляется на страницу логина.
        
    - Авторизованный пользователь **не** может редактировать/удалять чужие комментарии (получает 404).
        
    - Страницы регистрации, входа и выхода доступны анониму.
        
2. **`test_content.py`**
    
    - На главной странице не более 10 новостей.
        
    - Новости отсортированы от **самой свежей** к самой старой.
        
    - Комментарии на странице новости: от старых к новым.
        
    - Анониму недоступна форма отправки комментария, авторизованному доступна.
        
3. **`test_logic.py`**
    
    - Аноним не может отправить комментарий.
        
    - Авторизованный пользователь может отправить комментарий.
        
    - Если комментарий содержит запрещённые слова, он не публикуется, а форма возвращает ошибку.
        
    - Авторизованный пользователь может редактировать и удалять **только свои** комментарии.
        
    - Редактировать/удалять чужие комментарии нельзя.
        

**Не тестируем**:

- Процесс регистрации, авторизации и выхода (это штатный функционал Django).
    
- Админ-зону.
    
- Абсолютные URL (используем `reverse('name')`).
    
- Какие конкретно шаблоны подключаются и как отображают данные (предполагаем, что шаблоны работают корректно).
    
- Всё, что не указано в списке «Будем тестировать».
    

**Запуск тестов**:

```bash
python manage.py test
```

- Django ищет файлы, начинающиеся на `test*.py`, во всех директориях внутри проекта.
    
- Если тестов нет, будет `Ran 0 tests in ... OK`.
    

---

### Где живут тесты в Django

При `python manage.py startapp <app_name>` создаётся файл `tests.py`. На практике лучше перенести всё в пакет `tests` и удалить `tests.py`, чтобы не было путаницы:

```
<app_name>/
├── migrations/
├── __init__.py
├── admin.py
├── apps.py
├── models.py
├── views.py
├── tests/                # Пакет для тестов
│   ├── __init__.py
│   ├── test_content.py
│   ├── test_logic.py
│   ├── test_routes.py
│   └── test_trial.py
```

#### Два основных подхода к структуре файлов с тестами

1. **По исходному коду** (test_models.py, test_views.py, test_urls.py, test_forms.py и т.д.).
    
    - Минус: если логика приложения «размазана» по моделям, вьюхам, адресам, формам — непонятно, где конкретно проверять целостную бизнес-логику.
        
2. **По функциональному признаку** (как в уроке):
    
    - `test_routes.py` (проверка доступности эндпоинтов, редиректов, ограничений по правам).
        
    - `test_content.py` (какие данные и в какой сортировке отображаются, работа пагинации, скрытие формы для анонима и т.д.).
        
    - `test_logic.py` (проверка бизнес-логики, как обрабатываются формы, запрещённые слова и т.п.).
        

В реальных проектах применяются разные вариации этих схем, выбор зависит от удобства команды разработки.

---

### Задание на будущее

1. В YaNews (по описанному плану) создать пакет `tests` и в нём пять пустых файлов:
    
    ```
    __init__.py
    test_content.py
    test_logic.py
    test_routes.py
    test_trial.py
    ```
    
    Именно в них будет писаться код тестов.
    
2. Для другого проекта — **YaNote** — клонировать репозиторий, настроить виртуальное окружение, познакомиться с кодом.
    
    - Особенность: поле `slug` в модели заметок генерируется автоматически (транслитерация названия), если не заполнено. Должно оставаться уникальным.
        
    - **Написать план тестирования** (аналогично плану для YaNews), чтобы потом реализовать тесты.
        

---

### Best practices от опытных разработчиков (Django + unittest)

1. **Используйте `TestCase`** (а не просто `unittest.TestCase`), чтобы Django автоматически создавала/очищала тестовую базу данных между тестами.
    
2. **`Client`** и «интеграционные» проверки: для проверки маршрутов (`/urls/`) и авторизации удобно использовать встроенный `django.test.Client`.
    
3. **Фикстуры (fixtures) и фабрики (factory_boy)**:
    
    - При сложных связях моделей удобно использовать фабрики (или Pytest + factory_boy) для генерации тестовых объектов.
        
    - Django фикстуры (`.json`, `loaddata`) позволяют подгружать готовые объекты в БД перед тестами.
        
4. **`setUpTestData()`** (или Pytest-фикстуры) может быть эффективнее, чем `setUp()`, когда нужно создать неизменяемые объекты один раз на весь класс, сокращая общее время тестирования.
    
5. **Минимизируйте «лишние» тесты Django-фреймворка**: не тратьте ресурсы на проверку стандартной логики (регистрация, логин) — команда Django уже оттестировала это. Тестируйте **свою** бизнес-логику и возможные узкие места.
    
6. **Разделяйте уровни тестирования**: иногда достаточно «системных» (end-to-end) проверок, в других случаях полезны «юнит-тесты» на отдельные модули. Старайтесь найти баланс, чтобы покрыть критические части без избыточных дублирований.
    
7. **Структура файлов** должна быть понятна всей команде: выберите логику (по функционалу или по компонентам) и придерживайтесь её.
    
8. **Используйте `reverse()`** при тестах URL: меньше вероятности опечаток в путях, и если URL изменится, тесты нужно править в одном месте.
    

Все перечисленные приёмы повышают читаемость и надёжность тестов, упрощают поддержку и развитие проекта.