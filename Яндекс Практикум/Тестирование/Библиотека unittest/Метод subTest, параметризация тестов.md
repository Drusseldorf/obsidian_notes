**Задача**  
Проверять работу одной и той же функции или логики на разных наборах данных без дублирования тестов. В `unittest` для этого используется метод `subTest()` — он позволяет выполнять несколько проверок в рамках одного тест-метода с разными входными данными.

---

**Пример №1**

```python
from unittest import TestCase

def get_square(num):
    """Возвращает квадрат полученного аргумента"""
    return num ** 2

class TestExample(TestCase):

    def test_square(self):
        """Тест возведения в квадрат."""
        # Проверим три утверждения: (value -> expected_result)
        values_results = (
            (2, 4),   # ОК
            (3, 10),  # Упадёт
            (4, 20),  # Упадёт
        )
        for value, expected_result in values_results:
            with self.subTest():
                result = get_square(value)
                self.assertEqual(result, expected_result)
```

**Пояснения**

- `subTest()` используется как контекстный менеджер `with self.subTest(...):`.
    
- При каждом проходе цикла внутри `subTest()` можно указывать:
    
    - **Именованные аргументы**:
        
        ```python
        with self.subTest(value=value, expected=expected_result):
            ...
        ```
        
        Тогда при падении теста будет видно, какие именно параметры привели к ошибке.
        
    - **Сообщение об ошибке (msg)**:
        
        ```python
        with self.subTest(
            value=value,
            expected_result=expected_result,
            msg=f'Число {value}, ожидалось {expected_result}'
        ):
            ...
        ```
        

**Что записывать в набор данных**

- Для параметризации часто используют **кортежи**: они не требуют дополнительной памяти для «изменяемости», позволяют неуникальные элементы и легко распаковываются.
    
- Можно использовать любой итерируемый объект (списки, кортежи, словари, генераторы и т. д.) — жёстких стандартов нет.
    

---

**Best practices от опытных разработчиков**

1. **Не дублировать тесты**: вместо копирования одинакового кода используйте `subTest()` для разных входных данных.
    
2. **Именованные аргументы в `subTest()`** делают отчёты понятнее: сразу видно, на каких именно данных тест провалился.
    
3. **Докстринги или комментарии** в тестах: полезно, когда тестов становится много; описывайте, зачем нужен конкретный тест и что он проверяет.
    
4. **Вычисление сложных входных данных**: если требуется сгенерировать массив чисел или сложные структуры, делайте это единообразно (через фикстуры/хелперы), чтобы не засорять сами тесты лишним кодом.
    
5. **Логическое объединение набора тестовых данных**: если параметров много, группируйте их в понятные структуры, чтобы любой разработчик сразу понимал, что проверяется.
    
6. **Используйте кортежи** для статичных наборов данных, когда нет необходимости в изменении списка. При больших объёмах данных задумайтесь о производительности и вместимости (кортежи занимают меньше памяти, чем списки).