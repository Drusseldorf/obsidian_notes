**Фикстуры `pytest`** — это функции с декоратором `@pytest.fixture`, которые:

1. Готовят данные или окружение перед тестами и (при необходимости) «убирают» после.
    
2. Могут быть переиспользованы в разных тестах, **без** дублирующего кода.
    
3. Вызываются **явно** в параметрах тестов или через маркеры (`@pytest.mark.usefixtures`), либо автоматически (с `autouse=True`).
    

---

### Основная идея

- В `unittest` мы используем `setUp()`/`tearDown()` или `setUpClass()`/`tearDownClass()` для фикстур.
    
- В `pytest` каждая фикстура — отдельная функция, **не привязанная** к классу.
    
- Мы явно указываем нужную фикстуру в **параметрах** теста.
    

**Пример**:

```python
import pytest

@pytest.fixture
def give_me_a_string():
    return "Какой чудесный день!"

def test_string_fixture(give_me_a_string):
    assert give_me_a_string[0] == 'К'
```

- Тестовая функция принимает аргумент `give_me_a_string` с именем фикстуры.
    
- `pytest` находит фикстуру, запускает её, и результат (строка) попадает в тест.
    

---

### Вызывание одной фикстуры в другой

```python
@pytest.fixture
def give_me_a_string():
    return "Какой чудесный день!"

@pytest.fixture
def pack_to_list(give_me_a_string):
    return [give_me_a_string]

def test_string_fixture(pack_to_list, give_me_a_string):
    assert pack_to_list == [give_me_a_string]
```

- Внутри `pack_to_list` мы можем вызвать `give_me_a_string`.
    
- Цепочки фикстур позволяют поэтапно строить окружение.
    

---

### Маркер `usefixtures` (когда фикстура ничего не возвращает)

Если фикстура не возвращает данных, но требуется для побочных эффектов (например, изменяет внешний ресурс или объект), **можно**:

1. Вызывать её как аргумент теста **(не очень красиво, если не используем)**;
    
2. Или применить `@pytest.mark.usefixtures('fixture_name')`, и тогда фикстура будет выполнена **без** попадания в параметры теста.
    

**Пример**:

```python
@pytest.fixture
def start_engine(engine):
    engine.is_running = True

@pytest.mark.usefixtures('start_engine')
def test_engine_is_running(engine):
    assert engine.is_running
```

---

### Автоматический вызов фикстуры: `autouse=True`

```python
@pytest.fixture(autouse=True)
def start_engine(engine):
    engine.is_running = True
    yield
    engine.is_running = False
```

- Фикстура запускается автоматом для **каждого** теста (по умолчанию scope='function'), без явного вызова.
    
- Полезно для общих действий (логирование, настройка окружения).
    

---

### Область видимости (scope)

- **function** (по умолчанию): создаёт/возвращает объект **на каждый тест**.
    
- **class**: один раз на класс тестов.
    
- **module**: один раз на файл с тестами.
    
- **package**: один раз на весь пакет (реже используется).
    
- **session**: один раз на всю серию тестов (все тесты, что запускаются).
    

**Зачем?**  
Чтобы **сэкономить время/ресурсы** при повторяющихся операциях (создание БД, запуск сервера и т. п.).

```python
@pytest.fixture(scope='session')
def engine():
    return Engine()
```

- С этим параметром вызывается один раз за сессию и **кеширует** результат для всех тестов.
    

---

### Паттерн `yield` в фикстуре (setup/teardown)

Внутри одной фикстуры можно объединить код до и после теста:

```python
@pytest.fixture
def start_engine(engine):
    # setup
    engine.is_running = True
    print("Before test")
    yield
    # teardown
    engine.is_running = False
    print("After test")
```

- Всё, что **до** `yield`, выполняется **до** теста (setup).
    
- Всё, что **после** `yield`, выполняется **после** выполнения теста (teardown).
    

---

### Файл `conftest.py`

- **Не требует импорта** в тестовые файлы: `pytest` **сам** обнаружит фикстуры в `conftest.py`.
    
- Можно хранить общие фикстуры для всего проекта (например, в корне) или для конкретного модуля/приложения (в каталоге тестов).
    
- Возможна логика переопределения фикстур: если в отдельном `conftest.py` есть фикстура с тем же именем, она перекроет глобальную.
    

---

### Best practices

1. **Разделяйте** простые и сложные (цепочечные) фикстуры: пусть каждая отвечает за свой кусок окружения.
    
2. **Используйте** область видимости (`scope`) для экономии ресурсов (например, `scope='session'` для общей БД на все тесты).
    
3. **Не бойтесь** создавать несколько фикстур — это делает код тестов чище, без повторяющейся подготовки.
    
4. **В `conftest.py`** храните фикстуры, нужные множеству файлов; для узких случаев — держите фикстуры рядом с тестами.
    
5. **Teardown** через `yield` — удобнее, чем отдельная фикстура, поскольку setup/teardown логически связаны в одном месте.
    