## 1. Зачем нужны формы на основе моделей

- Задача: **добавлять** или **редактировать** объекты в базе данных через форму.
- При использовании «обычных» классов `Form` требуется вручную дублировать поля из модели, поддерживать их актуальность и самостоятельно обрабатывать сохранение данных в БД.
- **Фреймворк Django** позволяет автоматически создавать форму на базе модели с помощью класса `ModelForm`, что существенно упрощает синхронизацию полей и работу с базой.

---

## 2. Когда лучше использовать `forms.Form`, а когда `forms.ModelForm`

1. **forms.Form**
    
    - Подходит для задач, **не связанных** напрямую с сохранением в БД (например, формы поиска, фильтрации, подписки на рассылку и т.д.).
    - Можно использовать, даже если какие-то поля _могут_ влиять на БД, но это не основная задача.
2. **forms.ModelForm**
    
    - Создает поля формы **на основе** модели (те же типы полей, те же ограничения).
    - Автоматически связывает данные формы с моделью; есть удобные методы для сохранения (с помощью `form.save()` и т.п.).
    - Идеален, когда основное назначение формы — _добавить или отредактировать_ записи в базе.

---

## 3. Подготовка модели для хранения данных

Допустим, мы хотим сохранять данные дня рождения. Создадим модель `Birthday` в `birthday/models.py`:

```python
# birthday/models.py
from django.db import models

class Birthday(models.Model):
    first_name = models.CharField('Имя', max_length=20)
    last_name = models.CharField(
        'Фамилия',
        blank=True,
        help_text='Необязательное поле',
        max_length=20
    )
    birthday = models.DateField('Дата рождения')
```

**Обратите внимание**:

- `max_length` обязателен для `CharField`.
- `blank=True` означает, что поле может быть пустым в форме.
- `help_text` и `verbose_name` (`'Имя'`, `'Фамилия'`) используются для более удобного отображения в админке и формах.

Далее:

```bash
python manage.py makemigrations
python manage.py migrate
```

– чтобы создать и применить миграции (новую таблицу в БД).

---

## 4. Создание `ModelForm`

### 4.1 Структура кода

Вместо обычного класса `Form`, используем `ModelForm`:

```python
# birthday/forms.py
from django import forms
from .models import Birthday

class BirthdayForm(forms.ModelForm):
    class Meta:
        model = Birthday   # Модель, на основе которой строится форма
        fields = '__all__' # Используем все поля модели
        # Настройка виджетов, если нужно
        widgets = {
            'birthday': forms.DateInput(attrs={'type': 'date'})
        }
```

Основные отличия:

1. **Наследуемся от `forms.ModelForm`**, а не от `forms.Form`.
2. Внутри класса `Meta` указываем:
    - `model = Birthday` — модель, из которой берем поля.
    - `fields = '__all__'` — способ определить, какие поля модели включать в форму (в примере — все).
    - Alternatively, можно использовать `fields = ('first_name', 'last_name')` или `exclude = ('some_field', )`.

### 4.2 Зачем внимательно указывать поля

- Если мы поставим `fields = '__all__'`, то **все** поля модели окажутся в форме — это может быть нежелательно, если у модели есть служебные поля или внешние ключи, которые не должны редактироваться пользователем.
- Лучше явно прописывать `fields`, чтобы избежать случайного появления «лишних» полей, особенно если модель расширяется со временем.

---

## 5. Проверка работы

### 5.1 Во view и шаблоне пока без изменений

Допустим, в файле `birthday/views.py` у нас уже есть такая view-функция:

```python
# birthday/views.py
from django.shortcuts import render
from .forms import BirthdayForm
from .utils import calculate_birthday_countdown

def birthday(request):
    form = BirthdayForm(request.GET or None)
    context = {'form': form}
    if form.is_valid():
        birthday_countdown = calculate_birthday_countdown(
            form.cleaned_data['birthday']
        )
        context.update({'birthday_countdown': birthday_countdown})
    return render(request, 'birthday/birthday.html', context)
```

А в `birthday.html` мы выводим эту форму, как раньше:

```html
<!-- templates/birthday/birthday.html -->
{% extends "base.html" %}
{% load django_bootstrap5 %}

{% block content %}
  <form>
    {% bootstrap_form form %}
    {% bootstrap_button button_type="submit" content="Отправить" %}
  </form>
  ...
{% endblock %}
```

### 5.2 Что изменилось?

- Внешне форма будет **выглядеть так же**, как при использовании `Form`, но теперь её поля автоматически соответствуют модельным.
- У поля `last_name` будет ограничение `max_length=20`. Попытка ввести более длинную строку приведёт к ошибке валидации.

### 5.3 Сохранение в БД

**Важно**: пока мы не вызвали `form.save()`, данные _не записываются_ в базу. В данном уроке это ещё не делается, но в будущем вы можете добавить логику сохранения так:

```python
if form.is_valid():
    instance = form.save(commit=False)  # Создает объект, но не сохраняет
    # например, можно заполнить поле user = request.user, если нужно
    instance.save()  # Сохраняет данные в базу
```

Сейчас мы ограничиваемся тем, что проверяем корректность данных и выводим поздравление. Но технически форма уже готова к быстрому сохранению в БД.

---

## 6. Дополнительные советы и бест-практики

1. **Явно указывайте поля в `fields`**
    
    - Чтобы ненароком не вывести важные/скрытые поля.
    - Пример: `fields = ('first_name', 'last_name', 'birthday')`.
2. **`blank=True` и `null=True` в модели**
    
    - `blank=True` означает, что поле в форме может быть пустым.
    - `null=True` означает, что в БД поле может хранить `NULL`. Обычно для `CharField` используют `blank=True`, а `null=True` — реже, только если нужно различать «пустую строку» от `NULL` в БД.
3. **Настройка виджетов**
    
    - Если нужно изменить HTML-атрибуты (`placeholder`, `class`, и т.д.), используйте `widgets` в `Meta`:
        
        ```python
        widgets = {
          'birthday': forms.DateInput(attrs={'type': 'date', 'class': 'form-control'})
        }
        ```
        
    - Это сразу добавит нужные стили или плейсхолдеры в поле.
4. **Автоматическая валидация**
    
    - Django проверяет, чтобы поля соответствовали типам данных модели (например, `DateField` не примет невалидную дату), а строки — установленной длине.
    - Если нужна дополнительная логика, можно переопределить метод `clean()` у `ModelForm` или использовать валидаторы.
5. **Сохранение полей, не отображаемых в форме**
    
    - Если нужно назначить какие-то поля **автоматически** (например, `author = request.user`), можно использовать `form.save(commit=False)`, а затем вручную заполнить поле и сохранить.
6. **Совместимость с админкой**
    
    - Django Admin тоже строит формы для моделей автоматически. Если ваша модель корректно описана и вы добавили её в `admin.py`, админка уже будет иметь похожую форму.
7. **Проектная организация**
    
    - Разделяйте логику: храните формы в `forms.py`, модели в `models.py`. Если форма слишком большая или логика сложная, можно разбить на несколько файлов, но не стоит всё помещать в один.