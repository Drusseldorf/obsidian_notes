## 1. Зачем нужна валидация

1. **Защита от некорректных данных** (ошибок, опечаток, злонамеренных действий).
2. **Гарантия соответствия данных типу и формату**, ожидаемому моделью.
3. **Возможность кастомных проверок** – уникальности записей, своя логика валидации

**Браузерные ограничения (например, `max_length` на поле)** не защищают сервер, потому что пользователь может обойти их, изменив HTML-код или отправив запрос напрямую.

---

## 2. Общая схема валидации в Django

При вызове `form.is_valid()` в Django выполняются проверки в следующем порядке:

1. Проверка, что каждый параметр из запроса можно привести к требуемому типу (число, дата и т. п.).
2. Вызов функций-валидаторов, указанных в поле (аргумент `validators`).
3. Вызов методов вида `clean_<имя_поля>()` для каждого поля. Они могут изменять (очищать, форматировать) или дополнительно валидировать поле.
4. Вызов общего метода `clean()`, где можно проверить взаимосвязь полей и выдать общую ошибку.

---

## 3. Кастомные валидаторы (functions)

### 3.1 Пример

**Задача**: проверять возраст пользователя, ограниченный от 1 года до 120 лет. Создадим файл `birthday/validators.py`:

```python
# birthday/validators.py
from datetime import date
from django.core.exceptions import ValidationError

def real_age(value):
    """Проверяет, что возраст от 1 до 120 лет."""
    age = (date.today() - value).days / 365
    if age < 1 or age > 120:
        raise ValidationError('Ожидается возраст от 1 года до 120 лет')
```

### 3.2 Привязка валидатора к форме или модели

- **Если используем `forms.Form`**:
    
    ```python
    class BirthdayForm(forms.Form):
        birthday = forms.DateField(
            label='Дата рождения',
            validators=(real_age,),
            widget=forms.DateInput(attrs={'type': 'date'}),
        )
    ```
    
- **Если используем `forms.ModelForm`**: тогда логичнее описать валидатор в самом поле модели, чтобы он действовал и в админке, и во всех формах:
    
    ```python
    # birthday/models.py
    from django.db import models
    from .validators import real_age
    
    class Birthday(models.Model):
        ...
        birthday = models.DateField('Дата рождения', validators=(real_age,))
    ```
    

При нарушении ограничений появляется `ValidationError`, в шаблоне автоматически отобразится сообщение об ошибке.

---

## 4. Методы clean_<поле>() (пост-обработка и валидация)

### 4.1 Как это работает

- Django вызывает `clean_<поле>()`, чтобы дать возможность дополнительно проверить/отформатировать значение.
- Метод должен **вернуть** (return) итоговое значение, которое попадёт обратно в `cleaned_data`.

### 4.2 Пример

**Задача**: если в поле `first_name` введено несколько имён через пробел, сохраняем только первое. В `birthday/forms.py`:

```python
class BirthdayForm(forms.ModelForm):
    class Meta:
        model = Birthday
        fields = '__all__'
        widgets = {
            'birthday': forms.DateInput(attrs={'type': 'date'}),
        }

    def clean_first_name(self):
        first_name = self.cleaned_data['first_name']
        # Берём только первое слово
        return first_name.split()[0]
```

В итоге в БД записывается только «первое» имя, а не вся строка.

---

## 5. Метод clean() (проверка зависимостей нескольких полей)

### 5.1 Пример: проверка фамилии/имени на совпадение с The Beatles

Допустим, мы не хотим пускать «Джон Леннон» и т. д. В `birthday/forms.py`:

```python
BEATLES = {'Джон Леннон', 'Пол Маккартни', 'Джордж Харрисон', 'Ринго Старр'}

class BirthdayForm(forms.ModelForm):
    class Meta:
        model = Birthday
        fields = '__all__'

    def clean(self):
        # Сначала вызываем родительский метод clean() – важно для ModelForm,
        # чтобы сработали проверки уникальности полей и т.п.
        super().clean()
        first_name = self.cleaned_data.get('first_name')
        last_name = self.cleaned_data.get('last_name')
        if f'{first_name} {last_name}' in BEATLES:
            raise ValidationError(
                'Мы тоже любим Битлз, но введите, пожалуйста, настоящее имя!'
            )
```

- `clean()` вызывается **после** всех отдельных полей.
- Можно выбросить `ValidationError`, которая будет считаться ошибкой формы в целом.
- При необходимости возвращаем обновлённый словарь: `return self.cleaned_data`.

---

## 6. Уникальные записи (constraints) и super().clean()

### 6.1 Описание constraints в модели

```python
class Birthday(models.Model):
    ...
    class Meta:
        constraints = [
            models.UniqueConstraint(
                fields=('first_name', 'last_name', 'birthday'),
                name='Unique person constraint'
            )
        ]
```

Это ограничение действует на уровне БД и на уровне `ModelForm`, **только если** мы в методе `clean()` вызываем `super().clean()`. Тогда Django проверяет сочетание полей на уникальность.
Требуется применить миграции после этого изменения в моделях.

---

## 7. Лучшие практики и советы

1. **Валидации на уровне модели**
    
    - Универсальные проверки (типа допустимого возраста) лучше размещать прямо в модели (через `validators=(...)`), чтобы они применялись во всех формах и админке.
2. **Локальные проверки в `clean_<field>()`**
    
    - Удобны, если специфическая логика нужна только в одной форме (например, отсечение пробелов, добавление префиксов).
3. **Метод `clean()` для зависимостей**
    
    - Если нужно проверить несколько полей вместе (например, дата отъезда должна быть раньше даты приезда), делаем это в `clean()`.
4. **Вызов `super().clean()`**
    
    - Обязательно для `ModelForm` и при наследовании форм, чтобы родительские проверки сработали (включая проверки на уникальность).
5. **Своевременные миграции**
    
    - Если добавляете UniqueConstraint или изменяете параметры модели (например, `max_length`), не забывайте о `makemigrations` и `migrate`.
6. **Сообщения об ошибках**
    
    - Django сам выводит ошибки в шаблонах, если использовать, например, `{{ form.non_field_errors }}` и `{{ form.field_name.errors }}`.

7. **Не полагайтесь на фронтенд-валидацию**
    
    - Любая проверка, выполняемая только в браузере (JS, атрибуты HTML), легко обходится. Всегда проверяйте и на сервере.

Если вы используете, например, `{{ form.as_p }}` или другой встроенный способ «автоматического» рендеринга формы, то ошибки действительно будут отображаться «из коробки». Но важно понимать, что:

1. **При «автоматическом» рендеринге** (через `{{ form.as_p }}`, `{{ form.as_table }}` и т. п.) Django:
    
    - Показывает ошибки каждого поля прямо под этим полем.
    - Выводит ошибки формы (non-field errors) в начале формы, отдельно от полей.
2. **При «ручном» рендеринге** (когда вы сами пишете `<label>...</label>` и вручную размещаете `{{ form.field_name }}` и `{{ form.field_name.errors }}` в шаблоне), Django уже не знает, куда именно выводить ошибки. В этом случае:
    
    - Нужно самостоятельно позаботиться о том, где именно вы хотите видеть ошибки для каждого поля (или общие ошибки формы).

Таким образом, «не обязательно» явно писать `{{ form.non_field_errors }}` и `{{ form.field_name.errors }}`, **если** вы пользуетесь встроенными методами вывода формы (например, `{{ form.as_p }}`). Но если вы делаете кастомную верстку формы и хотите чётко контролировать места, где выводятся ошибки, лучше явно прописать соответствующие теги.