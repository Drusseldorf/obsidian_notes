### 1. Ссылки в шаблонах и проблема «жёстких» адресов

- В обычном HTML для перехода на страницу указывают статический адрес:
    
    ```
    <a href="catalog/">Список товаров</a>
    ```
    
- **Недостаток**: если в проекте меняется структура URL, придётся **править ссылки во всех шаблонах** вручную.
    

---

### 2. Именованные URL (name)

- Django позволяет присвоить каждому маршруту в `urls.py` **имя** (параметр `name` в `path()`).
    
- Пример в `catalog/urls.py`:
  ```python
    urlpatterns = [
        path('catalog/', views.product_list, name='product_list'),
        path('catalog/<int:pk>/', views.product_detail,      name='product_detail'),
	    ]
    ```
    
- В шаблоне вместо «жёсткого» адреса используют тег `url` с именем:
    
    ```
    <a href="{% url 'product_list' %}">Страница со списком товаров</a>
    <a href="{% url 'product_detail' 1 %}">Товар №1</a>
    ```
    
- При рендеринге Django **автоматически подставит** реальный путь `/catalog/` или `/catalog/1/`.
    

**Преимущество**:

- Чтобы изменить адрес, правим только `urls.py`. Шаблоны не трогаем — ссылки подтягиваются по имени.
    

---

### 3. Изменение структуры URL без правки шаблонов

- Если URL меняется в `urls.py` (например, на `new_link/`), то в шаблоне по-прежнему используем то же имя:
    
    ```python
    # catalog/urls.py
    urlpatterns = [
        path('new_link/', views.product_list, name='product_list'),
        path('new_link/<int:pk>/', views.product_detail, name='product_detail'),
    ]
    ```
    
- В шаблоне:
    
    ```
    <a href="{% url 'product_list' %}">Список товаров</a>
    <a href="{% url 'product_detail' 1 %}">Товар №1</a>
    ```
    
- **Результат**: ссылки автоматически станут `new_link/` и `new_link/1/`.
    

---

### 4. Пространства имён (namespace)

- Проблема: если в **разных приложениях** (например, `catalog` и `cart`) используем одинаковые `name='product_list'`, возникает конфликт.
    
- Решение: указывать **namespace** (пространство имён) для каждого приложения.
    
- В файле `urls.py` приложения объявляют переменную `app_name`. Обычно она совпадает с названием приложения:
    
    ```python
    # catalog/urls.py
    app_name = 'catalog'
    
    urlpatterns = [
        path('', views.product_list, name='product_list'),
    ]
    ```
    
- Тогда при генерации ссылки в шаблоне указывают:
    
    ```
    <a href="{% url 'catalog:product_list' %}">Список товаров</a>
    ```
    
    - `catalog` — это namespace;
        
    - `product_list` — имя, заданное в `name='product_list'`.
        
- Таким образом, если в приложении `cart` тоже будет `name='product_list'`, мы используем `cart:product_list` в ссылках для корзины.
    
- **Преимущество**: никаких конфликтов и полная ясность, из какого приложения берётся путь.
    

---

### 5. Итог

1. **name** в `path()` даёт возможность ссылаться на маршрут по имени, без «жёсткой» привязки к URL.
    
2. **{% url 'some_name' ... %}** — Django-тег, подставляющий реальный адрес из `urls.py`.
    
3. **namespace** (`app_name = 'your_app'`) решает конфликты имён разных приложений: в шаблонах пишем `'your_app:имя_ссылки'`.
    
4. При изменении URL в `urls.py` менять шаблоны не нужно — достаточно поменять путь в `path()`.
    

**Результат**: система именованных ссылок + namespace помогает централизованно управлять путями, избегать конфликтов имён и упрощает рефакторинг URL в любом Django-проекте.