### 1. Зачем нужен словарь контекста?

- В Django каждый шаблон может выводить данные, которые отличаются от страницы к странице (например, разные товары в магазине или разные новости на портале).
- Вместо создания отдельных шаблонов на каждый объект (что неэффективно), используют **один шаблон**, а уникальные данные передают в него с помощью **словаря контекста** (`context`).
- Django «умеет» подставлять данные из этого словаря в нужные места шаблона.

---

### 2. Передача данных из view-функции в шаблон

- Для передачи контекста используется функция `render(request, template_name, context)`.
- Параметры:
    1. `request` — объект HTTP-запроса.
    2. `template_name` — путь к файлу-шаблону (например, `"homepage/index.html"`).
    3. `context` (необязательный) — словарь с данными, которые должны быть вставлены в шаблон.

Пример:

```python
# homepage/views.py 

from django.shortcuts import render 

def index(request): 
	template_name = 'homepage/index.html' 
	title = 'Главная страница ACME' 
	promo_product = 'Iron carrot' 
	context = { 
		'title': title, 
		'promo_product': promo_product, 
	} 
	return render(request, template_name, context)
```

Здесь в `context` передаются ключи `'title'` и `'promo_product'`, которые будут доступны в шаблоне.

---

### 3. Как вывести данные в шаблоне

- В HTML-шаблоне значения контекста выводятся конструкцией `{{ ключ }}`.
- По соглашению Django вокруг ключа ставятся пробелы: `{{ title }}`.
- Пример вывода данных из примера выше:

```html
<!-- templates/homepage/index.html --> 
<h1>{{ title }}</h1> 
<p>Товар дня: {{ promo_product }}</p>
```
---

### 4. «Точечная» нотация (dot-notation)

Django автоматически определяет, как обрабатывать выражение после точки:

- Если это **словарь** — берёт значение по ключу.
- Если это **объект класса** — берёт атрибут или метод.
- Если это **список** — обращается к элементу по индексу.

Примеры:

```html
{{ my_dict.some_key }} 
{{ my_object.attribute }} 
{{ my_list.0 }}
```
Если `my_list = ['Hello', 'World']`, в шаблоне `{{ my_list.0 }}` выведет `Hello`.

---

### 5. Ветвление в шаблоне (`if`, `elif`, `else`)

- Синтаксис похож на Python, но всё пишется внутри специальных тегов шаблонизатора `{% ... %}`.
- Обязателен закрывающий тег `{% endif %}`.

Пример:

```html
{% if promo_product == "Iron carrot" %}   
  Железная морковка — хорошо для стальных зубов. 
{% elif promo_product == "Giant mousetrap" %}   
  Ребята, давайте жить дружно! 
{% else %}   
  Вы все меня ещё не знаете, но вы меня узнаете! 
{% endif %}
```

Django подставит подходящий блок текста, основываясь на значении `promo_product`, переданном через `context`.

---

### 6. Циклы (`for ... in ...`) в шаблоне

- Список или любой другой итерируемый объект можно перебрать циклом.
- Структура:
    `{% for item in items %}   ... {% endfor %}`
- Важно: тег `{% endfor %}` обязателен.

Пример с передачей списка во view:

```python
# catalog/views.py 

def product_list(request):     
	template_name = 'catalog/product_list.html'     
	title = 'Список товаров ACME'     
	products = [
		'Iron carrot', 
		'Giant mousetrap', 
		'Dehydrated boulders', 
		'Invisible paint'
	]     
	context = {
		'title': title,         
		'products': products     
	}     
	return render(request, template_name, context)
```

Шаблон:

```html
<!-- templates/catalog/product_list.html --> 
<h1>{{ title }}</h1> 
{% for product in products %}   
	<p>{{ product }}</p> 
{% endfor %}
```
---

### 7. Специальная переменная `forloop` в циклах

Внутри цикла Django автоматически создаёт объект `forloop`, содержащий полезные атрибуты:

- `forloop.counter` — номер итерации, начиная с 1.
- `forloop.counter0` — номер итерации, начиная с 0 (по-программистски).
- `forloop.revcounter` — сколько итераций осталось до конца, начиная с 1.
- `forloop.revcounter0` — сколько итераций осталось до конца, начиная с 0.
- `forloop.first` — `True`, если текущая итерация первая.
- `forloop.last` — `True`, если текущая итерация последняя.

Использование, например, чтобы после **последнего** элемента списка вывести горизонтальную линию:

```html
{% for product in products %}   
	<p>{{ product }}</p>   
	{% if forloop.last %}     
		<hr>   
	{% endif %} 
{% endfor %}
```

---

### 8. Тег `{% empty %}`

- Если коллекция (список, queryset и т.п.) пустая, всё, что размещено между `{% empty %}` и `{% endfor %}`, будет выведено вместо элементов цикла.
- Пример:

```html
{% for product in products %}   
	<p>{{ product }}</p> 
{% empty %}   
	<p>Товаров пока не подвезли</p> 
{% endfor %}
```

Если `products` пуст, вместо списка товара пользователи увидят текст: «Товаров пока не подвезли».

---

### 9. Что ещё важно учесть

- Django позволяет использовать в шаблонах и другие логические операции (`and`, `or`, `not`), сравнения (`==`, `!=`, `>`, `<` и т.д.).
- В шаблонах удобно выводить любой тип данных: строки, числа, списки, объекты классов. Django обработает обращение к ним через точку единообразно.
- Код в шаблонах по возможности держат «лёгким» (не делают сложную логику). Тяжёлые вычисления — во `view`.

---

**Итог:**

- Словарь контекста передаёт уникальные данные в шаблон.
- В шаблоне данные выводят через фигурные скобки `{{ ... }}` и управляют логикой с помощью тегов `{% if ... %}`, `{% for ... %}`, и т.д.
- Такой подход позволяет переиспользовать один и тот же шаблон, наполняя его разными данными для разных страниц.