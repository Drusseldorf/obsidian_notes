## 1. Задача: дать пользователям возможность добавлять «теги» к записям

1. Каждая запись в модели `Birthday` может иметь несколько тегов (например, «Друг», «Коллега», «Родственник»).
2. Один и тот же тег (например, «Друг») может относиться к разным записям.
3. Требуется вывести список тегов рядом с каждой запись, а в конце – автор записи.
4. Нужно не только всё вывести, но и сделать это эффективно, не порождая кучу запросов к БД.

---

## 2. Создание модели Tag и связь many-to-many

### 2.1 Модель `Tag`

В `birthday/models.py`:

```python
class Tag(models.Model):
    tag = models.CharField('Тег', max_length=20)

    def __str__(self):
        # Возвращаем человекочитаемый текст вместо 
        # <Tag object (id)>
        return self.tag
```

### 2.2 Связь `ManyToManyField` в `Birthday`

Добавляем поле в модель `Birthday`:

```python
class Birthday(models.Model):
    ...
    # Много тегов у одной записи
    tags = models.ManyToManyField(
        Tag,
        verbose_name='Теги',
        blank=True,
        help_text='Удерживайте Ctrl для выбора нескольких вариантов'
    )
    ...
```

- `blank=True` – поле не обязательно.
- В админке теперь появится виджет множественного выбора тегов.

После изменений – **`python manage.py makemigrations && python manage.py migrate`**.

---

## 3. Отображение тегов в шаблоне

### 3.1 Самый простой способ

В списке `birthday/list/` – при рендере каждого объекта `Birthday`, можно вывести все связанные теги:

```html
{% for birthday in page_obj %}
  ...
  {% for tag in birthday.tags.all %}
    {{ tag.tag }}
  {% endfor %}
  ...
{% endfor %}
```

Но без оптимизации, для каждого объекта `Birthday`, Django будет делать **отдельный запрос** к промежуточной таблице many-to-many. При 10 записях – 10 дополнительных запросов.

### 3.2 Дополнительно: автор записи

Там же мы показываем `birthday.author.username`. Если не оптимизировать, появится ещё по запросу на загрузку автора. Итого получается 2 запроса на объект (по одному для тега и автора). При 10 записях – **20 лишних запросов**.

---

## 4. Проблема: слишком много SQL-запросов

С помощью **Django Debug Toolbar** (или в логах) можно увидеть, что для вывода 10 объектов возникает более 20 запросов. Это не очень масштабируемо и может тормозить.

---

## 5. Решение: методы `select_related` и `prefetch_related`

### 5.1 Когда используется `select_related()`

- При связи **«один ко многим»** или «один к одному».
- Автор записи (`birthday.author`) – это ForeignKey (один-ко-многим).
- `select_related('author')` сделает **JOIN** с таблицей пользователя и загрузит всё одним запросом.

### 5.2 Когда используется `prefetch_related()`

- При связи **«многие ко многим»** или «один ко многим», когда нужен более сложный механизм (например, для M2M).
- `prefetch_related('tags')` сделает **дополнительный запрос** к таблице тегов (и промежуточной таблице), но при этом загрузит все теги **сразу** для всех выбранных объектов `Birthday`, без повторных запросов.

---

## 6. Как применить в CBV: переопределяем `queryset`

В `birthday/views.py` (например, для `BirthdayListView`):

```python
class BirthdayListView(ListView):
    model = Birthday
    # По умолчанию было objects.all(), но мы переопределим:
    queryset = Birthday.objects.prefetch_related('tags').select_related('author')
    ordering = 'id'
    paginate_by = 10
```

- Суть:
    - `select_related('author')` – подгружает автора (ForeignKey) через JOIN.
    - `prefetch_related('tags')` – подгружает связанные теги (ManyToMany) другим запросом, но единым для всех объектов.
- В итоге для 10 записей вместо 20+ запросов будет **2** дополнительных запроса:
    1. Основной запрос `SELECT * FROM birthday_birthday LEFT JOIN auth_user...`
    2. `SELECT * FROM birthday_tag INNER JOIN birthday_birthday_tags ...`

### 6.1 Результат

Теперь, когда мы в шаблоне обратимся к `birthday.author` или `birthday.tags.all()`, Django **не** будет делать дополнительных SQL-запросов – данные уже предзагружены.

---

## 7. Более элегантный вывод тегов с помощью `join`

### 7.1 Фильтр `join` в шаблоне

```html
{% for birthday in page_obj %}
  ...
  <!-- Сразу объединим теги в строку через запятую -->
  {% with all_tags=birthday.tags.all %}
    {% if all_tags %}
      {{ all_tags|join:", "|lower|capfirst }} пользователя {{ birthday.author.username }}
    {% endif %}
  {% endwith %}
{% endfor %}
```

- `join:", "` склеивает список тегов в строку.
- `|lower` делает строчные буквы, `|capfirst` делает первую букву заглавной.
- Если теги отсутствуют (`all_tags` пуст), ничего не выводим.

---

## 8. Бест-практики и заключительные советы

1. **Используйте `select_related` и `prefetch_related`**
    - `select_related('author')` для ForeignKey.
    - `prefetch_related('tags')` для ManyToMany.
    - Следите, чтобы не применять `select_related` там, где много объектов (join больших таблиц тоже дорогой). Но для типовых случаев упрощает жизнь.
2. **Избегайте n+1-запросов**
    - Это когда при выводе n элементов делается ещё n запросов к связанной модели. `prefetch_related` или `select_related` убирает эту проблему.
3. **Профилируйте SQL**
    - Django Debug Toolbar – один из лучших способов проверить, сколько запросов отправляется на каждую страницу.
4. **Не переусердствуйте**
    - `prefetch_related` будет грузить все связанные объекты. Если у вас много тегов, иногда может быть дороже грузить их все. Но обычно, если они реально нужны в шаблоне, это оправдано.
5. **Совместная работа**
    - Можно делать цепочку: `.select_related('author').prefetch_related('tags')`.
    - Можно даже prefetch через отношения глубже – например `'tags__something_else'`.
6. **Удобство**
    - Иногда имеют смысл методы типа `birthday.get_tags_display()` – но это по вкусу.
    - Если хотите перевести теги на другую модель / сделать отдельный ManyToMany – это легко расширяется.
7. **Разделяйте DTO (Data Transfer Objects)**
    - Если страница сложная, иногда полезно писать отдельные менеджеры или сервисы, формирующие QuerySet с нужными `select_related` / `prefetch_related`, чтобы ListView не был перегружен логикой.
8. **Ограничения**
    - `select_related` не подходит для ManyToMany – только `prefetch_related`.
    - `prefetch_related` делает дополнительный запрос, а `select_related` – join. Выбирайте, что подходит к типу связи.