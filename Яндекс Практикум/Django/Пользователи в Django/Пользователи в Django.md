## 1. Аутентификация и авторизация

1. **Аутентификация** (authentication) – проверка, что пользователь действительно тот, за кого себя выдаёт (например, сверяем логин-пароль с БД).
2. **Авторизация** (authorization) – проверка прав доступа (какие страницы, действия или объекты доступны).

В Django эти процессы тесно связаны – модуль `django.contrib.auth` предоставляет готовую систему для хранения и проверки пользователей, а также управления их правами.

---

## 2. Модуль `django.contrib.auth`

- По умолчанию входит в `INSTALLED_APPS`.
- Предоставляет **модель User**, встроенные views и URL-шаблоны для входа/выхода, восстановления паролей и т.п.
- Примеры возможностей:
    - **Логин** / **логаут** (формы для ввода пароля).
    - **Смена** / **сброс** пароля.
    - **Проверка прав** (permissions) на уровне админки и собственного кода.
    - **Группы** (groups) – можно объединять пользователей и назначать права целой группе.

### 2.1 Поля встроенной модели User

Стандартная модель `User` имеет такие поля, как:

- `username`, `password`, `email`, `first_name`, `last_name`
- Флаги: `is_staff`, `is_active`, `is_superuser`
- Технические поля: `last_login`, `date_joined`
- **Группы** (`groups`), **права** (`user_permissions`)

Все эти поля видны в админке и доступны при работе с объектами модели `User`.

---

## 3. Права пользователей (permissions) и группы

1. **Права** определяют, какие действия разрешены пользователю: просматривать, создавать, редактировать и удалять объекты конкретной модели.
2. **Группы** позволяют назначать набор прав сразу нескольким пользователям.
3. **Суперпользователь** (`is_superuser=True`) имеет все права, даже если явно они не указаны.

### 3.1 Проблема «админка vs. пользовательский интерфейс»

- В **админке** (admin) встроено автоматическое чтение прав: чтобы иметь доступ к модели Birthday в админке, надо явно выдать право.
- В **пользовательских** страницах мы сами отвечаем за проверку прав. Если не настроить, даже аноним может редактировать/удалять данные.

Решение: в своих view-функциях / CBV надо использовать **декораторы** или **миксины** для проверки прав и статуса пользователя.

---

## 4. Расширение или замена модели пользователя

### 4.1 Зачем менять модель пользователя

- Может понадобиться дополнительная информация в модели (например, `bio`, `date_of_birth`, `avatar` и т.д.).
- Встроенная модель `User` не меняется напрямую, так как она часть Django. Есть два подхода:

#### 4.1.1 Расширение (через One-to-One)

- Создаётся модель «профиля» (Profile), связанная с пользователем `OneToOneField(User)`.
- **Плюсы**: можно сделать в любой момент, даже если база уже существует.
- **Минусы**: придётся «склеивать» данные в запросах (JOIN), дополнительно настраивать админку и автоматическое создание профиля.

#### 4.1.2 Замена стандартного `User` на кастомный

- Пишется своя модель, унаследованная от `AbstractUser` или `AbstractBaseUser`.
- В `settings.py` указываем `AUTH_USER_MODEL = 'myapp.MyUser'`.
- **Плюсы**: можно полностью контролировать модель, хранить все поля в одной таблице.
- **Минусы**: менять модель пользователя желательно **до** запуска миграций. Если же менять после, придётся переносить данные или удалять/пересоздавать БД.

---

## 5. Примеры кастомной модели пользователя

### 5.1 Наследование от `AbstractUser`

```python
# users/models.py
from django.contrib.auth.models import AbstractUser
from django.db import models

class MyUser(AbstractUser):
    bio = models.TextField('Биография', blank=True)
```

**Настройка в `settings.py`:**

```python
AUTH_USER_MODEL = 'users.MyUser'
```

После этого:

1. Выполнить `makemigrations` и `migrate`.
2. Зарегистрировать модель в админке:

```python
# users/admin.py
from django.contrib import admin
from django.contrib.auth.admin import UserAdmin
from .models import MyUser

# Добавляем кастомное поле в fieldsets
UserAdmin.fieldsets += (
    ('Extra Fields', {'fields': ('bio',)}),
)

admin.site.register(MyUser, UserAdmin)
```

Теперь в админке будет поле «Биография».

### 5.2 Наследование от `AbstractBaseUser`

- Более «низкоуровневый» вариант, когда нужно самому определить почти всё (логин, поля, механизм аутентификации).
- Сложнее в настройке, рекомендуемая документация: [AbstractBaseUser docs](https://docs.djangoproject.com/en/4.2/topics/auth/customizing/#auth-custom-user).

---

## 6. Работа с моделью пользователя в коде: `get_user_model()`

Чтобы код оставался гибким, вместо:

```python
from django.contrib.auth.models import User
```

лучше использовать:

```python
from django.contrib.auth import get_user_model

User = get_user_model()
```

Так вы не привязываетесь к конкретной модели `User` – если модель будет заменена на `MyUser`, код продолжит работать без изменений.

---

## 7. Основные советы и бест-практики

1. **Учитывайте отличие аутентификации и авторизации**. Если нужно проверять, залогинен пользователь или нет, используйте декоратор `@login_required` или CBV-миксины `LoginRequiredMixin`. Если нужно проверить, может ли пользователь менять объект, — проверяйте права или сравнивайте автора объекта с `request.user`.
2. **Распределение прав**:
    - Если есть несколько ролей пользователей (например, «Редактор», «Автор», «Читатель»), используйте **группы**. Проще добавить новые права к группе, чем раздавать их каждому пользователю вручную.
3. **Суперпользователь** (`is_superuser=True`) всегда имеет все права, но нельзя забывать про `is_staff`, чтобы дать ему доступ в админку.
4. **Замена модели пользователя**:
    - Делайте это **до** первого `migrate`, чтобы избежать конфликтов в БД.
    - Если нужно расширить уже существующий проект, смотрите в сторону **расширения модели** (через One-to-One) или решайтесь на перенос данных.
5. **Используйте `get_user_model()`** везде, где работаете с моделью пользователя, чтобы не завязываться жёстко на встроенный `User`.