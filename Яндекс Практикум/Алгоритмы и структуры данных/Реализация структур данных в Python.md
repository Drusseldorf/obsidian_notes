# Реализация структур данных в Python

---

### **Список как динамический массив**

- **Структура:** элементы списка `list` занимают соседние ячейки в памяти.
- **Время доступа по индексу:** O(1) — константное время.
- **Добавление элементов:**
    - Если зарезервированное место есть, операция занимает O(1). Интерпретатор всегда резервирует некоторое количество памяти для списка, чтобы при добавлении в него новых элементов не производить реаллокацию списка в памяти. Это называется амортизация. Однако это баланс между зарезервированным местом и вероятностью реаллокации. Реаллокация не исключается.
    - При нехватке места выполняется **релокация** — перенос списка в новый участок памяти, временная сложность O(n).
- **Советы:**
    - Для ускорения работы можно создавать списки с заранее заданной длиной. (заполняем элементы как None например)
- **Добавление и удаление в середине списка:** O(n), т.к. требует сдвига элементов.

---

### **Массивы (array)**

- **Характеристики:**
    - Элементы должны быть одного типа (указывается при создании).
    - Массивы используют меньше памяти, чем списки.
- **Пример создания:**
    
    ```python
    from array import array
    arr = array('i', [1, 2, 3])  # 'i' — целые числа. реализованы на C так что тут указыается тип данных как он есть в C
    ```
    
- **Преимущества:**
    - Экономия памяти.
    - Более эффективная работа с элементами фиксированного типа.

---

### **Связные списки (в пайтон нет такого типа данных)**

- **Описание:**
    - Узлы (nodes) содержат значение и ссылку на следующий элемент.
    - Последний узел ссылается в никуда.
- **Добавление элементов:**
    - В начало или конец — O(1).
    - В произвольное место — O(n), требуется перебор до нужной позиции.
- **Удаление элементов:**
    - Удаление произвольного узла требует перенаправления ссылок.
- **Ограничения:**
    - Доступ к элементу по индексу — O(n), так как требуется перебор.
    - Невозможно перебрать список в обратном порядке.

---

### **Двусвязные списки**

- **Описание:**
    - Узлы содержат ссылки на следующий и предыдущий элементы.
- **Преимущества:**
    - Удобно добавлять или удалять элементы с обеих сторон за O(1).
- **Недостатки:**
    - Требует больше памяти (хранение двух ссылок).

---

### **Реализация связного списка в Python**

- **Класс узла (Node):**
    
    ```python
    class Node:
        def __init__(self, value, next_item=None):
            self.value = value
            self.next_item = next_item
    ```
    
- **Создание связного списка:**
    
    ```python
    node_last = Node(value='Последний элемент')
    node_middle = Node(value='Средний элемент', next_item=node_last)
    node_head = Node(value='Голова', next_item=node_middle)
    ```
    
- **Перебор списка:**
    
    ```python
    temp_node = node_head
    while temp_node is not None:
        print(temp_node.value)
        temp_node = temp_node.next_item
    ```
    

---

### **Сравнение структур**

Список:

![image.png](%D0%A0%D0%B5%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D1%83%D1%80%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20Python%2015b1dd2d7a1e800c8cf7fe4e8b8a2c1c/29d0bc09-c6c0-49d6-908a-0483d123d3a6.png)

Связанный список:

| Время в среднем | Время в худшем случае |
| --- | --- |
| Обращение по индексу | O(n) |
| Добавление элемента на следующую позицию за текущим элементом | O(1) |
| Добавление элемента на позицию перед текущим элементом | O(n) |
| Удаление первого элемента | O(1) |
| Удаление текущего элемента | O(n) |
| Поиск по значению | O(n) |
| Определение длины списка | O(n) |

---

### **Заключение**

- **Список (list):** универсальный, удобный, но не всегда оптимальный по памяти.
- **Массивы (array):** эффективны для хранения данных одного типа.
- **Связные списки:** удобны для частого добавления и удаления элементов, но менее эффективны для доступа по индексу.
- **Двусвязные списки:** повышают удобство, но требуют больше памяти.