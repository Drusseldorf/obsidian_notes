# Глава 16. Перегрузка операторов

### **Введение**

**Основная идея главы:**

- Перегрузка операторов позволяет пользовательским типам взаимодействовать с операторами (например, `+`, *``) так же, как встроенные типы Python.

**Почему это важно?**

- Улучшает читаемость и удобство кода.
- Необходима в таких областях, как численные вычисления (NumPy), финансовые приложения и научные исследования.

---

### **1. Основы перегрузки операторов**

**Перегрузка операторов:**

- Дает возможность переопределять поведение стандартных операторов для пользовательских типов.

**Ограничения в Python:**

1. Нельзя изменять поведение операторов для встроенных типов.
2. Нельзя добавлять новые операторы (только перегружать существующие).
3. Некоторые операторы нельзя перегружать: `is`, `and`, `or`, `not`.

---

### **2. Унарные операторы**

**Поддерживаемые унарные операторы:**

1. `` -(`__neg__`): Унарный минус.
2. `+` (`__pos__`): Унарный плюс.
3. `~` (`__invert__`): Побитовое отрицание.

**Пример реализации для `Vector`:**

```python
def __neg__(self):
    return Vector(-x for x in self)

def __pos__(self):
    return Vector(self)
```

**Тонкости:**

1. Унарные операторы не изменяют объект (`self`), а создают новый.
2. Если оператор не поддерживается (например, `~` для `Vector`), Python вызывает `TypeError`.

**Интересный случай:**

- Для `decimal.Decimal`, `x != +x` возможно из-за изменения точности в контексте вычислений. Это когда мы поменяли точность, а потом сравниваем значения.

```python
>>> import decimal
>>> ctx = decimal.getcontext()
>>> ctx.prec = 40
>>> one_third = decimal.Decimal('1') / decimal.Decimal('3')
>>> one_third
Decimal('0.3333333333333333333333333333333333333333')
>>> one_third == +one_third
True
>>> ctx.prec = 28
>>> one_third == +one_third
False
>>> +one_third
Decimal('0.3333333333333333333333333333')
```

---

### **3. Перегрузка инфиксных операторов**

**Инфиксные операторы:**

- Пример: `+`, -``,* ``, `/`, `@`.

**Алгоритм вызова операторов:**

1. Python вызывает метод `__add__`, если он есть.
2. Если `__add__` возвращает `NotImplemented`, Python вызывает `__radd__`.
3. Если оба метода возвращают `NotImplemented`, возникает `TypeError`.

**Пример перегрузки `+` для сложения векторов:**

```python
def __add__(self, other):
    try:
        pairs = itertools.zip_longest(self, other, fillvalue=0.0)
        return Vector(a + b for a, b in pairs)
    except TypeError:
        return NotImplemented

def __radd__(self, other):
    return self + other
```

**Советы автора:**

- Всегда возвращайте `NotImplemented`, если оператор не может обработать операнд. Это синглтон для пайтона, чтобы пайтон пробовал выполнять инверсные операторы. Его нельзя райзить, для этого имеется NotImplemetedError и он используется в абстрактных классах.
- Это позволяет другим классам попытаться выполнить операцию.

---

### **4. Перегрузка оператора `` * для умножения на скаляр**

**Пример реализации:**

```python
def __mul__(self, scalar):
    try:
        factor = float(scalar)
    except TypeError:
        return NotImplemented
    return Vector(n * factor for n in self)

def __rmul__(self, scalar):
    return self * scalar
```

**Тонкости:**

- Умножение поддерживает любые типы, которые можно преобразовать в `float` (например, `int`, `bool`, `Fraction`).

**Duck typing vs Goose typing:**

- В случае `__mul__` использован duck typing (пробуем выполнить операцию, ловим `TypeError`).
- Goose typing (явная проверка типов) более предсказуем и иногда предпочтительнее.

---

### **5. Оператор `@` (матричное умножение)**

**Поддержка с Python 3.5:**

- Введён для удобной работы с матрицами (например, в NumPy).

**Пример реализации:**

```python
def __matmul__(self, other):
    if isinstance(other, abc.Sized) and isinstance(other, abc.Iterable):
        if len(self) == len(other):
            return sum(a * b for a, b in zip(self, other))
        else:
            raise ValueError('@ requires vectors of equal length.')
    else:
        return NotImplemented
```

**Особенности:**

- Goose typing: проверяется, поддерживает ли операнд методы `__len__` и `__iter__`.
- В Python 3.10 добавлен аргумент `strict` в `zip`, который можно использовать для строгой проверки длины.

---

### **6. Операторы сравнения (Rich Comparison Operators)**

**Список операторов:**

- `==`, `!=`, `<`, `>`, `<=`, `>=`.

**Правила обработки:**

- Если метод возвращает `NotImplemented`, Python вызывает "обратный" метод (например, для `==` это `__eq__`, а затем `__eq__` другого операнда).
- Для `==` и `!=` Python сравнивает `id(a)` и `id(b)` как последнее средство.

**Пример реализации `__eq__`:**

```python
def __eq__(self, other):
    if isinstance(other, Vector):
        return len(self) == len(other) and all(a == b for a, b in zip(self, other))
    return NotImplemented
```

**Тонкости:**

- Для оператора `!=` достаточно определить `__eq__`, так как Python автоматически вызывает его и возвращает противоположный результат.

---

### **7. Операторы присваивания с модификацией (Augmented Assignment Operators)**

**Пример: `+=`, `*=`.**

- Если метод `__iadd__` не определён, выражение `a += b` обрабатывается как `a = a + b`.

**Пример реализации `__iadd__`:**

```python
def __iadd__(self, other):
    if isinstance(other, Tombola):
        other_iterable = other.inspect()
    else:
        try:
            other_iterable = iter(other)
        except TypeError:
            raise TypeError("right operand in += must be 'Tombola' or an iterable")
    self.load(other_iterable)
    return self
```

**Тонкости:**

- Методы `__iadd__`, `__imul__` и т.п. всегда должны возвращать `self`.
- `+=` более "либерален", чем `+`, и принимает любые итерируемые операнды.

---

### **Заключение**

**Ключевые моменты:**

1. Python ограничивает перегрузку операторов для повышения читаемости и предсказуемости кода.
2. Перегрузка операторов может быть мощным инструментом, но требует осторожного использования, чтобы не запутывать пользователей.

**Пример удачной перегрузки:**

- В `pathlib.Path` оператор `/` используется для создания путей:

```python
p = Path('/etc')
q = p / 'init.d' / 'reboot'
```