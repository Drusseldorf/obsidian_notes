# Глава 7. Функции как полноправные объекты

- **Функции как объекты первого класса**:
    - Функции в Python являются объектами первого класса, что значит:
        - Они могут создаваться во время выполнения.
        - Их можно присваивать переменным.
        - Можно передавать как аргументы другим функциям.
        - Можно возвращать как результат функций.
- **Работа с функциями как с объектами**:
    - Функции можно присваивать переменным и вызывать через них.
    - Их можно передавать в качестве аргументов, например, в такие функции как `map()` и `sorted()`.
- **Функции высшего порядка**:
    - Это функции, которые принимают другие функции в качестве аргументов или возвращают функции как результат.
    - Примеры: `sorted()` с параметром `key`, `map()`, `filter()`, `reduce()`.
- **Современные альтернативы map, filter и reduce**:
    - Списковые включения и генераторные выражения более удобочитаемы и заменяют `map` и `filter`. Они (генераторные выражения) являются более pythonic стилем и их использовать лучше
    - Функция `sum` заменяет `reduce` для суммирования значений.
- **Анонимные функции (lambda)**:
    - Короткие функции, которые могут быть полезны в качестве аргументов для функций высшего порядка.
    - Имеют ограничения по синтаксису — тело функции должно быть выражением.
- **Различные типы вызываемых объектов**:
    - В Python множество вызываемых объектов: обычные функции, методы, экземпляры классов с методом `__call__`, генераторы и корутины.
- **Параметры, доступные только по ключу и только по позиции**:

### Примеры параметров, доступных только по позиции или только по ключу

1. **Только позиционные параметры** (добавлено в Python 3.8):
    - Чтобы сделать параметр доступным только по позиции, укажите `/` после списка таких параметров в определении функции.
    
    ```python
    def my_func(a, b, /, c, d):
        print(a, b, c, d)
    
    # Вызываем функцию с позиционными аргументами
    my_func(1, 2, c=3, d=4)  # Работает
    my_func(1, 2, 3, 4)      # Работает
    
    # Неправильный вызов: a и b могут быть переданы только по позиции
    my_func(a=1, b=2, c=3, d=4)  # Ошибка
    ```
    
    В этом примере `a` и `b` являются позиционными параметрами и их нельзя передавать по имени, тогда как `c` и `d` можно передавать как по позиции, так и по ключу.
    
2. **Только именованные параметры**:
    - Чтобы сделать параметры доступными только по ключу, укажите `` перед ними.
    
    ```python
    def my_func(a, b, *, c, d):
        print(a, b, c, d)
    
    # Вызываем функцию с ключевыми аргументами
    my_func(1, 2, c=3, d=4)  # Работает
    
    # Неправильный вызов: c и d могут быть переданы только по ключу
    my_func(1, 2, 3, 4)      # Ошибка
    ```
    
    В этом примере `c` и `d` являются только именованными параметрами, и их обязательно нужно передавать по ключу.
    
3. **Комбинированный пример**:
    - Можно использовать оба ограничения, чтобы смешать только позиционные, свободные, и только именованные параметры:
    
    ```python
    def my_func(a, b, /, c, *, d, e):
        print(a, b, c, d, e)
    
    # Только позиционные параметры (a, b) и только именованные параметры (d, e)
    my_func(1, 2, 3, d=4, e=5)  # Работает
    
    # Неправильный вызов
    my_func(a=1, b=2, c=3, d=4, e=5)  # Ошибка
    ```
    
    В этом примере:
    
    - `a` и `b` должны быть переданы только по позиции.
    - `c` может быть передан как по позиции, так и по имени.
    - `d` и `e` должны быть переданы только по имени (ключу).

- Параметры, которые можно передавать только по ключу, добавлены в Python 3.
- С версии 3.8 введены параметры, доступные только по позиции, с использованием `/`.
- **Полезные модули для функционального программирования**:
    - `operator`: содержит функции для работы с операциями, например, `mul`, `itemgetter`, `attrgetter`.
    - `functools.partial`: позволяет создать новую функцию с заранее установленными значениями для некоторых аргументов, что удобно для адаптации функций под определенные API.

### Полезные модули для функционального программирования

### 1. Модуль `operator`

Модуль `operator` предоставляет функции, которые позволяют использовать стандартные операторы как функции, что делает код более гибким и удобным для функционального программирования.

### Пример использования `operator.mul`

Функция `operator.mul` умножает два числа. Это удобно при использовании, например, с `functools.reduce`, чтобы вычислить произведение элементов.

```python
from operator import mul
from functools import reduce

numbers = [1, 2, 3, 4, 5]
result = reduce(mul, numbers)
print(result)  # Вывод: 120
```

### Пример использования `operator.itemgetter`

Функция `operator.itemgetter` возвращает функцию, которая извлекает элемент по заданному индексу из последовательности. Это полезно для сортировки по определенному полю в списке кортежей.

```python
from operator import itemgetter

data = [
    ('apple', 3),
    ('banana', 2),
    ('cherry', 5)
]

# Сортировка по второму элементу (количество)
sorted_data = sorted(data, key=itemgetter(1))
print(sorted_data)
# Вывод: [('banana', 2), ('apple', 3), ('cherry', 5)]
```

### Пример использования `operator.attrgetter`

Функция `operator.attrgetter` возвращает функцию, которая получает значение указанного атрибута объекта. Полезно для сортировки или фильтрации по атрибуту объекта.

```python
from operator import attrgetter

class Fruit:
    def __init__(self, name, sweetness):
        self.name = name
        self.sweetness = sweetness

fruits = [
    Fruit('apple', 5),
    Fruit('banana', 8),
    Fruit('cherry', 7)
]

# Сортировка по уровню сладости
sorted_fruits = sorted(fruits, key=attrgetter('sweetness'))
print([fruit.name for fruit in sorted_fruits])
# Вывод: ['apple', 'cherry', 'banana']
```

### 2. `functools.partial`

Модуль `functools` предоставляет функцию `partial`, которая позволяет создавать новую функцию с заранее установленными значениями для некоторых аргументов. Это полезно для адаптации функций под определенные API или для использования в качестве колбэков.

### Пример использования `functools.partial`

Предположим, у нас есть функция `power`, которая возводит число в степень, и мы хотим создать новую функцию `square`, которая всегда возводит в квадрат.

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

# Создаем функцию square, которая всегда возводит в квадрат
square = partial(power, exponent=2)

print(square(5))  # Вывод: 25
print(square(3))  # Вывод: 9
```

### Пример использования `functools.partial` для передачи функции с предопределенным аргументом

При работе с функцией, которая принимает множество аргументов, можно использовать `partial`, чтобы зафиксировать часть аргументов, оставив остальные для заполнения в будущем.

```python
from functools import partial

def greet(greeting, name):
    return f"{greeting}, {name}!"

# Создаем функцию, которая всегда использует приветствие "Hello"
say_hello = partial(greet, "Hello")

print(say_hello("Alice"))  # Вывод: "Hello, Alice!"
print(say_hello("Bob"))    # Вывод: "Hello, Bob!"
```

Использование `partial` и функций из модуля `operator` позволяет упростить функциональное программирование, делая код более читаемым и компактным.

**Полноправные функции** (или **функции первого класса**) — это функции, которые могут использоваться и передаваться в программе как объекты данных. В языках, поддерживающих функции первого класса, функции обладают теми же правами и возможностями, что и другие объекты, например, переменные, списки или строки.

### Признаки полноправных функций

Если функции в языке программирования являются полноправными, они обладают следующими свойствами:

1. **Хранение в переменных**:
Функции могут быть присвоены переменным, то есть вы можете сохранить функцию в переменной и затем вызывать её через эту переменную.
    
    ```python
    def greet(name):
        return f"Hello, {name}!"
    
    say_hello = greet  # Присваиваем функцию переменной
    print(say_hello("Alice"))  # Вызов функции через переменную
    ```
    
2. **Передача как аргумента**:
Функции можно передавать как аргументы другим функциям.
    
    ```python
    def apply_function(func, value):
        return func(value)
    
    print(apply_function(greet, "Bob"))  # Передаем функцию greet как аргумент
    ```
    
3. **Возврат из других функций**:
Функции могут быть возвращены в качестве результата работы других функций. Это позволяет создавать функции внутри других функций и возвращать их в виде объектов.
    
    ```python
    def make_greeter(greeting):
        def greeter(name):
            return f"{greeting}, {name}!"
        return greeter
    
    hello_greeter = make_greeter("Hello")
    print(hello_greeter("Charlie"))  # Вызов возвращенной функции
    ```
    
4. **Хранение в структурах данных**:
Функции можно хранить в списках, словарях и других структурах данных.
    
    ```python
    actions = {
        "say_hello": greet,
        "say_goodbye": lambda name: f"Goodbye, {name}!"
    }
    print(actions["say_hello"]("Dave"))
    print(actions["say_goodbye"]("Eve"))
    ```