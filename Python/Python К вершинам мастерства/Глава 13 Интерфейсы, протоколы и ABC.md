# Глава 13. Интерфейсы, протоколы и ABC

### Утиная типизация (Duck Typing)

### Что это?

Это подход, при котором объект считается подходящим для использования в коде, если он реализует нужный набор методов, независимо от его класса или имени типа. Термин происходит из выражения: *"Если это ходит как утка и крякает как утка, то это утка."*

### Особенности:

- **Имплицитность**: Код просто предполагает, что объект умеет делать что-то, и пробует это использовать.
- **Пример**:
    
    ```python
    class Duck:
        def quack(self):
            print("Кря!")
    
    class Person:
        def quack(self):
            print("Я имитирую утку!")
    
    def make_it_quack(obj):
        obj.quack()  # Неважно, что это за объект
    
    make_it_quack(Duck())    # Кря!
    make_it_quack(Person())  # Я имитирую утку!
    ```
    
- **Преимущества**:
    - Высокая гибкость.
    - Минимум ограничений.
- **Недостатки**:
    - Ошибки возникают только во время выполнения, если объект не поддерживает ожидаемую операцию.

---

### Гусиная типизация (Goose Typing)

### Что это?

Это **явный** подход, при котором проверяется соответствие объекта абстрактному базовому классу (**ABC**). Название "гусиная" связано с более строгими требованиями (в сравнении с утиной).

### Особенности:

- **Эксплицитность**: Объект явно проверяется через `isinstance` или `issubclass`, чтобы соответствовать интерфейсу.
- Использует **абстрактные базовые классы (ABC)** из модуля `abc`.
- **Пример**:
    
    ```python
    from abc import ABC, abstractmethod
    
    class Bird(ABC):
        @abstractmethod
        def fly(self):
            pass
    
    class Goose(Bird):
        def fly(self):
            print("Гусь летит!")
    
    bird = Goose()
    isinstance(bird, Bird)  # True
    bird.fly()  # Гусь летит!
    ```
    
- **Преимущества**:
    - Более строгий контроль.
    - Ошибки ловятся раньше, чем при утиной типизации.
- **Недостатки**:
    - Менее гибкая модель, требует дополнительного кода для наследования от ABC.

---

### Статическая типизация (Static Typing)

### Что это?

Типы переменных и функций задаются **явно в коде**, и их корректность проверяется **до запуска программы** (например, через `mypy`).

### Особенности:

- В Python реализована через аннотации типов (`PEP 484`) и модуль `typing`.
- **Пример**:
    
    ```python
    from typing import List
    
    def add_numbers(numbers: List[int]) -> int:
        return sum(numbers)
    
    print(add_numbers([1, 2, 3]))  # 6
    # add_numbers(["1", "2", "3"])  # Ошибка при проверке типов (mypy)
    ```
    
- **Преимущества**:
    - Ошибки обнаруживаются еще до выполнения.
    - Упрощает рефакторинг в больших проектах.
- **Недостатки**:
    - Уменьшение гибкости и увеличение объема кода.

---

### Динамическая типизация (Dynamic Typing)

### Что это?

Тип переменной или функции определяется **в момент выполнения**. Это стандартный подход в Python.

### Особенности:

- Python сам "угадывает" тип переменных, основываясь на их значении.
- **Пример**:
    
    ```python
    def add(a, b):
        return a + b
    
    print(add(3, 4))      # 7
    print(add("a", "b"))  # ab
    ```
    
- **Преимущества**:
    - Простота и гибкость.
- **Недостатки**:
    - Ошибки могут появляться только во время выполнения, если используется несовместимый тип.

---

### Сравнение подходов

| Подход | Проверка типов | Пример использования | Преимущества | Недостатки |
| --- | --- | --- | --- | --- |
| **Утиная типизация** | Во время выполнения | Если "крякает, значит утка" | Гибкость, минимум ограничений | Ошибки только во время выполнения |
| **Гусиная типизация** | Во время выполнения | Проверка через `isinstance` | Явный контроль интерфейса | Меньшая гибкость |
| **Статическая типизация** | До выполнения | Аннотации и статические проверщики (mypy) | Раннее выявление ошибок | Дополнительный код |
| **Динамическая типизация** | Во время выполнения | Стандартный Python | Простота и универсальность | Потенциальные ошибки во время выполнения |

### **Основные типы типизации в Python**

1. **Утиная типизация (Duck Typing)**
    - **Описание**: Если объект "крякает, как утка", он считается уткой.
    - **Особенности**:
        - Основана на методах объекта, а не на его классе.
        - Пример: итерация через `__getitem__` вместо явного `__iter__`.
    - **Плюсы**: Гибкость, минимальные ограничения.
    - **Минусы**: Ошибки обнаруживаются только во время выполнения.
2. **Гусиная типизация (Goose Typing)**
    - **Описание**: Использование абстрактных базовых классов (ABC) для проверки интерфейса.
    - **Особенности**:
        - Проверка через `isinstance` и `issubclass`.
        - Включает регистрацию виртуальных подклассов через `register`.
    - **Плюсы**: Явный контроль, строгий контракт.
    - **Минусы**: Более жесткая структура, требует дополнительного кода.
3. **Статическая типизация (Static Typing)**
    - **Описание**: Проверка типов через аннотации перед запуском программы.
    - **Особенности**:
        - Вводится с Python 3.5 (PEP 484, `typing`).
        - Использует внешние проверки (`mypy`).
    - **Плюсы**: Раннее обнаружение ошибок, лучше подходит для больших проектов.
    - **Минусы**: Снижение гибкости, необходимость писать аннотации.
4. **Статическая утиная типизация (Static Duck Typing)**
    - **Описание**: Использование протоколов (`Protocol`) для структурного подтипа.
    - **Особенности**:
        - Появилось в Python 3.8 (PEP 544).
        - Проверяет структуру объекта без наследования.
    - **Плюсы**: Расширяет возможности статической типизации.
    - **Минусы**: Требует инструментов для проверки (например, `mypy`).

Python предоставляет четыре подхода к типизации: утиную, гусиную, статическую и статическую утиную. Каждый подход имеет свои плюсы и минусы, и их следует использовать в зависимости от задачи. Протоколы и ABC помогают строить гибкие, расширяемые интерфейсы, повышая читаемость и устойчивость кода.