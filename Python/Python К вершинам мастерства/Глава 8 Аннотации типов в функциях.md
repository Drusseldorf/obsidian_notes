# Глава 8. Аннотации типов в функциях

Python остаётся динамически типизированным языком, а значит, проверка типов остаётся необязательной. Типизация ввели, чтобы помочь разработчикам избежать ошибок с помощью анализа кода до его выполнения. Однако не всем пользователям Python это будет полезно в равной степени, поэтому аннотации типов остаются опциональными.

PEP 484 (Type Hints) привносит возможность явно указывать типы для аргументов функции, значений переменных и возвращаемых значений. Это помогает инструментам статического анализа находить ошибки, не выполняя код. Основное применение аннотаций типов находит себя в профессиональной разработке, где есть IDE и CI/CD-процессы.

### Что такое "постепенная типизация"?

PEP 484 представил систему **постепенной типизации** — такой подход позволяет коду оставаться совместимым, даже если не все функции имеют указанные типы. Основные принципы постепенной типизации:

1. **Опциональность**: проверка типов не обязательна. Если тип не указан, предполагается `Any`.
2. **Типизация на этапе анализа, а не во время выполнения**: аннотации помогают статическим анализаторам, но не мешают выполнению кода.
3. **Не влияет на производительность**: аннотации не оптимизируют байт-код или производительность на практике.

### Пример с функцией `show_count`

Рассмотрим функцию `show_count`, возвращающую строку в зависимости от количества и слова:

```python
def show_count(count, word):
    if count == 1:
        return f'1 {word}'
    count_str = str(count) if count else 'no'
    return f'{count_str} {word}s'
```

Мы можем добавить к функции аннотации типов, чтобы указать, что `count` должен быть целым числом, а `word` — строкой, и что функция возвращает строку:

```python
def show_count(count: int, word: str) -> str:
    if count == 1:
        return f'1 {word}'
    count_str = str(count) if count else 'no'
    return f'{count_str} {word}s'
```

### Параметризованные и обобщенные типы

Теперь переходим к обобщенным типам, которые позволяют создавать **параметризованные коллекции** и улучшать читаемость кода, определяя тип элементов в коллекциях.

Пример для списка строк:

```python
def tokenize(text: str) -> list[str]:
    return text.upper().split()
```

Здесь тип `list[str]` указывает, что возвращаемое значение — список, элементы которого обязательно строки.

### TypeVar: Параметризованные и обобщенные типы (Дженерики)

Основные концепции дженериков

### 1. **Generic**

`Generic` — это базовый класс для создания дженериков. Например, можно создать класс, который принимает параметризованный тип и работает с ним, используя специальный синтаксис.

```python
from typing import Generic, TypeVar

T = TypeVar('T')  # Создаем параметр типа

class MyContainer(Generic[T]):
    def __init__(self, value: T):
        self.value = value

    def get_value(self) -> T:
        return self.value
```

Здесь `MyContainer` является обобщенным классом, который может работать с любым типом данных. Например:

```python
container_int = MyContainer(123)        # Создаем контейнер для int
container_str = MyContainer("Hello")    # Создаем контейнер для str

print(container_int.get_value())  # Вывод: 123
print(container_str.get_value())  # Вывод: Hello
```

### 2. **TypeVar**

`TypeVar` — это специальная функция, которая создает "переменную типа". Она позволяет указать, что тип переменной будет определяться при использовании. Это используется в функциях и классах, чтобы обозначить тип, который можно подставить.

```python
from typing import TypeVar

T = TypeVar('T')  # Создаем переменную типа

def echo(value: T) -> T:
    return value

print(echo(123))         # Вывод: 123
print(echo("Привет"))    # Вывод: Привет
```

Здесь функция `echo` принимает аргумент любого типа `T` и возвращает значение того же типа.

### 3. **Обобщенные коллекции (Generic Collections)**

В Python обобщенные типы можно использовать с коллекциями, например, `List`, `Dict`, `Set`, `Tuple` и т.д., для указания типа данных внутри коллекций.

```python
from typing import List, Dict

def process_list(items: List[int]) -> int:
    return sum(items)

def get_item(data: Dict[str, int], key: str) -> int:
    return data.get(key, 0)
```

Здесь `process_list` принимает список целых чисел, а `get_item` — словарь, где ключ — строка, а значение — целое число.

### 4. **Ограниченные дженерики (Bounded Generics)**

С помощью `TypeVar` можно ограничить типы, которые могут быть переданы в качестве параметров, указав базовый класс. Например, если вы хотите, чтобы обобщенный класс или функция принимали только числовые значения, можно ограничить это с помощью `TypeVar`.

```python
from typing import TypeVar
from numbers import Number

T = TypeVar('T', bound=Number)  # Ограничиваем тип числами

def add(a: T, b: T) -> T:
    return a + b

print(add(1, 2))        # Вывод: 3
# print(add("1", "2"))  # Ошибка: несоответствие типов
```

Здесь функция `add` принимает только числовые значения благодаря ограничению `bound=Number`.

### Примеры использования

### Обобщенные функции

```python
from typing import TypeVar, List

T = TypeVar('T')

def get_first_element(lst: List[T]) -> T:
    return lst[0] if lst else None

print(get_first_element([1, 2, 3]))      # Вывод: 1
print(get_first_element(["a", "b", "c"]))  # Вывод: "a"
```

### Обобщенные классы с несколькими параметрами типов

```python
from typing import TypeVar, Generic

K = TypeVar('K')
V = TypeVar('V')

class KeyValue(Generic[K, V]):
    def __init__(self, key: K, value: V):
        self.key = key
        self.value = value

    def get_key_value(self) -> tuple[K, V]:
        return self.key, self.value

pair = KeyValue("age", 30)
print(pair.get_key_value())  # Вывод: ("age", 30)
```

Здесь класс `KeyValue` может работать с любыми парами типов: `K` — для ключа, а `V` — для значения.

### Итог

Дженерики позволяют писать код, который гибок к типам данных, обеспечивая при этом строгую проверку типов. Это делает код более читаемым, безопасным и удобным для использования, особенно при работе с большими проектами, где важно следить за типами данных.

Для того чтобы гибко обрабатывать разные типы данных, используется `TypeVar`. Это переменная типа, которая позволяет создавать функции с универсальными типами. Например, функция `sample`, которая принимает последовательность `Sequence[T]` и возвращает список тех же элементов `list[T]`, будет работать с любым типом `T`:

```python
from typing import Sequence, TypeVar
from random import shuffle

T = TypeVar('T')

def sample(population: Sequence[T], size: int) -> list[T]:
    if size < 1:
        raise ValueError('size must be >= 1')
    result = list(population)
    shuffle(result)
    return result[:size]
```

Эта функция работает с любыми типами элементов, будь то строки, целые числа или другие объекты.

### `TypeVar` с ограничениями

Иногда необходимо ограничить тип переменной. Например, `mode` должна возвращать элемент, который поддерживает операции хеширования. В этом случае мы указываем ограничение `bound`:

```python
from typing import TypeVar, Iterable, Hashable
from collections import Counter

HashableT = TypeVar('HashableT', bound=Hashable)

def mode(data: Iterable[HashableT]) -> HashableT:
    pairs = Counter(data).most_common(1)
    if len(pairs) == 0:
        raise ValueError('no mode for empty data')
    return pairs[0][0]
```

Теперь функция `mode` вернёт значение того же типа, что и элементы, находящиеся в `data`, при этом поддерживающие хеширование.

### Обобщение через `Protocol` и статическое утко-типизирование

Протоколы позволяют использовать статическое утко-типизирование. Например, если функция должна обрабатывать значения, которые можно отсортировать (поддерживают `<`), можно создать протокол `SupportsLessThan` и использовать его в `TypeVar` с ограничением `bound`:

```python
from typing import Protocol, TypeVar, Iterable

class SupportsLessThan(Protocol):
    def __lt__(self, other: Any) -> bool: ...

T = TypeVar('T', bound=SupportsLessThan)

def top(series: Iterable[T], length: int) -> list[T]:
    ordered = sorted(series, reverse=True)
    return ordered[:length]
```

Таким образом, `top` может принимать любые типы, которые можно сравнивать, будь то строки, числа или объекты с методом `__lt__`.

### Callable: аннотация для функций в качестве аргументов

Для аннотации параметров типа "функция" используется `Callable`. Например, функция `repl`, которая принимает на вход другую функцию для обработки ввода пользователя, будет аннотироваться так:

```python
from typing import Callable

def repl(input_fn: Callable[[str], str]) -> None:
    while True:
        line = input_fn(">>> ")
        if line == 'exit':
            break
        print(eval(line))
```

### NoReturn

Используется для функций, которые никогда не возвращают значения, например, функции, выбрасывающие исключения:

```python
from typing import NoReturn

def raise_error(message: str) -> NoReturn:
    raise Exception(message)
```

### Подведение итогов

Подсказки типов — мощный инструмент, улучшающий читаемость и надёжность кода, но они остаются опциональными. Используя `TypeVar`, `Protocol`, `Callable`, и другие типы из `typing`, можно создавать гибкие и удобные API, сохраняя динамическую природу Python.

## От Алексея

Алексей не согласен, что типизация это сложно долго и вообще мол пишите юниты и будьте счастливы, нет! Тайпхинты для веб разраба средней руки - маст хэв.

**Цели типизации**

- раннее выявление ошибок — до рантайма, до попадания кода на продакшн
- ту же задачу решают тесты
- правильная типизация помогает уменьшить количество тестов, которые писать и поддерживать сложнее типов
- улучшение читаемости кода
- упрощение разработки в IDE / PDE (pde - персональная среда разработчика? типа неовим настроенный для программирования с LSP)

**LSP — Liskov Substitution Principle**

Принцип подстановки Барбары Лисков

- это один из принципов SOLID Роберта Мартина, буква L в аббревиатуре
- одна из формулировок: «функции, которые используют базовый тип, должны иметь возможность использовать его подтипы, не зная об этом»
- то есть подтипы должны расширять поведение родителя, но не ломать его

**Sequence vs Iterable**

В чём разница?

- `Iterable` — общий тип, `Sequence` его частный случай.
- По обоим можно итерироваться, но вычислить длину можно только у `Sequence`, `Iterable` может быть бесконечным.
- У `Sequence` можно взять произвольный элемент по числовому индексу, `Iterable` не обязан поддерживать такое.
- Примеры `Sequence` — `list`, `tuple`, `str`, `bytes` (позволяют получить по числовому индексу элемент).
- Примеры `Iterable` — все `Sequence` плюс `dict`, `file-object` и другие.

Про стаб файлы: [https://youtu.be/KofihAoSp2U](https://youtu.be/KofihAoSp2U)

**Параметр функции vs Аргумент функции**

- Это не одно и то же.
- Параметр функции — это то, что мы используем внутри функции и задаём в сигнатуре (определении) функции.
- Аргумент функции — это то, что мы передаём в функцию.

Вот пример кода, который иллюстрирует разницу между параметрами и аргументами:

```python
# Определение функции с параметрами a и b
def sum(a: int, b: int) -> int:
    return a + b

# Вызов функции с аргументами 10 и 20
result = sum(10, 20)

print(f"Результат: {result}")
```

Объяснение:

- В определении функции `sum` — `a` и `b` являются **параметрами**.
- При вызове `sum(10, 20)` — `10` и `20` являются **аргументами**, которые передаются в функцию `sum` и привязываются к параметрам `a` и `b`.

**Интерфейс vs Абстрактный класс vs Протокол**

Интерфейс

В строгом понимании, интерфейс — это контракт, который определяет, какие методы и свойства должен реализовать класс, без указания их реализации. В Python в явном виде интерфейсов нет, как, например, в Java, но их можно эмулировать с помощью абстрактных классов, где все методы остаются абстрактными (не содержат реализации). Это делает интерфейсы полезными, когда нужно обозначить обязательный набор методов для классов-наследников, что гарантирует наличие определенного функционала, сохраняя гибкость в реализации.

Абстрактный класс

Абстрактный класс — это класс, который содержит как абстрактные методы, так и методы с готовой реализацией. Это позволяет создать базовую функциональность, которую могут использовать подклассы, сохраняя при этом возможность добавлять собственные реализации для некоторых методов. В Python абстрактные классы реализуются с помощью модуля `abc`. Абстрактный класс полезен, когда нужно частично реализовать функционал и оставить некоторые методы для обязательной реализации в дочерних классах.

Пример использования абстрактного класса:

```python
from abc import ABC, abstractmethod

class Animal(ABC):
    @abstractmethod
    def speak(self):
        pass

    def move(self):
        print("Moving forward")

class Dog(Animal):
    def speak(self):
        print("Woof!")
```

Протокол

Протоколы (protocols) — это новая концепция, появившаяся в Python с `typing.Protocol`. Протоколы можно рассматривать как неявные интерфейсы. Если класс имеет все методы, указанные в протоколе, он считается совместимым с ним, даже если он не является его наследником. Это позволяет писать более гибкий код, где проверка типов основана на "утиных типах" (duck typing). Протоколы помогают сохранять типобезопасность, не ограничивая структуру классов жесткими связями.

Пример протокола:

```python
from typing import Protocol

class Flyable(Protocol):
    def fly(self) -> None:
        ...

class Bird:
    def fly(self) -> None:
        print("Flying")

def take_off(flyable: Flyable):
    flyable.fly()

bird = Bird()
take_off(bird)  # Работает, так как Bird соответствует протоколу Flyable
```

### Сравнение:

- **Интерфейсы** строго описывают контракт без реализации, поддерживаются неявно через абстрактные классы в Python.
- **Абстрактные классы** позволяют частично реализовать функционал и определяют обязательные методы для наследников.
- **Протоколы** обеспечивают гибкость "утиных типов", позволяя использовать классы, которые не наследуются от определенного интерфейса или абстрактного класса, но имеют требуемые методы.

Таким образом, протоколы в Python предоставляют более гибкий механизм для описания контрактов и, в отличие от интерфейсов и абстрактных классов, позволяют сохранить стиль программирования, характерный для динамически типизированных языков, в то время как абстрактные классы дают больше контроля над функциональностью и позволяют задавать базовую реализацию.

Основные типы, которые часто используются в Python и которые "достаточно" для типизации в большинстве случаев. Вот более детальное объяснение каждого пункта:

1. **Простые типы** — это базовые типы данных, такие как `str`, `int`, `bytes`, `float`, `Decimal`, и `bool`. Они используются для представления строк, целых чисел, байтов, чисел с плавающей точкой, десятичных значений с фиксированной точностью и булевых значений соответственно.
2. **Объединение типов** — оператор `|` используется для указания, что переменная может быть одним из нескольких типов. Например, `str | int` означает, что значение может быть либо строкой, либо целым числом.
3. **Опциональность** — позволяет указать, что значение может быть типа `str` или `None`. Это часто используется для типов, которые могут принимать `None` в качестве значения, когда данные отсутствуют.
4. **Свои классы (в т.ч. датаклассы)** — позволяет использовать пользовательские типы, такие как `User`, `UserGroup` и т.п. Это расширяет возможности типизации, так как позволяет описывать более сложные структуры данных.
5. **Абстрактные контейнеры** — такие как `Iterable`, `Sequence`, `Mapping`, `MutableMapping`, которые представляют коллекции данных, например, последовательности или отображения. Они описывают поведение коллекций, но не указывают на конкретную реализацию.
6. **Реализации контейнеров** — конкретные типы коллекций, такие как `list`, `tuple`, `set`, и `dict`. Эти типы используются для работы с коллекциями данных и имеют определенное поведение и методы.

Этот набор типов и подходов к типизации покрывает большинство типовых случаев при разработке на Python, делая код более читаемым, предсказуемым и помогающим избежать ошибок на ранних этапах.

## Never, NoReturn

Ссылка на видео разбор - https://youtu.be/etkNsCRoKNY

Never - чтобы показать статическому интерпретатору, что какой то кейс никогда не должен быть вызван. Хороший пример с матч - кейс: Имеется третий атрибут у класса Operation, но он никак не обработан в match-case, при этом в случае _ стоит функция возвращающая Never. Благодаря этому анализатор кода понимает, что этот кейс не должен быть вызван, но технически он может вызываться из-за чего выводится ошибка на 19 строчке

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%208%20%D0%90%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%B2%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85%201301dd2d7a1e80558d87dde6bb328fe4/image.png)

NoReturn - функция не должна возвращать ничего, в том числе и None. Пример когда функция возбуждает исключение:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%208%20%D0%90%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D0%B8%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%20%D0%B2%20%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F%D1%85%201301dd2d7a1e80558d87dde6bb328fe4/image%201.png)