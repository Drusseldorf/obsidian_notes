# Глава 11. Объект в духе Python

# Краткий разбор с кодом

Для библиотек и фреймворков "пайтоник" заключается в том, чтобы сделать их интуитивно понятными для Python-разработчиков. Благодаря модельному подходу к данным (Data Model), пользовательские типы в Python могут работать так же естественно, как и встроенные типы, без необходимости наследования.

### Основные цели в создании класса Vector2d (на его примере смотрим возможности)

1. Поддержка встроенных функций преобразования объектов в другие типы (`repr()`, `bytes()`, `complex()` и т.д.).
2. Реализация альтернативного конструктора как метода класса.
3. Расширение мини-языка форматирования, используемого `f-strings`, `format()`, и методом `str.format()`.
4. Обеспечение доступа к атрибутам только для чтения.
5. Возможность создания хэшируемого объекта для использования в множествах и в качестве ключей словаря.
6. Сокращение использования памяти с помощью `__slots__`.

### Пример использования Vector2d

```python
v1 = Vector2d(3, 4)
print(v1.x, v1.y)  # Вывод: 3.0 4.0
x, y = v1
print(x, y)  # Вывод: (3.0, 4.0)
print(repr(v1))  # Вывод: Vector2d(3.0, 4.0)
v1_clone = eval(repr(v1))
print(v1 == v1_clone)  # Вывод: True
print(str(v1))  # Вывод: (3.0, 4.0)
octets = bytes(v1)
print(octets)  # Вывод: b'd\x00\x00\x00\x00\x00\x00\x08@...'
print(abs(v1))  # Вывод: 5.0
print(bool(v1), bool(Vector2d(0, 0)))  # Вывод: (True, False)
```

### Реализация Vector2d

Рассмотрим реализацию класса Vector2d с основными методами, обеспечивающими его поведение как "пайтоник" объекта:

```python
from array import array
import math

class Vector2d:
    typecode = 'd'

    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)

    def __iter__(self):
        return (i for i in (self.x, self.y))

    def __repr__(self):
        class_name = type(self).__name__
        return '{}({!r}, {!r})'.format(class_name, *self)

    def __str__(self):
        return str(tuple(self))

    def __bytes__(self):
        return (bytes([ord(self.typecode)]) + bytes(array(self.typecode, self)))

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        return bool(abs(self))
```

### Альтернативный конструктор (classmethod)

Добавим метод `frombytes`, который позволяет создавать объект из байтового представления.

```python
@classmethod
def frombytes(cls, octets):
    typecode = chr(octets[0])
    memv = memoryview(octets[1:]).cast(typecode)
    return cls(*memv)
```

Использование `classmethod` полезно для создания альтернативных конструкторов, которые работают с классом, а не с экземплярами.

### Мини-язык форматирования (Formatted Displays)

Добавим поддержку мини-языка форматирования, чтобы объекты `Vector2d` могли быть отформатированы с использованием `format()` и `f-strings`.

```python
def __format__(self, fmt_spec=''):
    if fmt_spec.endswith('p'):
        fmt_spec = fmt_spec[:-1]
        coords = (abs(self), self.angle())
        outer_fmt = '<{}, {}>'
    else:
        coords = self
        outer_fmt = '({}, {})'
    components = (format(c, fmt_spec) for c in coords)
    return outer_fmt.format(*components)
```

Этот метод позволяет добавлять пользовательские спецификаторы, такие как `p` для полярных координат.

### Хэшируемость (Hashable)

Чтобы сделать объекты `Vector2d` хэшируемыми, необходимо реализовать `__hash__` и сделать атрибуты неизменяемыми (на самом деле это не обязательно, достаточно хеш метод реализовать). Для этого мы можем использовать свойства (декоратор @property).

```python
class Vector2d:
    # ...

    @property
    def x(self):
        return self.__x

    @property
    def y(self):
        return self.__y

    def __hash__(self):
        return hash((self.x, self.y))
```

### Использование **slots** для экономии памяти

Чтобы оптимизировать использование памяти, можно задать `__slots__`, указав список допустимых атрибутов. Это позволит избежать создания словаря `__dict__` для каждого экземпляра.

```python
class Vector2d:
    __slots__ = ('__x', '__y')
    typecode = 'd'
    # ...
```

`__slots__` помогает сократить потребление памяти, но добавляет некоторые ограничения, такие как невозможность добавления новых атрибутов, не указанных в `__slots__`.

### Перегрузка атрибутов класса

В Python классные атрибуты можно переопределять на уровне экземпляра. Это позволяет изменять значения атрибутов, которые являются общими для всех экземпляров, на уровне отдельных объектов.

```python
v1 = Vector2d(3.0, 4.0)
print(bytes(v1))  # Байтовое представление с 'd'

v1.typecode = 'f'  # Изменение typecode на уровне экземпляра
print(bytes(v1))  # Теперь использует 'f' для преобразования
```

Также можно создать подкласс для изменения значения атрибута на уровне класса:

```python
class ShortVector2d(Vector2d):
    typecode = 'f'
```

### Итог

Класс `Vector2d` демонстрирует множество возможностей, которые предоставляют специальные методы Python для создания "пайтоновских" объектов. Примеры включают преобразование к строкам и байтам, поддержку различных форматов, хэширование и экономию памяти.

### Основные методы, рассмотренные в главе

1. **Методы представления**: `__repr__`, `__str__`, `__format__`, `__bytes__`.
2. **Методы преобразования в числа**: `__abs__`, `__bool__`, `__hash__`.
3. **Метод сравнения**: `__eq__`.
4. **Альтернативные конструкторы**: использование `@classmethod`.
5. **Экономия памяти** с помощью `__slots__`.

# Относительно мыслей автора

### Основная идея главы

Автор подчеркивает, что для создания по-настоящему "пайтоник" объектов важно ориентироваться на то, как ведут себя встроенные типы Python. Пользовательские классы должны быть интуитивными для Python-разработчиков, а это означает, что они должны поддерживать знакомые методы и соглашения языка.

### Объектные Представления (Object Representations)

Автор отмечает, что в Python существуют два способа представления объектов: `repr()` для внутреннего представления и `str()` для внешнего, пользовательского. Цель здесь — помочь разработчику и пользователю лучше понять объект. `__repr__` должен давать полное техническое представление (возможное для воссоздания объекта через `eval`), а `__str__` — более дружелюбное, "человеческое".

**Пример реализации:**

```python
def __repr__(self):
    class_name = type(self).__name__
    return '{}({!r}, {!r})'.format(class_name, *self)

def __str__(self):
    return str(tuple(self))
```

### Альтернативный Конструктор (An Alternative Constructor)

Автор рекомендует создавать альтернативные конструкторы через `@classmethod`, которые принимают данные в различных форматах. Это помогает создавать гибкие и удобные в использовании классы. В качестве примера приводится `frombytes` для конвертации из байтов.

```python
@classmethod
def frombytes(cls, octets):
    typecode = chr(octets[0])
    memv = memoryview(octets[1:]).cast(typecode)
    return cls(*memv)
```

### classmethod против staticmethod

Автор подчеркивает полезность `@classmethod`, который передает в метод класс, а не экземпляр, что позволяет создавать альтернативные конструкторы. В то же время он скептически относится к `@staticmethod`, отмечая, что такие методы редко полезны, так как обычная функция на уровне модуля зачастую предпочтительнее.

```python
class Demo:
    @classmethod
    def klassmeth(*args):
        return args

    @staticmethod
    def statmeth(*args):
        return args
```

### Форматирование (Formatted Displays)

Автор говорит о важности добавления кастомного форматирования в классы, что позволяет объектам поддерживать встроенные функции форматирования, такие как `f-strings`, `format()` и `str.format()`. Python предоставляет мини-язык спецификаций, и можно расширить его для своего класса, как это сделано для поддержки полярных координат в `Vector2d`.

```python
def __format__(self, fmt_spec=''):
    if fmt_spec.endswith('p'):
        fmt_spec = fmt_spec[:-1]
        coords = (abs(self), self.angle())
        outer_fmt = '<{}, {}>'
    else:
        coords = self
        outer_fmt = '({}, {})'
    components = (format(c, fmt_spec) for c in coords)
    return outer_fmt.format(*components)
```

### Хэшируемость (Hashable)

Автор акцентирует внимание на том, что хэшируемость необходима для использования объектов в множествах и в качестве ключей в словарях. Для этого объект должен быть неизменяемым и иметь реализованный метод `__hash__`. В `Vector2d` мы делаем атрибуты `x` и `y` только для чтения и реализуем `__hash__`, чтобы сделать объект хэшируемым.

```python
def __hash__(self):
    return hash((self.x, self.y))
```

### Использование **slots** для Экономии Памяти

Автор отмечает, что `__slots__` может значительно снизить расход памяти, но использование этого механизма сопряжено с ограничениями. Он подходит, когда у нас много однотипных объектов и нужно избежать словаря атрибутов (`__dict__`). При этом появляется необходимость заранее задавать список допустимых атрибутов, что делает классы менее гибкими.

```python
class Vector2d:
    __slots__ = ('__x', '__y')
    typecode = 'd'
```

**Важно:** Автор предупреждает, что оптимизация памяти с помощью `__slots__` оправдана только при работе с миллионами объектов, а в других случаях она может добавить ненужную сложность.

### Переопределение Атрибутов Класса (Overriding Class Attributes)

В Python атрибуты класса могут быть переопределены на уровне экземпляра. Автор рекомендует использовать эту возможность для создания настраиваемых объектов или для наследования классов с небольшими изменениями. Например, можно задать `typecode` на уровне экземпляра, чтобы изменить представление `Vector2d` в байтах.

```python
v1 = Vector2d(3.0, 4.0)
v1.typecode = 'f'
```

Если же нужно изменить `typecode` для всех экземпляров, автор предлагает создать подкласс и переопределить атрибут на уровне класса.

```python
class ShortVector2d(Vector2d):
    typecode = 'f'
```

### Заключение

Автор отмечает, что добавление всех этих методов делает класс "пайтоник" и удобным для других разработчиков, но не всегда нужно реализовывать их все, особенно в прикладных приложениях. Полный набор методов может быть полезен для библиотек и фреймворков, где пользователи ожидают стандартного поведения объектов Python.

**Основная мысль:** Чтобы создать по-настоящему "пайтоник" объект, важно наблюдать за поведением встроенных объектов Python и следовать этим примерам.