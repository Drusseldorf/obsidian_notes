# Глава 2. Массив последовательностей

## Общие сведения о встроенных последовательностях

Встроенные последовательности реализованы на C, их можно разделять по разным признакам:

1. **Контейнерные последовательности**

В них хранятся ссылки на объекты любого типа
****
Могут хранить элементы разных типов, в том числе вложенные контейнеры. Примеры: list, tuple, collections.deque (как list но можно добавлять и удалять элементы либо справа, либо слева.)

2. **Плоские последовательности**

Хранятся сами значения прямо в памяти, занятой последовательностью, а не как отдельные объекты Питона

****Позволяют хранить элементы только одного типа. 
Примеры: str, bytes, array.array (Неизменяемая последовательность, позволяющая компактно хранить объекты одного из базовых типов)

Каждый объект Пайтон, находящийся в памяти, имеет заголовок с метаданными. Например, у float, имеется поле самого значения, счетчик ссылок на объект, указатель типа объекта

Еще можно разделять последовательности по изменяемости:

1. **Изменяемые**
2. **Неизменяемые**

Причем изменяемые наследуют от неизменяемых все методы (дандер: getitem, contains, iter, reversed) и реализуют дополнительные (дандер: setitem, delitem и др).
*Я тут пишу не все*

## Списковые включения

Лусиано пишет, что если уж используем компрехеншон листа, то предполагается, что мы этот лист таки будет как-то дальше использовать (Не надо его использовать что-бы как то повторить блок кода, тогда уж лучше стандартный for .. in ..)

Аналогично, если включение занимает больше двух строчек, то лучше использовать цикл for..

Интересный пример, как можно получить декартово произведение в виде списка, от перемножения двух других последовательностей с помощью лист компрехеншона

Например у нас имеются футболки с цветами black, white, и с размерами: s, m, l. Как быстро создать список со всеми вариантами футболок?

```python
colors = ['black', 'white']
sizes = ['s', 'm', 'l']
tshirts = [(color, size) for color in colors for size in sizes]
```

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%202%20%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%20%D0%BF%D0%BE%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D1%81%D1%82%D0%B5%D0%B8%CC%86%20c378ba40c8ef407dbe07df3834172f70/image.png)

Что эквивалентно конструкции со вложенным классическим for:

Кстати пример с колодой карт из первой главы - это как раз оно и есть, декартово произведение для получения для каждой карты все масти.

```python
for color in colors:
    for size in sizes:
        print((color, size))
```

## Генераторные выражения

Генераторное выражение - экономит память и отдает элементы по одному, применяя протокол итератора.

Если генераторное выражение - единственный аргумент для функции, то можно не дублировать круглые скобки:

```python
some_tuple = tuple('hi' for _ in range(5))
```

Причем, есть интересный способ использовать его в цикле for. Мы не храним в памяти целиком список, чтобы просто пройтись по нему циклом for. Интересный способ применения:

```python
for tshirt in (f'{c} {s}' for c in colors for s in sizes):
    print(tshirt)
```

## Кортеж - не просто не изменяемый список

Гвидо в частной беседе с Лусиано: “То, что кортежи ведут себя как последовательности - просто хак”.

Сделаю тут вставку из конспекта по просмотру одного собеса на ютубе:

> *Итерирование по кортежу происходит быстрее, чем по списку
Кортеж потребляет меньше памяти, чем список
Если все элементы кортежа ХЭШИРУЕМЫЕ, то он может быть ключом в словаре
Кортеж неизменяемый тип данных, в отличие от списка*
> 
> 
> *Кортеж - набор **разнородных** (не обязательно однотипных данных). Тут стоит упомянуть именованные кортежи, в которых можно удобно хранить такие данные. И обращаться в таком случае к элементам можно через точечную нотацию.
> Однако именованные кортежи все же уступают по скорости фризед датаклассам. Если речь именно про хранение и считывание данных.
> 
> В списке обычно на практике хранят **однотипные объекты***
> 

Вообще говоря, у кортежей две функции: использование в качестве неизменяемых списков и в качестве записей с неименованными полями.

**Кортежи как записи**

Тут Лусиано подмечает, что по сути кортежи используются как записи данных по какому-то конкретному объекту, например, координаты. То есть, нам важно, что во первых, данные в записи идут строго в одном порядке, а во вторых, количество данных элементов строго определено.

```python
some_coords = (33.9425, -118,403882)
```

 

**Кортежи как неизменяемые списки**

Тут мы получаем:
*Ясность* - видим в коде кортеж и понимаем, что его длина никогда не изменится
*Производительность* - кортеж потребляет меньше памяти, чем список той же длины а так же позволяет интерпретатору выполнять некоторые оптимизации.

Не стоит забывать, что неизменяемость относится только к ссылкам на объекты. То есть если сами объекты изменяемы, то это приведет к тому, что кортеж в целом будет содержать ссылку уже на измененный объект. Кортеж хешируемый только если содержит неизменяемые объекты. Тогда он может быть элементом множества или быть ключом словаря (что кстати тоже самое, ибо это и есть множества)

Интересная инфа от кор разработчика пайтон:
Отвечая на вопрос “Правда ли что кортежи эффективнее списков”:

> Так как кортеж имеет фиксированную длину, то для него выделяется ровно столько памяти, сколько необходимо. А вот для листов память выделяется с запасом.
Ссылки на элементы кортежа хранятся в массиве, находящемся в самой структуре кортежа. А вот для списка хранится указатель на массив ссылок, размещенный где то в другом месте. Это из-за того, что список может перестать помещаться в выделенный участок памяти, и нужно будет перераспределять память для массива ссылок
> 

Кортеж поддерживает все методы списков, не связанные с добавлением или удалением элементов

## Распаковка последовательностей и итерируемых объектов

Можно красиво обменять значения переменных без использования еще одной временной переменной:

```python
a, b = b, a
```

Можно взять из последовательность только интересующие элементы, а распаковкой просто добить чтобы не было ошибки:

```python
a, b, *_ = range(5)
>>> a, b, _
(0, 1, [2, 3, 4])
```

Как распаковать вложенные кортежи:

Допустим имеем такой:

```python
metro_areas = [
    ('some name', 'jp', 36.77, (23.66453, 34.59382))
    ]
```

Тогда распаковка вложенного будет такая:

```python
for name, _, _, (lat, lon) in metro_areas:
    print(name, lat, lon)
```

Синтаксическая тонкость:
если кортеж состоит из одного элемента, то в конце нужно писать запятую

## Паттерн матчинг. Сопоставление с последовательностями-образцами

Появилось в пайтон 3.10.
Есть видео у Алексея - [https://youtu.be/0kyy_zKO86U?si=Cay2fToIXjhrP1wc](https://youtu.be/0kyy_zKO86U?si=Cay2fToIXjhrP1wc)

Общий вид:

```python
metro_areas = [
    ('some name', 'jp', 36.77, (23.66453, 34.59382))
    ]

for record in metro_areas:
    match record:
        case [name, _, _, (lat, lon)] if lon > 0:
            print(f'{name} | {lat} | {lon}')
        case _:
            print('nothing')
```

if - является необязательным охранным условием

Сопоставление считается успешным если:

1. Субъект (то что указываем после match) является некой последовательностью
2. Субъект и образец (то что после case)  содержат одинаковое число элементов
3. Все соответственные элементы, включая вложенные, совпадают

Квадратные и круглые скобки скобки в последовательностях образцах означают одно и то же. Можно просто все указывать в круглых, все равно сработает.

Стоит обратить внимание, что str, bytes и bytearray не являются последовательностями в контексте match\case. Их нужно преобразовывать в match: match tuple(’123’)

Символ _ в образцах имеет особый смысл, он сопоставляется с одним любым элементом в этой позиции, но не связывается со значением. Так же это единственная переменная, которая может встречаться более одного раза в образце. 

Любую часть образца можно связать с переменной через as:
case [name **as city_name**, _, _, (lat, lon)]

Можно так же задать образцам тип:

case [str(name), _, _, (lat, lon)]

 Это выглядит как вызов конструктора (приведение к типу), но в контексте образца эта конструкция проводит только проверку типа субъекта.

Можно так же не писать несколько раз _ а можно просто:

*_ 

Причем, если мы используем другую переменную для имени, например *some то ей будет присвоен список, а вот для _ не присваивается значения 

## Срезы

Почему в срезы и диапазоны не включается последний элемент?

1. Легко понять длину среза. Типа range(3), some_list[:3] содержат 3 элемента
2. Легко вычислить длина среза или диапазона, если заданы начальная и конечная позиции, нужно просто вычислить их разность
3. Легко разбить их на две непересекающиеся части: [:x], [x:]

Срезы это по сути еще одни объекты в питоне. Так что можно создать именованный срез и применить его уже к последовательность. Это хорошо, если мы хотим внести больше ясности в наш код.

Через нотацию среза можно изменять элементы последовательности или удалять их:

some_list[2:3] = [20, 30]

## Когда список не подходит

Тут в целом говорится когда лучше список, а когда например множество или deque, или array (да-да, таки в пайтоне есть отдельные массивы, обычно используются для научных целей, когда у нас например огромный список чисел)
В общем, тут конспектировать особо не буду, главное запомним что далеко не всегда использование только кортежа или списка является эффективным решением. Если что, проверяй книгу :)