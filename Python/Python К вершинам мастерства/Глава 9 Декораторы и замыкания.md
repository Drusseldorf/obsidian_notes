# Глава 9. Декораторы и замыкания

### Декораторы и замыкания в Python

**Декораторы** позволяют "отмечать" функции в коде для изменения их поведения. Чтобы понять декораторы, необходимо разобраться с концепцией **замыканий**, которые возникают, когда функция захватывает переменные, определённые вне её тела.

**nonlocal** — одно из редких ключевых слов в Python. Оно полезно для работы с замыканиями и необходимо для написания собственных декораторов.

Декораторы - по сути просто синтаксический сахар для передачи одной функции на вход в качестве аргумента другой функции:

Когда мы пишем код с использованием декоратора, например:

```python
@my_decorator
def my_function():
    print("Hello, world!")
```

На самом деле это просто синтаксический сахар для следующего:

```python
def my_function():
    print("Hello, world!")

my_function = my_decorator(my_function)
```

То есть, `@my_decorator` — это просто более короткий способ записать вызов декоратора, который принимает `my_function` в качестве аргумента и заменяет её на новую функцию, возвращаемую декоратором.

---

### `functools.wraps`

`functools.wraps` — это декоратор из модуля `functools` в Python, который используется для того, чтобы создать "хорошо себя ведущий" декоратор. Когда мы создаем декоратор, часто бывает, что при его использовании оригинальная функция теряет свои метаданные, такие как `__name__`, `__doc__` и другие, так как они перезаписываются внутренней функцией в декораторе. `functools.wraps` позволяет избежать этой проблемы, сохраняя оригинальные метаданные.

### Как это работает

Когда мы создаем декоратор, внутри него обычно объявляется функция-обёртка, которая выполняет дополнительные действия, прежде чем вызвать оригинальную функцию или после её выполнения. При этом без `functools.wraps` внутренняя функция-обёртка заменяет оригинальную функцию, и её метаданные перезаписывают исходные.

Используя `functools.wraps`, мы можем автоматически скопировать метаданные оригинальной функции в функцию-обёртку.

### Пример использования

Рассмотрим пример декоратора без использования `wraps`:

```python
def my_decorator(func):
    def wrapper(*args, **kwargs):
        """Внутренняя функция-обёртка"""
        print("Вызов функции:", func.__name__)
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """Эта функция выводит приветствие."""
    print("Привет!")

say_hello()
print(say_hello.__name__)  # Вывод: wrapper
print(say_hello.__doc__)    # Вывод: Внутренняя функция-обёртка
```

Здесь мы видим, что `say_hello` теперь указывает на `wrapper`, и информация о функции `say_hello`, такая как её имя и документация, была потеряна.

Теперь исправим это, используя `functools.wraps`:

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # копирует метаданные из func в wrapper
    def wrapper(*args, **kwargs):
        print("Вызов функции:", func.__name__)
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def say_hello():
    """Эта функция выводит приветствие."""
    print("Привет!")

say_hello()
print(say_hello.__name__)  # Вывод: say_hello
print(say_hello.__doc__)    # Вывод: Эта функция выводит приветствие.
```

Теперь после использования `@wraps(func)` метаданные оригинальной функции `say_hello` сохраняются, и они доступны при обращении к `say_hello.__name__` и `say_hello.__doc__`.

### Зачем нужен `functools.wraps`

Использование `wraps` делает декораторы более "чистыми" и удобными для использования. Это особенно полезно, когда:

1. **Документация и аннотации типов**. С `wraps` сохраняются аннотации типов и документация, что делает декорированные функции понятными при чтении кода или при использовании в средах разработки (IDE), которые отображают документацию.
2. **Тестирование**. Сохранение оригинальных метаданных функции полезно при тестировании, когда имя и документация функции нужны для понимания теста.
3. **Инструменты анализа и рефлексии**. Некоторые инструменты или библиотеки (например, `help()`, `inspect`) полагаются на оригинальные метаданные функции. `wraps` позволяет сохранить корректную информацию для таких инструментов.

### Как работает `functools.wraps`

`functools.wraps` — это просто ещё один декоратор, который принимает функцию и копирует её атрибуты (такие как `__name__`, `__doc__`, `__annotations__`) в функцию-обёртку, которая декорирует оригинальную функцию.

### Рекомендуемое использование `functools.wraps`

Если вы создаёте собственные декораторы, которые возвращают новую функцию, всегда используйте `@wraps`. Это делает код более удобным и облегчает отладку.

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        # Здесь можно добавить дополнительное поведение
        result = func(*args, **kwargs)
        # Дополнительные действия после вызова func
        return result
    return wrapper
```

`wraps` — это "лучшие практики" для создания декораторов в Python, позволяющие сохранить первоначальные характеристики декорируемой функции.

### Введение в декораторы

Декоратор — это функция, которая принимает другую функцию как аргумент и возвращает её или заменяет на другую функцию. Это позволяет изменять поведение функции без изменения её кода. Декораторы вызываются сразу после определения функции, которую они украшают при импорте модуля. (**A key feature of decorators is that they run right after the decorated function is defined. That is usually at import time)**

### Пример декоратора

```python
def deco(func):
    def inner():
        print('running inner()')
    return inner

@deco
def target():
    print('running target()')

target()  # Вывод: running inner()
```

Здесь функция `target` заменяется на `inner`, что подтверждается вызовом `target()`.

---

### Когда выполняются декораторы

Декораторы выполняются сразу после определения функции, которую они декорируют. Рассмотрим пример:

```python
registry = []

def register(func):
    print(f'running register({func})')
    registry.append(func)
    return func

@register
def f1():
    print('running f1()')

@register
def f2():
    print('running f2()')
```

При импорте этого модуля `register` выполнится дважды, добавляя функции `f1` и `f2` в `registry`.

---

### Область видимости переменных

В Python существует три уровня области видимости переменных:

1. **Локальная область функции**
2. **Глобальная область модуля**
3. **Нелокальная область (используется в замыканиях)**

```python
def f1(a):
    print(a)
    print(b)

b = 6
f1(3)  # Вывод: 3 6
```

Переменная `b` доступна из глобальной области. Однако, если в функции есть присваивание к `b`, она становится локальной, даже если присваивание находится после её использования.

Например вот такое поведение может стать неожиданным:

```bash
>>> def f1(a):
...     print(a)
...     print(b)
...     b = 4 # из-за того, что мы объявили b в функции, теперь интерпретатор
								# будет считать ее локальной
...
>>> b = 2
>>> f1(3)
3
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
  File "<stdin>", line 3, in f1
UnboundLocalError: cannot access local variable 'b' 
where it is not associated with a value
```

Чтобы b считалось все таки не локальной переменной  на этапе, когда мы ее еще не инициализировали, то нужно добавить global b перед print(b)

---

### Замыкания

**Замыкание** — это функция, которая сохраняет значения переменных, существующих во внешней функции. Это позволяет вложенной функции использовать переменные, которые больше не существуют в области видимости.

### Пример замыкания

хотя на момент вызова avg() локальной области видимости make_averager уже нет, тем не менее avg способна обращаться к series

```python
def make_averager():
    series = []

    def averager(new_value):
        series.append(new_value)
        return sum(series) / len(series)

    return averager

avg = make_averager()
print(avg(10))  # 10.0
print(avg(11))  # 10.5
```

---

### Свободные переменные

**Свободная переменная** — это переменная, которая используется внутри функции, но определена вне её. Свободные переменные позволяют функции "помнить" значения, даже если они больше недоступны в текущей области видимости. Обычно это встречается в случае вложенных функций.

Например:

```python
def outer():
    x = 10  # переменная x является свободной для inner

    def inner():
        print(x)  # x не определена внутри inner, но она "свободная" из outer

    return inner
```

В этом примере `x` — это свободная переменная для функции `inner`, так как она не объявлена в `inner`, но доступна из области видимости `outer`.

### Замыкания

**Замыкание** — это механизм, который позволяет функции "запоминать" окружение, в котором она была создана, даже если это окружение уже не существует. Когда мы создаём замыкание, Python сохраняет контекст внешних переменных, на которые ссылается вложенная функция. Эти переменные сохраняются в специальном атрибуте функции, называемом `__closure__`.

Рассмотрим более сложный пример:

```python
def make_multiplier(factor):
    def multiply_by_factor(number):
        return number * factor
    return multiply_by_factor

mult_by_3 = make_multiplier(3)
print(mult_by_3(5))  # Вывод: 15
```

Здесь `factor` — свободная переменная для `multiply_by_factor`. Когда `make_multiplier(3)` создаёт функцию `mult_by_3`, `factor` сохраняется в замыкании функции `multiply_by_factor`. Таким образом, даже после выхода из `make_multiplier`, `factor` всё ещё доступна через `mult_by_3`.

### Инспекция замыканий: `__closure__` и `co_freevars`

Python хранит информацию о замыкании в атрибуте `__closure__` функции. Этот атрибут содержит список переменных, сохранённых для функции. Каждая переменная представлена в виде **ячейки** (cell), которая хранит значение этой переменной.

Другой полезный атрибут — `co_freevars`, который находится в объекте `__code__` функции. `co_freevars` содержит имена всех свободных переменных, используемых функцией.

### Пример инспекции замыкания

Посмотрим на примере:

```python
def make_adder(n):
    def add(x):
        return x + n
    return add

add_five = make_adder(5)
print(add_five(10))  # Вывод: 15
```

Теперь можем использовать атрибуты `__closure__` и `co_freevars` для инспекции замыкания функции `add_five`.

```python
print(add_five.__code__.co_freevars)  # Вывод: ('n',)
print(add_five.__closure__[0].cell_contents)  # Вывод: 5
```

- `co_freevars` показывает, что `n` — это свободная переменная для `add`.
- `__closure__` содержит список ячеек, которые хранят значения свободных переменных. Здесь `cell_contents` позволяет получить фактическое значение `n`, которое равно 5.

### Объяснение атрибутов

- **`__closure__`** — это атрибут, который содержит информацию о замыкании функции. Он хранит список "ячеек" (`cell`), каждая из которых содержит значение одной свободной переменной.
- **`co_freevars`** — это атрибут объекта `__code__` функции. Он хранит имена свободных переменных, но не их значения.

### Ключевое слово `nonlocal`

Если вложенная функция должна изменять переменные (которые являются неизменяемыми например, то есть мы вынуждены создавать новое имя и переприсваивать ему объект) из замыкания, используется `nonlocal`. Это позволяет обновлять значения переменных, определённых во внешней функции.

### Пример использования `nonlocal`

```python
def make_averager():
    count = 0
    total = 0

    def averager(new_value):
        nonlocal count, total
        count += 1
        total += new_value
        return total / count

    return averager
```

---

### Создание простого декоратора

Пример простого декоратора, который измеряет время выполнения функции:

```python
import time

def clock(func):
    def clocked(*args):
        t0 = time.perf_counter()
        result = func(*args)
        elapsed = time.perf_counter() - t0
        print(f'[{elapsed:0.8f}s] {func.__name__}({args}) -> {result}')
        return result
    return clocked
```

Применение:

```python
@clock
def snooze(seconds):
    time.sleep(seconds)

snooze(0.123)
```

---

### Декораторы из стандартной библиотеки

Python предлагает несколько мощных декораторов:

- `@cache` и `@lru_cache` для кэширования результатов функции
- `@singledispatch` для реализации **single-dispatch generic functions**, которые позволяют создавать разные реализации одной функции для разных типов аргументов (в итоге получим функцию, которая ведет себя по разному в зависимости от типа данных, который был передан ей на вход в качестве аргумента)

### Пример использования `@cache`

```python
from functools import cache

@cache
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)
```

---

### Параметризованные декораторы

Чтобы создать декоратор с параметрами, необходимо создать фабрику декораторов — функцию, которая возвращает сам декоратор.

### Пример параметризованного декоратора

```python
def clock(fmt):
    def decorate(func):
        def clocked(*args):
            t0 = time.perf_counter()
            result = func(*args)
            elapsed = time.perf_counter() - t0
            print(fmt.format(elapsed=elapsed, func=func.__name__))
            return result
        return clocked
    return decorate

@clock('{func} выполнена за {elapsed:0.8f} секунд')
def sleep_func(seconds):
    time.sleep(seconds)
```

---

### Логика поиска переменных в Python

Когда интерпретатор Python видит переменную в коде, он следует определённым правилам, чтобы найти её значение. Этот процесс поиска называется **LEGB**-правилом, что расшифровывается как:

- **L (Local)** — Локальная область видимости.
- **E (Enclosing)** — Область видимости, охватывающая (или "включающая" функцию).
- **G (Global)** — Глобальная область видимости модуля.
- **B (Built-in)** — Встроенная область видимости Python (например, `len`, `print`).

Каждую из этих областей видимости Python проверяет в определённом порядке. Рассмотрим каждую из них подробнее.

### 1. **Local (Локальная область видимости)**

Переменная считается локальной, если она объявлена внутри функции. Это самая внутренняя область видимости, доступная только внутри функции, где переменная была создана.

Пример:

```python
def my_func():
    x = 10  # x — локальная переменная для my_func
    print(x)

my_func()  # Вывод: 10
```

В этом примере `x` — локальная переменная для `my_func`, и она не доступна за пределами этой функции.

### 2. **Enclosing (Включающая область видимости)**

Если внутри функции объявлена другая функция, то внутренняя функция имеет доступ к переменным внешней функции. Это называется включающей (или охватывающей) областью видимости.

Пример:

```python
def outer():
    x = 10  # x — переменная включающей области видимости для inner

    def inner():
        print(x)  # inner может использовать x из outer

    inner()  # Вывод: 10

outer()
```

Здесь `x` не является локальной переменной для `inner`, но так как она находится в функции, которая охватывает `inner`, Python может её найти в этой включающей области.

### 3. **Global (Глобальная область видимости)**

Глобальная область видимости определена на уровне модуля. Глобальные переменные доступны как из функций, так и из других частей кода, если они объявлены в пределах модуля.

Пример:

```python
x = 10  # глобальная переменная

def my_func():
    print(x)  # my_func имеет доступ к глобальной переменной x

my_func()  # Вывод: 10
print(x)  # Вывод: 10
```

Здесь `x` объявлена в глобальной области, и она доступна как внутри `my_func`, так и за её пределами.

### 4. **Built-in (Встроенная область видимости)**

Эта область содержит все встроенные функции и константы Python, такие как `len`, `print`, `True`, `False` и так далее. Если переменная не найдена в локальной, включающей и глобальной областях, Python попытается найти её во встроенной области.

Пример:

```python
def my_func():
    print(len([1, 2, 3]))  # вызов встроенной функции len

my_func()  # Вывод: 3
```

### Как Python определяет область видимости

Python решает, к какой области относится переменная, на этапе компиляции. Это означает, что перед выполнением кода интерпретатор уже знает, является ли переменная локальной, глобальной или принадлежит включающей области видимости. Поэтому, если мы объявляем переменную внутри функции, Python считает её локальной.

Пример, показывающий возможные ошибки:

```python
x = 10

def my_func():
    print(x)  # Ошибка: UnboundLocalError
    x = 5  # Python считает, что x — локальная, так как ей присваивается значение

my_func()
```

Здесь возникает ошибка `UnboundLocalError`, так как Python считает, что `x` должна быть локальной переменной в `my_func`, но мы пытаемся использовать её до присвоения значения. Если мы хотим явно указать, что `x` — глобальная переменная, то можем использовать ключевое слово `global`.

### Глобальные и нелокальные переменные

Чтобы изменить значение глобальной переменной внутри функции, нужно использовать ключевое слово `global`:

```python
x = 10

def my_func():
    global x
    x = 20  # изменяем глобальную переменную x

my_func()
print(x)  # Вывод: 20
```

Если же мы хотим изменить переменную включающей области видимости, а не глобальную, можно использовать ключевое слово `nonlocal`, которое появилось в Python 3:

```python
def outer():
    x = 10

    def inner():
        nonlocal x
        x = 20  # изменяем переменную из области outer

    inner()
    print(x)  # Вывод: 20

outer()
```

### Инспекция свободных переменных: `__code__` и `__closure__`

Когда функция использует переменные из внешней области видимости, они сохраняются в её замыкании. Мы можем проверить это, используя атрибуты `__code__` и `__closure__`.

### `__code__.co_freevars`

Атрибут `co_freevars` объекта `__code__` хранит имена всех свободных переменных функции (т.е. переменных, которые не являются локальными, но при этом не глобальные).

Пример:

```python
def outer():
    x = 10

    def inner():
        print(x)

    return inner

f = outer()
print(f.__code__.co_freevars)  # Вывод: ('x',)
```

### `__closure__`

Атрибут `__closure__` хранит значения свободных переменных в виде списка "ячеек" (`cell`). Каждая ячейка содержит одну свободную переменную.

Пример:

```python
def outer():
    x = 10

    def inner():
        print(x)

    return inner

f = outer()
print(f.__closure__[0].cell_contents)  # Вывод: 10
```

Таким образом, атрибут `__closure__` позволяет получить значения переменных из замыкания.

### Итог

- **Local** — локальные переменные внутри функции.
- **Enclosing** — переменные из охватывающих функций, если функция вложена.
- **Global** — переменные, объявленные на уровне модуля.
- **Built-in** — встроенные переменные и функции Python.

Понимание этой иерархии (LEGB) помогает избежать ошибок при работе с переменными, особенно в случаях с замыканиями и декораторами.

### Декораторы как классы

Вместо функций декораторы могут быть реализованы как классы, реализующие метод `__call__`. Это полезно для сложных декораторов, так как делает код более читабельным.

```python
class Clock:
    def __init__(self, fmt):
        self.fmt = fmt

    def __call__(self, func):
        def clocked(*args):
            t0 = time.perf_counter()
            result = func(*args)
            elapsed = time.perf_counter() - t0
            print(self.fmt.format(elapsed=elapsed, func=func.__name__))
            return result
        return clocked

@Clock('{func} завершена за {elapsed:0.8f} секунд')
def sleep_func(seconds):
    time.sleep(seconds)
```

---

### Заключение

Эта глава охватывает принципы работы декораторов и замыканий. Понимание замыканий и области видимости переменных помогает создавать мощные декораторы. Декораторы — это отличный способ расширить функционал функции, делая код более выразительным и удобным для работы.