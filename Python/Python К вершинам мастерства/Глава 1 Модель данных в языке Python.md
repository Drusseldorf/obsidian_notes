# Глава 1. Модель данных в языке Python

Рассказывается, что по сути модель данных в питоне описывает сам питон как каркас.

Она описывает API, следуя которому можно согласовать свои объекты со стандартными средствами языка пайтон, так как они сами в свою очередь используют тот же API.

Дандер методы (*dunder = double underscore, двойное подчеркивание*) - это как раз и есть по идее этот API, они же - магические методы

## Реализация колоды карт

Этот пример хорошо показывает как очень мощно возможно согласовать реализацию работы своего объекта (колода карт) со стандартными средствами Пайтона. **

```python
from typing import NamedTuple

class Card(NamedTuple):
    rank: str
    suit: str

class Deck:
    ranks = [str(n) for n in range(6, 11)] + list('JQKA')
    suits = ['spades', 'diamonds', 'clubs', 'hearts']

    def __init__(self):
        self._cards = [Card(rank, suit) for suit in self.suits for rank in self.ranks]

    def __len__(self):
        return len(self._cards)

    def __getitem__(self, position):
        return self._cards[position]
```

Использовали именованный кортеж, просто чтобы он представлял собой объект карты.

Именованные кортежи можно использовать для репрезентации объекта, который просто содержит какие то поля и не реализовывает свои методы. Хотя стоит отметить, что тут можно было бы использовать датакласс

Реализовали в классе колоды два дандер метода:
__len__ и __getitem__

Что нам это дало?

Для начала, теперь мы можем получить размер колоды просто применив стандартную функцию len к объекту нашей колоды:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image.png)

Как получить карту из колоды? Да просто через синтаксис *[ ]*

Например, получим 8-ую карту нашей колоды:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%201.png)

Аналогично, работают все виды срезов, например, получим первые три карты:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%202.png)

А что если мы хотим получить случайную карту из колоды? Опять же, используем стандартные средства пайтона - random библиотеку

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%203.png)

Доступно так же и итерирование по нашей колоде

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%204.png)

Итерирование часто подразумевается неявно. Если в коллекции отсутствует метод __contains__, то оператор in производит последовательный просмотр.

Наш объект поддерживает in потому что наш объект итерируемый

## Как используются специальные методы

Дандер методы предназначены для вызова интерпретатором, а не разработчиком.

Например for i in x: подразумевает вызов функции iter(x) которая в свою очередь может вызывать метод x.__iter__() если он реализован, а если нет то x.__getitem__() как в примере нашей колоды карт.

Единственный специальный метод который явно вызывается из пользовательского кода это метод __init__ для того чтобы инициализировать конструктор родительского класса.

Примечание: вообще говоря это происходит не атомарно, сначала вызывается дандер new, а потом уже init

## Строковое представление

Метод __repr__ вызывается встроенной функцией repr() для получения строкового представления объекта. Если его не реализовывать, то мы получаем строку вида:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%205.png)

А если реализовать repr:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%206.png)

То получим уже:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%207.png)

В отличии от __repr__, метод __str__ вызывается str() и предназначен для отображения пользователя как бы хуман френдли представление об объекте. А вот __repr__ же должен давать точное, однозначное представление об объекте.

Когда вызывает print, то ищется сначала __str__, а если его нет, тогда уже __repr__.

Если репр уже имеет хорошее наглядное представление об объекте тогда стр уже и не нужен. Если вы реализуете один из этих двух методов, то пусть лучше это будет репр

Кроме того, репр нужно реализовывать так, чтобы к нему можно было применить eval - эта функция собирает объект из представления в репр. При этом репр должен быть реализован однозначно, лучше всего согласно конструктору объекта. Что имеется в виду:

Вот конструктор:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%208.png)

А вот репр:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%209.png)

Тогда eval - создаст новый объект:

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%201%20%D0%9C%D0%BE%D0%B4%D0%B5%D0%BB%D1%8C%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D1%8F%D0%B7%D1%8B%D0%BA%D0%B5%20Python/image%2010.png)

цель `__repr__`— быть однозначным, а цель `__str__` — читабельным

```python
import datetime

# Отличный пример для наглядности – **datetime**:

>>> dt = datetime.datetime(2019, 7, 27)

>>> repr(dt)

'datetime.datetime(2019, 7, 27, 0, 0)'

>>> str(dt)

'2019-07-27 00:00:00'

>>> eval(repr(dt)) == dt

True
```

**str** от **datetime** просто покажет нам дату и время в удобном формате; **repr** от **datetime** вернет строку, в которой будет вызов описан конструктора конкретно этого объекта, да так, что при исполнении этой строки как кода на Python функцией **eval** – мы получим объект **datetime** для той же даты

eval - позволяет выполнять пайтон код, читая его как строку

!r - Флаг **!r** вызывает **repr(x) (условно говоря, чтобы числа оставались числами, а не становились строками в выводе репра, сырой формат (r - raw))**

## Про bool

bool(x) вызывает x.__bool__().

Если __bool__ не реализован, то интерпретатор пытается вызвать __len__, и тут при получении 0 возвращается False

## Почему len не метод?

1. Унификация. 
Имеется много контейнеров (последовательностей), к тому же можно делать свои.
Благодаря глобальной функции len можно вычислять их длины не используя что-то другое.
2. Предсказуемость.
3. Гвидо говорит:
HCI. Human-computer interface. Для некоторых операций префиксная нотация читается лучше чем постфиксная
4. Спорная херня, так ли уж это полезно, имеются холивары