# Глава 3. Словари и Множества

> Python - по сути своей словари, обернутые тоннами синтаксического сахара
— Лало Мартинс, один из первых цифровых номандов и питонистов
> 

## Введение

1. Python во многом основан на словарях. Атрибуты классов, пространств имён, именованные аргументы функций – все они используют структуру данных словаря (тип `dict`).
2. Словари – это фундаментальная часть реализации Python. Многие встроенные объекты и функции хранятся в специальном словаре `__builtins__.__dict__`.
3. В основе словарей лежат **хеш-таблицы**, которые обеспечивают высокую производительность операций с ними.
4. **Множества (set и frozenset)**: Эти типы данных используются для работы с уникальными значениями. Они позволяют выполнять такие операции, как объединение, пересечение, разница и проверка на подмножества. В их основе так же лежат хэш-таблицы.
5. Множества в Python реализуют многие операции, встречающиеся в других языках программирования. Использование множеств помогает упростить код, избегая излишних вложенных циклов и условий.

Основные моменты: словари и множества являются мощными и фундаментальными структурами данных, обеспечивающими высокую производительность в Python.

## Современный синтаксис словарей

### Словарные включения

Словарные включения работают аналогично списковым включениям и появились в Python начиная с версии 2.7. С их помощью можно создавать словари на основе генераторов. Пример простого словарного включения:

```python
{ключ: значение for элемент in итерируемый_объект} 
# или
{ключ: значение for элемент1, элемент2 in итерируемый_объект} 
```

Это мощный инструмент для динамического создания словарей на основе данных из других коллекций.

---

***Пример на практике: Коды стран***

Взгляни на такой пример: у нас есть список телефонных кодов стран, и мы можем легко преобразовать его в словарь с использованием словарных включений.

Исходные данные — список кортежей:

```python
dial_codes = [
    (880, 'Bangladesh'),
    (55, 'Brazil'),
    (86, 'China'),
    (91, 'India'),
    (62, 'Indonesia'),
    (81, 'Japan'),
    (234, 'Nigeria'),
    (92, 'Pakistan'),
    (7, 'Russia'),
    (1, 'United States')
]
```

Создание словаря (могли конечно же просто использовать конструктор dict(),  но тут просто для примера):

```python
country_dial = {country: code for code, country in dial_codes}
```

Теперь у нас есть словарь, где страны — это ключи, а телефонные коды — значения:

```python
{
 'Bangladesh': 880, 'Brazil': 55, 'China': 86, 'India': 91,
 'Indonesia': 62, 'Japan': 81, 'Nigeria': 234, 'Pakistan': 92,
 'Russia': 7, 'United States': 1
}
```

---

***Сортировка и манипуляции***

Ты также можешь сортировать этот словарь, например, по странам или преобразовывать значения. Вот как можно получить упорядоченный список стран с телефонными кодами, где код меньше 70:

```python
{code: country.upper() for country, code in sorted(country_dial.items()) if code < 70}
```

Результат будет таким:

```python
{55: 'BRAZIL', 62: 'INDONESIA', 7: 'RUSSIA', 1: 'UNITED STATES'}
```

### Распаковка отображений

В версии Python 3.5 появилась поддержка распаковки отображений сверху вниз. Эта функция была введена в рамках PEP 448 (Additional Unpacking Generalizations).

**1:** его можно применять при вызове функции для передачи ключевых аргументов, как в примере, причем можно использовать даже несколько операторов ** в аргументе функции, при условии что все ключи - строки И среди аргументов функции нет повторяющихся ключей.

```python
def dump(**kwargs):
    return kwargs
dump(x=1, y=2, z=3)
# {'x': 1, 'y': 2, 'z': 3}
```

**2:** можно использовать для распаковки внутри словарного литерала. Можно объединить несколько словарей и задать новые значения ключей:

```python
x = {'a': 1, 'b': 2}
y = {'z': 3}
{**x, 'y': 2, **y}
# {'a': 1, 'b': 2, 'y': 2, 'z': 3}
```

Оператор распаковки можно использовать несколько раз в одном выражении, и он поддерживает использование нескольких словарей, при этом повторяющиеся ключи перезаписываются последними значениями.

---

### Объединение отображений оператором `|`

- В Python 3.9 были введены операторы `|` и `|=` для объединения отображений (словарей). Это новый синтаксис для объединения словарей, аналогичный использованию оператора `|` для множеств.
- Оператор `|` создаёт новое отображение, объединяя исходные словари:
    
    ```python
    d1 = {'a': 1, 'b': 3}
    d2 = {'a': 2, 'b': 4, 'c': 6}
    d1 | d2
    # {'a': 2, 'b': 4, 'c': 6}
    ```
    
- **Особенности работы оператора `|`:**
    - Тип нового словаря обычно совпадает с типом левого операнда. Однако, если правый операнд имеет другой пользовательский тип, то применяется тип правого операнда.
    - Если ключи совпадают, то значение из правого словаря перезаписывает значение из левого.
- Оператор `|=` изменяет содержимое существующего словаря:
    
    ```python
    d1 |= d2
    # d1: {'a': 2, 'b': 4, 'c': 6}
    ```
    
- **Совместимость с предыдущими версиями Python:** Если нужно поддерживать код для версий Python до 3.9, для объединения словарей можно использовать методы из PEP 584 или другие способы объединения отображений.

---

## Сопоставление с отображением-образцом

- В Python 3.10 был введён новый механизм сопоставления с образцом (pattern matching), который позволяет более структурированно работать с отображениями, в том числе с JSON API и базами данных, такими как MongoDB, EdgeDB или PostgreSQL.
- **Пример функции, использующей сопоставление с образцом:**
    
    ```python
    def get_creators(record: dict) -> list:
        match record:
            case {'type': 'book', 'api': 2, 'authors': [*names]}:  # <1>
                return names
            case {'type': 'book', 'api': 1, 'author': name}:  # <2>
                return [name] 
            case {'type': 'book'}:  # <3>
                raise ValueError(f"Invalid 'book' record: {record!r}")
            case {'type': 'movie', 'director': name}:  # <4>
                return [name] 
            case _:  # <5>
                raise ValueError(f'Invalid record: {record!r}')
    ```
    
- **Разбор примера:**
    1. Сопоставляем со словарем, в котором есть type': 'book', 'api': 2,
    а в authors - некая последовательность.
    Возвращаем элементы последовательности в виде нового списка.
    2. Сопоставляем со словарем, в котором есть type': 'book', 'api': 1,
    а в authors - произвольный объект.
    Возвращаем этот объект в виде списка из этого элемента одного name.
    3. Любой другой словарь в котором 'type': 'book' - Недопустим, поднимаем исключение.
    4. Если есть 'type': 'movie', а у 'director' есть одиночное значение то вернем этот объект в виде элемента в списке.
    5. Любой другой объект недопустим, поднимаем исключение
- **Пример использования функции:**
    
    ```python
    >>> b1 = dict(api=1, author='Douglas Hofstadter',
    ... type='book', title='Gödel, Escher, Bach')
    >>> get_creators(b1)
    ['Douglas Hofstadter']
    >>> from collections import OrderedDict
    >>> b2 = OrderedDict(api=2, type='book',
    ... title='Python in a Nutshell',
    ... authors='Martelli Ravenscroft Holden'.split())
    >>> get_creators(b2)
    ['Martelli', 'Ravenscroft', 'Holden']
    >>> get_creators({'type': 'book', 'pages': 770})
    Traceback (most recent call last):
     ...
    ValueError: Invalid 'book' record: {'type': 'book', 'pages': 770}
    >>> get_creators('Spam, spam, spam')
    Traceback (most recent call last):
     ...
    ValueError: Invalid record: 'Spam, spam, spam'
    ```
    
- **Особенности сопоставления:**
    - Порядок ключей в образцах не имеет значения, даже если субъект это OrderedDict
    - Сопоставление считается успешным, даже  в случае частичного совпадения с образцом 
    В тестах субъекты b1 и b2 включают ключ title, которого нет в образце book, и тем не менее сопоставление успешно.

При сопоставлении возникает вопрос, а как же быть в DefoultDict, ведь там при вызове дандер getitem (то есть при синтаксисе через указание ключа в квадратных скобках) создается динамически отсутствующее значение. Стало быть они всегда пройдут патерн матчинг?

Конечно, ответ нет. Дело в том, что при паттерн матчинг используется d.get(key, sentinel), где sentil по умолчанию это специальный маркер, который точно не может встретиться в пользовательском коде \ данных. 

PS get вторым аргументом получает значение, которое нужно отдать, если ключа такого нет в словаре.

## Что значит хешируемый?

Вот определение из глоссария Python:

> Объект является хешируемым, если у него есть хеш-код, который не изменяется в течение его жизненного цикла (у него должен быть метод __hash__()), и его можно сравнивать с другими объектами (у него должен быть метод __eq__()). Хешируемые объекты, которые считаются равными при сравнении, должны иметь одинаковый хеш-код.
> 

Все неизменяемые типы данных хешируемы.

Кортежи хешируемы, если все их элементы хешируемы.

**`dict` — работает как hash map**

- от ключа берётся хеш-функция
- O(1) в среднем случае:
    - установка `dict[key]`
    - проверка `key in dict`
    - поиск `dict[key]`
- значение хеш-функции — адрес в памяти, где хранится значение

---

### Дополнение информации:

**Как работает хеширование в Python словарях (dict)**:

- В словарях Python ключи должны быть хешируемыми объектами, то есть объектами, которые имеют неизменяемый хеш-код (например, строки, числа, кортежи).
- Когда вы обращаетесь к элементу словаря по ключу, Python вычисляет хеш-код ключа с помощью встроенной функции `hash()`.
- Этот хеш-код используется для определения местоположения элемента в памяти. Это позволяет быстро находить значения, соответствующие ключам, с помощью минимального количества операций (в среднем O(1)).

**Операции с `dict` и их сложность**:

- **Вставка** (`dict[key] = value`): При вставке значения по ключу Python вычисляет хеш ключа и добавляет пару ключ-значение в соответствующую ячейку памяти.
- **Поиск** (`value = dict[key]`): Хеш ключа вычисляется, и по этому хешу находится соответствующий элемент в словаре.
- **Проверка существования ключа** (`key in dict`): Работает так же, как поиск значения. Вычисляется хеш ключа, и по нему проверяется наличие элемента в словаре.

**Обработка коллизий**:

- Иногда два разных ключа могут иметь одинаковый хеш-код — это называется коллизией. Python решает этот вопрос, храня все элементы с одинаковым хешем в цепочке (в виде списка), и затем перебирает их для нахождения нужного ключа. Это верно только для старых диктов. Смотри новые конспекты в другой теме заметок.
- Хотя это увеличивает сложность до O(n) в худшем случае, на практике такие ситуации редки, и средняя сложность операций остаётся O(1).

## Пример утиной типизации в контексте словарей

У словарей например имеется метод d.update(m). Он расширяет словарь d словарем m.

Как это делается под капотом?

Для начала Python проверяет, крякает ли m как словарь? А именно проверяется есть ли у m метод keys() - он возвращает список из ключей. Если есть, значит ведем себя с m как со словарем.

А если его нет? Тогда предполагается, что m имеет элементы парами (key, value). То есть по сути m может быть произвольным итерируемым объектом, порождающим пары key, value. Тогда метод update вполне себе сработает, ведь главное что m крякает как словарь ну или, может хотябы дать нам пары ключ-значение. Вот такой вот Python.

## collections.Counter

`Counter` из модуля `collections` — это отображение, которое хранит целочисленный счётчик для каждого ключа. Когда обновляется существующий ключ, к его счётчику прибавляется новое значение. Этот класс можно использовать для подсчёта экземпляров хешируемых объектов или как **множество с кратностями** (multiset).

---

### Основные возможности `Counter`:

1. **Подсчёт элементов**:
    - `Counter` позволяет считать количество вхождений каждого элемента в последовательности.
    - Пример использования для подсчёта букв в строке:
        
        ```python
        >>> ct = collections.Counter('abracadabra')
        >>> ct
        Counter({'a': 5, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
        ```
        
2. **Метод `update()`**:
    - Позволяет обновить счётчики, добавляя вхождения из новой последовательности:
        
        ```python
        >>> ct.update('aaaaazzz')
        >>> ct
        Counter({'a': 10, 'z': 3, 'b': 2, 'r': 2, 'c': 1, 'd': 1})
        ```
        
3. **Метод `most_common([n])`**:
    - Возвращает список кортежей с n наиболее часто встречающимися элементами и их количеством:
        
        ```python
        >>> ct.most_common(3)
        [('a', 10), ('z', 3), ('b', 2)]
        ```
        
    - Важно отметить, что если несколько элементов имеют одинаковое количество вхождений (например, `'b'` и `'r'`), метод всё равно покажет только указанное количество элементов.

## Интересный пример избавления от дубликатов, но с сохранением порядка первого вхождения элементов

Множество - это коллекция уникальных объектов. Основной вариант использования - удаление дубликатов:

```python
l = ['spam', 'spam', 'eggs', 'spam', 'bacon', 'eggs']
set(l)
{'eggs', 'spam', 'bacon'}
list(set(l))
['eggs', 'spam', 'bacon']
```

Если вы хотите удалить дубликаты, но при этом сохранить порядок
первого появления каждого элемента, теперь вы можете использовать обычный словарь,
вот так:

```python
dict.fromkeys(l).keys()
dict_keys(['spam', 'eggs', 'bacon'])
list(dict.fromkeys(l).keys())
['spam', 'eggs', 'bacon']
```

fromkeys работает так:

```python
>>> l = ["some1", "some2", "some3"]
>>> dict.fromkeys(l)
{'some1': None, 'some2': None, 'some3': None}
```

## **Зачем нам** dict_keys, dict_values, dict_items

- **Неизменяемые** — не возникнет рассинхронизации данных со словарём.
- **Не дублируют данные в памяти**.
- **Дают функциональность множеств** (для `dict_keys` и `dict_items`).

---

### Дополнение информации:

1. **Что возвращают методы:**
    - `dict_keys()`: возвращает объект специального типа `dict_keys`, который ведёт себя как множество. Это не просто список или кортеж, это отдельный объект, который отражает изменения в словаре.
    - `dict_values()`: возвращает объект `dict_values`, который отображает все значения словаря, но не является списком или кортежем. Это отдельный объект, который обновляется при изменении словаря.
    - `dict_items()`: возвращает объект `dict_items`, который содержит пары ключ-значение и также ведёт себя как множество.
2. **Особенности:**
    - Эти структуры данных (например, `dict_keys`, `dict_items`) **неизменяемы**. Это значит, что они не могут быть изменены напрямую, что предотвращает возникновение ошибок рассинхронизации между этими объектами и исходным словарём.
    - Эти структуры **не дублируют данные в памяти**. В отличие от списков или кортежей, они являются представлениями на оригинальный словарь. То есть, они динамически обновляются при изменении словаря, не требуя копирования данных.
    - Для `dict_keys` и `dict_items` реализована функциональность множеств, что позволяет использовать операции, такие как пересечение, объединение и проверка на вхождение. Например:
        
        ```python
        keys = some_dict.keys()
        other_keys = other_dict.keys()
        common_keys = keys & other_keys  # Пересечение ключей двух словарей
        ```