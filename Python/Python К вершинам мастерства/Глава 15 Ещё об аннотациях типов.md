# Глава 15. Ещё об аннотациях типов

### **1. Перегруженные сигнатуры (`@overload`)**

### **Что это?**

- `@overload` позволяет аннотировать функции, которые могут принимать разные комбинации типов параметров и возвращать разные типы.
- Это особенно полезно для функций, где тип возвращаемого значения зависит от типов нескольких параметров.

### **Как это работает?**

- Перегруженные функции описываются в `@overload`, но их реализация предоставляется в отдельной функции без аннотаций.

### **Пример:**

```python
from typing import overload, Iterable, Union, TypeVar

T = TypeVar('T')
S = TypeVar('S')

@overload
def sum(it: Iterable[T]) -> Union[T, int]: ...
@overload
def sum(it: Iterable[T], start: S) -> Union[T, S]: ...

def sum(it, start=0):  # Реальная функция без аннотаций
    return functools.reduce(operator.add, it, start)
```

### **Тонкости:**

1. **Очередность проверки перегрузок:** Статический анализатор проверяет их по порядку. Например, `sum(range(100), 1000)` проверяется сначала на первую сигнатуру, а затем на вторую.
2. **Использование двойного подчёркивания:** `__iterable` — это соглашение PEP 484 для позиционных аргументов, которые нельзя передавать как именованные (например, `sum(my_list)` допустимо, но `sum(__iterable=my_list)` — нет).
3. **Реальная реализация без типов:** Реализация функции (`def sum(...)`) остаётся без аннотаций типов. Это снижает шум кода.

### **Советы автора:**

- **Не перегружайте функции понапрасну.** Аннотирование простой функции, как в примере, может казаться избыточным.
- Изучайте примеры перегрузок в `typeshed`, где таких примеров сотни.

---

### **2. TypedDict**

### **Что это?**

- `TypedDict` добавляет аннотации типов к словарям, где ключи фиксированы, а значения имеют определённые типы.

### **Пример:**

```python
from typing import TypedDict

class BookDict(TypedDict):
    isbn: str
    title: str
    authors: list[str]
    pagecount: int
```

### **Особенности:**

1. `TypedDict` существует **только для статической проверки типов.**
2. При выполнении это обычный словарь:
    
    ```python
    book = BookDict(
        isbn='0134757599',
        title='Refactoring, 2e',
        authors=['Martin Fowler', 'Kent Beck'],
        pagecount=478
    )
    print(type(book))  # <class 'dict'>
    ```
    
3. **Типизация помогает, но не защищает от ошибок в рантайме:**
    
    ```python
    book['weight'] = 4.2  # Mypy выдаст ошибку, но Python выполнит код.
    del book['title']     # Mypy запретит удаление ключа.
    ```
    

### **Тонкости:**

1. `TypedDict` не заменяет проверку JSON на этапе выполнения. Для этого нужны библиотеки вроде `pydantic`.
2. Если ключи словаря не соответствуют типу, это остаётся проблемой только для статического анализатора.

### **Советы автора:**

- Не используйте `TypedDict` вместо проверок в рантайме, особенно при работе с динамическими структурами вроде JSON.

---

### **3. Приведение типов с помощью `typing.cast`**

### **Что это?**

- `typing.cast()` сигнализирует анализатору типов, что переменная имеет определённый тип.

### **Пример:**

```python
from typing import cast

def find_first_str(items: list[object]) -> str:
    index = next(i for i, x in enumerate(items) if isinstance(x, str))
    return cast(str, items[index])
```

### **Тонкости:**

1. **Никакой проверки в рантайме.** `cast` просто возвращает переданное значение.
2. **Не злоупотребляйте `cast`:** Частое использование может указывать на проблемы в коде или низкое качество внешних зависимостей.

### **Советы автора:**

- Используйте `cast`, только если нет других решений. В противном случае, это "запах кода".
- В некоторых случаях вместо `cast` можно использовать `# type: ignore`, но это менее информативно.

---

### **4. Чтение аннотаций типов во время выполнения**

### **Что это?**

- Аннотации типов хранятся в атрибуте `__annotations__`.

### **Пример:**

```python
def clip(text: str, max_len: int = 80) -> str: ...
print(clip.__annotations__)
# {'text': <class 'str'>, 'max_len': <class 'int'>, 'return': <class 'str'>}
```

### **Проблемы:**

1. **Зависимость от времени выполнения:**
    - При импорте модуля аннотации типов интерпретируются, что может замедлять загрузку.
2. **Обратные ссылки (Forward References):**
    - Когда класс ссылается на самого себя, аннотации нужно записывать в виде строки:
        
        ```python
        class Node:
            def __init__(self, value: int, next: 'Node' = None): ...
        ```
        

### **Советы автора:**

- Используйте `typing.get_type_hints()` вместо чтения `__annotations__` напрямую. Это надёжнее.

---

### **5. Обобщённые классы (Generics)**

### **Что это?**

- Обобщённые классы позволяют создавать классы, которые работают с параметризованными типами.

### **Пример:**

```python
from typing import TypeVar, Generic

T = TypeVar('T')

class LottoBlower(Generic[T]):
    def __init__(self, items: list[T]):
        self._items = items
```

### **Тонкости:**

1. **Инвариантность по умолчанию:** Если тип используется и для ввода, и для вывода данных, класс должен быть инвариантным.
2. **Избегайте сложных обобщённых API:** Они могут усложнить использование типов.

---

### **6. Вариантность (Variance)**

### **Что это?**

- Вариантность описывает, как подтипы соотносятся с типами в обобщённых классах:
    - **Инвариантность:** `C[A]` не совместим с `C[B]`.
    - **Ковариантность:** Если `B <: A`, то `C[B] <: C[A]`.
    - **Контравариантность:** Если `B <: A`, то `C[A] <: C[B]`.

### **Пример:**

1. **Ковариантный класс:**
    
    ```python
    T_co = TypeVar('T_co', covariant=True)
    
    class BeverageDispenser(Generic[T_co]):
        def dispense(self) -> T_co: ...
    ```
    
2. **Контравариантный класс:**
    
    ```python
    T_contra = TypeVar('T_contra', contravariant=True)
    
    class TrashCan(Generic[T_contra]):
        def put(self, item: T_contra): ...
    ```
    

### **Советы автора:**

- Если тип используется только для возвращаемых значений, он может быть ковариантным.
- Если тип используется только для аргументов методов, он может быть контравариантным.

---

### **7. Протоколы (Protocols)**

### **Что это?**

- Протоколы определяют интерфейсы (сигнатуры методов) без реализации.

### **Пример:**

```python
from typing import Protocol

class SupportsAbs(Protocol):
    def __abs__(self) -> float: ...
```

### **Особенности:**

- Протоколы полезны для определения интерфейсов, которые могут использоваться в статической проверке.
- Они работают как "утки" — объект может соответствовать протоколу, если у него есть все необходимые методы.

---

### Выводы:

1. Аннотации типов полезны, но не всегда окупают усилия.
2. Обобщённые классы, протоколы и перегрузки помогают создавать точные API, но усложняют код.
3. Используйте статическую типизацию там, где это оправдано, но не пытайтесь аннотировать весь код.

## Ковариантность

**Можно использовать переданный тип или его дочерние типы**

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2015%20%D0%95%D1%89%D0%B5%CC%88%20%D0%BE%D0%B1%20%D0%B0%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%201501dd2d7a1e80c799ffef412c97f659/96aab7f9-dc0e-49de-972d-063d8a4e2e85.png)

Мы можем использовать нотацию, например, Sequence[Employee] и передавать туда объекты наследники этого класса, так как он является их родителем. Статический анализатор кода не выдаст ошибки, ему это ок, все корректно

## Инвариантность

**Можно использовать только тот тип, который мы указали, т.е. без дочерних и без общих**

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2015%20%D0%95%D1%89%D0%B5%CC%88%20%D0%BE%D0%B1%20%D0%B0%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%201501dd2d7a1e80c799ffef412c97f659/image.png)

Мы хотим чтобы в листах были конкретные типы.

На строке 10 система проверки типов отдает ошибку:

programmers_list = frontenders_lest - Fronteder is incompatible with Programmer.

**Нельзя лист от программер приравнять к более конкретной реализации - фронтендера. В другую сторону это тоже не работает, туда нельзя положить более общий тип - емплоерс.**

Почему так? Потому что листы ссылаются на один и тот же участок в памяти, так работают переменные в питоне. Один и тот же объект не может быть и листом от прогеров и листом от фронтендеров. Потому что потом когда будем аппендить один лист то и другая переменная, которая на него ссылается тоже будет аппендится. Получится ошибка типизации.

## **Контравариантность**

**Можно использовать сам тип, который мы указали или его более общие типы - родители**

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2015%20%D0%95%D1%89%D0%B5%CC%88%20%D0%BE%D0%B1%20%D0%B0%D0%BD%D0%BD%D0%BE%D1%82%D0%B0%D1%86%D0%B8%D1%8F%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2%201501dd2d7a1e80c799ffef412c97f659/image%201.png)

Программеру можно дать задание программера, и можно дать задание сотрудника (более общий тип)

В то же время программеру нельзя дать задание фронтендера, ведь программер может быть и бэком, а он не умеет делать таски фронта