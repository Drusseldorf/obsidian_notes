# Глава 5. Построители классов данных

### Введение в Data Class Builders

Data-классы в Python — это классы, которые в основном предназначены для хранения данных и минимальной логики. Python предоставляет несколько инструментов для создания таких классов:

1. **collections.namedtuple** — с версии Python 2.6, создает подклассы tuple с именованными полями.
2. **typing.NamedTuple** — с версии Python 3.5, аналог namedtuple, но с поддержкой аннотаций типов.
3. **dataclasses.dataclass** — с версии Python 3.7, декоратор для создания классов с более широкими возможностями и настройками.

### Примеры классов для хранения координат

```python
from collections import namedtuple
Coordinate = namedtuple('Coordinate', 'lat lon')
moscow = Coordinate(55.76, 37.62)
print(moscow)  # Coordinate(lat=55.76, lon=37.62)
```

### Ключевые отличия подходов:

- **dataclass** по умолчанию создает изменяемые экземпляры, но с опцией `frozen=True` можно сделать их неизменяемыми.
- **namedtuple и NamedTuple** создают неизменяемые экземпляры (immutable).
- Все они автоматически генерируют такие методы как `__init__`, `__repr__`, `__eq__`.

### Ключевые функции и методы:

- **Конвертация в dict**: `._asdict()` у namedtuple и `dataclasses.asdict()` для dataclass.
- **Доступ к полям**: через атрибуты `_fields` и `_field_defaults` для namedtuple и функцию `dataclasses.fields` для dataclass.
- **Создание нового экземпляра с изменениями**: через `_replace` для namedtuple и `dataclasses.replace()` для dataclass.

### Пример с dataclass:

```python
from dataclasses import dataclass

@dataclass(frozen=True)
class Coordinate:
    lat: float
    lon: float

moscow = Coordinate(55.76, 37.62)
print(moscow)  # Coordinate(lat=55.76, lon=37.62)
```

### Особенности каждого подхода:

1. **namedtuple**:
    - Легко создавать подклассы кортежей с именованными полями.
    - Поля неизменяемы.
    - Используется для простых структур данных.
2. **NamedTuple**:
    - Добавляет поддержку аннотаций типов.
    - Полезно, когда требуется явное указание типов.
3. **dataclass**:
    - Поддержка изменяемых и неизменяемых классов.
    - Позволяет добавлять логику через методы, более гибок в настройках.
    - Возможность настройки через параметры декоратора (например, `frozen=True` для неизменяемых объектов).

### Параметры для dataclass:

- **init**: автоматически создает метод `__init__`.
- **repr**: создает метод `__repr__`.
- **eq**: создает метод `__eq__`.
- **frozen**: делает экземпляры неизменяемыми.
- **default_factory**: используется для создания значения по умолчанию для изменяемых типов данных (например, списков).

Пример использования `default_factory`:

```python
from dataclasses import dataclass, field

@dataclass
class ClubMember:
    name: str
    guests: list = field(default_factory=list)
```

### Атрибуты класса и объекта в `dataclass`

```bash
>>> from dataclasses import dataclass
>>> @dataclass
... class SomeData:
...     a: int # это атрибут объекта, у класса его нет
...     b: float = 1.1 # можно обращаться по классу, это его атрибут
...     c = "spam"  # можно обращаться по классу, это его атрибут
...
>>> SomeData.a  # это атрибут объекта, у класса его нет
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AttributeError: type object 'SomeData' has no attribute 'a'
>>> SomeData.b  # можно обращаться по классу, это его атрибут
1.1
>>> SomeData.c  # можно обращаться по классу, это его атрибут
'spam'
>>> some_1 = SomeData(10)
>>> some_1
SomeData(a=10, b=1.1) # b, c - это теперь атрибуты объекта, свои
>>> some_1.b = 2.5
>>> some_1
SomeData(a=10, b=2.5) # поменялся атрибут b но только у объекта
>>> SomeData.b # тут все еще атрибут b класса, 1.1 равен как и при написании класса
1.1
>>> some_1.c
'spam'
>>> some_1.c = "new!"
>>> some_1.c
'new!'
>>> SomeData.c
'spam'

НО ВСЕ МЕНЯЕТСЯ ЕСЛИ НЕ ИСПОЛЬЗОВАЛСЯ ДАТА КЛАСС?

>>> class SomeClass:
...     a = 10
...
>>> SomeClass.a
10
>>> some_2 = SomeClass
>>> some_2.a
10
>>> some_2.a = 1111
>>> SomeClass.a  # Изменился атрибут класса через вызов его через экземпляр
1111
```

### Data Class как признак "Code Smell"

Data-классы могут быть признаком плохого проектирования, если они используются только для хранения данных, без логики. По идее объектно-ориентированного программирования, данные и функции, работающие с ними, должны находиться в одном классе.

### Заключение

Data-классы полезны для упрощения кода, особенно когда требуется много однотипных классов для хранения данных. Однако важно не злоупотреблять ими, оставляя логику внутри других классов, чтобы избежать плохого дизайна программы.

## Доп информация из разбора главы Алексеем

Важная мысль из "Чистого кода" Мартина о разделении понятий структуры данных и объектов. Ключевая идея заключается в том, что необходимо понимать разницу между структурами данных и объектами, и избегать смешения их реализации в одном классе. 
Это значит, что структуры данных должны просто хранить информацию, в то время как объекты должны включать поведение (методы). 
Таким образом, соблюдается принцип "чистого кода", где логика и данные разделены и не переплетаются в одном классе, что способствует лучшей поддерживаемости и пониманию кода.

- **Структуры данных** раскрывают свои атрибуты, но не имеют методов, которые могли бы манипулировать этими данными. Это означает, что данные являются открытыми и управляются внешними функциями или классами.
- **Объекты**, наоборот, скрывают свои данные, предоставляя доступ к ним только через методы. Объекты применяют абстракции для работы с данными, предоставляя осмысленные способы взаимодействия с ними.

акцентируется внимание на важном различии между структурами и объектами, особенно в контексте геттеров и сеттеров:

- **Геттеры и сеттеры**: Если атрибуты экземпляра делаются приватными, а для доступа к ним используются только геттеры и сеттеры — это все еще структура данных, а не объект. Такие методы не добавляют реальной логики для работы с данными, а лишь механически предоставляют доступ к ним, что не является настоящей абстракцией.
- **Абстракция**: Истинная абстракция скрывает реализацию, делая несущественные детали недоступными для внешнего кода, и позволяет пользователю работать на более высоком уровне, не вдаваясь в подробности.
- **Разработка абстракции**: Для создания хорошей абстракции нужно продумать, как скрыть детали и предоставить осмысленные методы для работы с данными.

Таким образом, абстракция требует осмысленного подхода к созданию методов, которые не просто предоставляют доступ к данным, но и инкапсулируют их, защищая от прямого вмешательства.

Подчеркивается, что **структуры данных** могут быть приемлемы в некоторых случаях. Например, их можно использовать для передачи неизменяемых данных между слоями приложения. В качестве примера приводится **dataclass с параметром frozen=True**, который делает экземпляры класса неизменяемыми. Также важно, что такие структуры не должны содержать бизнес-логику — их цель состоит исключительно в переносе данных.

Это подчеркивает важность использования структур данных только в тех ситуациях, когда они действительно оправданы, например, для передачи статической информации.

Обсуждается проблема с шаблоном Active Record:

- **Active Record** — ПЛОХО, когда структура данных совмещается с объектом, содержащим бизнес-логику, что считается плохой практикой. **Active Record** должен оставаться просто структурой данных (ORM) для отображения моделей (Записи из таблиц БД)
- Django ORM использует Active Record, и потому **не следует писать бизнес-логику в Django-моделях**, так как они в основном являются структурами данных. Модели предназначены для работы с данными, а не для выполнения бизнес-логики.
- Лучше **вынести бизнес-логику в отдельный слой**, который можно назвать "сервисами" или как угодно по предпочтению. Это помогает поддерживать разделение ответственности и улучшает читаемость и сопровождение кода.