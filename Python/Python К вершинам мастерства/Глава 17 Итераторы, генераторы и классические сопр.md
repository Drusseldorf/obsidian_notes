# Глава 17. Итераторы, генераторы и классические сопрограммы

### **1. Введение**

### **Что это такое**

Итерация — основа обработки данных. В Python она встроена на уровне языка через концепции итераторов и итерабельных объектов. Глава показывает, как паттерн итератор реализован в Python, и как использовать генераторы для более лаконичного и эффективного кода.

### **Тонкости**

- Повторяющиеся шаблоны в коде — сигнал того, что абстракция недостаточно сильна.
- Все стандартные коллекции Python поддерживают итерацию, что позволяет использовать конструкции `for`, списковые включения и т.д.

### **Советы \ мысли автора**

- Избегайте ручного создания итераторов, используйте встроенные механизмы Python.
- Если данные слишком велики для памяти, используйте ленивую загрузку через итераторы.

---

### **2. Итераторы в Python**

### **Что это такое**

Итератор — объект, который поддерживает методы `__iter__` (возвращает сам итератор) и `__next__` (возвращает следующий элемент или вызывает `StopIteration`, если элементов больше нет).

### **Пример**

```python
class MyIterator:
    def __init__(self, data):
        self.data = data
        self.index = 0

    def __iter__(self):
        return self

    def __next__(self):
        if self.index >= len(self.data):
            raise StopIteration
        item = self.data[self.index]
        self.index += 1
        return item

it = MyIterator([1, 2, 3])
for item in it:
    print(item)  # Вывод: 1, 2, 3
```

### **Тонкости**

- Итераторы не могут быть сброшены. Если нужно повторное использование, создайте новый итератор.
- Итератор сам по себе является итерабельным, так как `__iter__` возвращает `self`.

### **Советы \ мысли автора**

- Используйте итераторы, если требуется последовательное чтение элементов из больших коллекций или потоков данных.

---

### **3. Итерабельные объекты**

### **Что это такое**

Итерабельный объект — это любой объект, у которого есть метод `__iter__`, возвращающий итератор, или метод `__getitem__`, поддерживающий индексацию с нуля.

### **Пример**

```python
class Sentence:
    def __init__(self, text):
        self.words = text.split()

    def __getitem__(self, index):
        return self.words[index]

s = Sentence("Python is awesome")
print(list(s))  # ['Python', 'is', 'awesome']
```

### **Тонкости**

- Python автоматически вызывает `iter()` на объекте для итерации.
- Если объект не поддерживает `__iter__`, но имеет `__getitem__`, Python пытается использовать индексы до получения `IndexError`.

### **Советы \ мысли автора**

- Реализация `__iter__` предпочтительнее `__getitem__`, так как последняя используется для обратной совместимости и может быть удалена в будущем.

---

### **4. Генераторы**

### **Что это такое**

Генератор — это специальный вид итераторов, создаваемый функцией с использованием ключевого слова `yield`.

### **Пример**

```python
def my_generator():
    yield 1
    yield 2
    yield 3

g = my_generator()
print(next(g))  # 1
print(list(g))  # [2, 3]
```

### **Тонкости**

- Вызов функции-генератора возвращает объект генератора, а не выполняет код внутри функции.
- Генераторы лениво вычисляют значения, что позволяет экономить память.

### **Советы \ мысли автора**

- Используйте генераторы для обработки больших потоков данных, когда не нужно хранить все элементы в памяти.

---

### **5. Ленивые итерации**

### **Что это такое**

Ленивая итерация — подход, при котором значения вычисляются по запросу, а не заранее. Это экономит память и уменьшает нагрузку на CPU.

### **Пример**

Использование `re.finditer` вместо `re.findall`:

```python
import re

def lazy_words(text):
    pattern = re.compile(r'\w+')
    for match in pattern.finditer(text):
        yield match.group()

text = "Lazy iteration is cool"
print(list(lazy_words(text)))  # ['Lazy', 'iteration', 'is', 'cool']
```

### **Тонкости**

- Генераторы возвращают значения по одному, а функции вроде `finditer` позволяют обходить текст, не создавая полных списков.

### **Советы \ мысли автора**

- Ленивые итераторы подходят для работы с большими текстами или данными, которые нельзя полностью загрузить в память.

---

### **6. Генераторные выражения**

### **Что это такое**

Генераторное выражение — это компактный синтаксис для создания генераторов, аналогичный списковым включениям.

### **Пример**

```python
squares = (x**2 for x in range(10))
print(list(squares))  # [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]
```

### **Тонкости**

- Генераторные выражения используют меньше памяти, так как элементы не хранятся в виде списка.
- Если выражение слишком длинное, лучше использовать функцию-генератор для читаемости.

### **Советы \ мысли автора**

- Используйте генераторные выражения для простых и коротких итераторов.

---

### **7. Итераторы против Генераторов**

### **Что это такое**

- Итераторы — это общий термин для объектов с методом `__next__`.
- Генераторы — это итераторы, созданные с использованием `yield`.

### **Пример**

```python
def gen():
    yield 1
    yield 2

print(isinstance(gen(), iter))  # True
```

### **Тонкости**

- Генераторы автоматически реализуют протокол итерации.
- Генераторы экономят код и упрощают управление состоянием.

### **Советы \ мысли автора**

- Для большинства задач итерации используйте генераторы, так как они проще и эффективнее.

### **1. Подгенераторы с `yield from`**

### **Что это такое**

`yield from` — это синтаксис, введённый в Python 3.3, позволяющий делегировать работу другому генератору (подгенератору).

### **Пример**

```python
def sub_gen():
    yield 1.1
    yield 1.2

def gen():
    yield 1
    yield from sub_gen()
    yield 2

for x in gen():
    print(x)
# Результат:
# 1
# 1.1
# 1.2
# 2
```

### **Тонкости**

- `yield from` передаёт управление подгенератору до тех пор, пока тот не завершит работу.
- Значения из подгенератора возвращаются напрямую, минуя основной генератор.
- После завершения подгенератора основной генератор продолжает работу.

### **Советы**

- Используйте `yield from` для упрощения кода, где требуется делегирование генерации данных.

---

### **2. Реализация `chain` через `yield from`**

### **Что это такое**

Функция `itertools.chain` объединяет несколько итераторов, проходя их последовательно.

### **Пример с `yield from`**

```python
def chain(*iterables):
    for iterable in iterables:
        yield from iterable

list(chain('ABC', range(3)))
# ['A', 'B', 'C', 0, 1, 2]
```

### **Тонкости**

- `yield from` упрощает реализацию вложенных циклов, делая код чище и понятнее.
- Результат аналогичен реализации через вложенные `for`.

---

### **3. Обход дерева с помощью `yield from`**

### **Что это такое**

С помощью `yield from` можно обойти дерево в глубину, проходя все узлы на каждом уровне.

### **Пример**

```python
def tree(cls, level=0):
    yield cls.__name__, level
    for sub_cls in cls.__subclasses__():
        yield from tree(sub_cls, level + 1)

def display(cls):
    for name, level in tree(cls):
        print(' ' * 4 * level + name)

display(BaseException)
# BaseException
#     Exception
#         TypeError
#         ...
```

### **Тонкости**

- Рекурсия с `yield from` позволяет обойти дерево любой глубины.
- Уровень иерархии передаётся через дополнительный аргумент.

### **Советы**

- Используйте `yield from`, чтобы избежать сложных вложенных циклов в рекурсивных функциях.

---

### **4. Классические корутины**

### **Что это такое**

Классические корутины — это генераторы, которые могут как возвращать значения, так и принимать их через `.send()`.

### **Пример: вычисление среднего**

```python
def averager():
    total = 0.0
    count = 0
    while True:
        term = yield total / count if count else 0.0
        total += term
        count += 1

coro = averager()
next(coro)       # Инициализация
print(coro.send(10))  # 10.0
print(coro.send(20))  # 15.0
print(coro.send(30))  # 20.0
```

### **Тонкости**

- Корутину нужно "подготовить" с помощью `next()` или `.send(None)`.
- Локальные переменные сохраняются между вызовами, заменяя необходимость использования класса.

### **Советы**

- Используйте корутины для обработки последовательных данных и сохранения контекста между вызовами.

---

### **5. Возврат значений из корутин**

### **Что это такое**

С помощью `return` корутина может возвращать значение при завершении.

### **Пример**

```python
def averager():
    total = 0.0
    count = 0
    while True:
        term = yield
        if term is None:
            break
        total += term
        count += 1
    return total / count

coro = averager()
next(coro)
coro.send(10)
coro.send(20)
try:
    coro.send(None)
except StopIteration as exc:
    result = exc.value
    print(result)  # 15.0

```

### **Тонкости**

- Возврат значения происходит через исключение `StopIteration`.
- Для получения результата используйте `yield from` в вызывающем генераторе.

---

### **6. Типизация генераторов**

### **Что это такое**

Генераторы могут быть типизированы с использованием `Generator[YieldType, SendType, ReturnType]`.

### **Пример**

```python
from typing import Generator

def averager() -> Generator[None, float, float]:
    total = 0.0
    count = 0
    while True:
        term = yield
        if term is None:
            break
        total += term
        count += 1
    return total / count
```

### **Тонкости**

- `YieldType` — тип значений, которые возвращает `yield`.
- `SendType` — тип значений, которые принимает `.send()`.
- `ReturnType` — тип значения, возвращаемого через `return`.

### **Советы**

- Используйте типизацию для ясности API корутин и генераторов.

---

### **Итоги**

- `yield from` упрощает делегирование генерации данных, улучшая читаемость кода.
- Классические корутины мощны, но требуют внимательного управления `.send()` и `return`.
- Типизация генераторов помогает создавать надёжный и документированный код.

![image.png](%D0%93%D0%BB%D0%B0%D0%B2%D0%B0%2017%20%D0%98%D1%82%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B,%20%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%8B%20%D0%B8%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5%20%D1%81%D0%BE%D0%BF%D1%80%201561dd2d7a1e80d9bf7dc4a7aa51c5fc/image.png)