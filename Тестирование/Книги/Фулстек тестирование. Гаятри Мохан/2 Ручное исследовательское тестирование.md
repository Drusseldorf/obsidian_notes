### 1. **Название и ключевой посыл**

- **Название главы**: «Ручное исследовательское тестирование»
- **Главная идея**: Тестирование приложения через призму «исследования» и аналитического мышления. Искать скрытые сценарии использования, не описанные явно в требованиях, находить неожиданные ошибки и расширять понимание приложения с точки зрения конечного пользователя.

---

### 2. **Отличие от обычного ручного тестирования**

- **Обычное ручное тестирование**:
    - Проверка заранее составленных сценариев (чек-лист, требования).
    - Не всегда требует глубокого анализа.
- **Исследовательское тестирование**:
    - Выход за пределы документации, «вольное» исследование поведения приложения.
    - Активное размышление о логике, интеграциях, поведении «в полях» (различные сбои, необычные входные данные).
    - Объединяет **три точки зрения**: бизнес-требования, техническая реализация и перспективу конечного пользователя.

---

### 3. **Важность и задачи**

- **Почему это нужно**:
    - Выявление сценариев, о которых не подозревали ни аналитики, ни разработчики.
    - Поиск интеграционных проблем, пропусков в цепочках действий и краевых случаев.
    - Раннее обнаружение и коррекция ошибок до выхода продукта к конечным пользователям.
- **Главная цель**: Сделать так, чтобы реальное использование приложения было **полноценно проверено**, включая нетипичные ситуации и потенциальные сбои.

---

### 4. **Подходы к исследовательскому тестированию**

(инструменты мышления, которые помогают структурировать проверки)

1. **Разделение на классы эквивалентности**
    
    - Разделяем входные данные на группы, которые обрабатываются одинаково.
    - Пример: если поле принимает число от 0 до 15 000, можно выделить несколько диапазонов (0–5000, 5001–15000 и т. д.) и проверять по одному значению из каждого диапазона.
2. **Анализ граничных значений**
    
    - Проверка крайних точек диапазонов (5000, 5001, 15 000, 15 001 и т. д.).
    - Часто именно на границах случается некорректная логика.
3. **Диаграмма переходов и состояний**
    
    - Отображаем приложение как набор состояний и переходов между ними (например, страница входа после ввода неправильного пароля несколько раз).
    - Помогает понять, сколько тестовых сценариев нужно для полного охвата.
4. **Таблица решений**
    
    - Удобна, когда несколько условий (логика «И», «ИЛИ»).
    - Пример: сценарий входа (адрес электронной почты + пароль). Чёткое перечисление всех комбинаций: «оба правильные», «оба неправильные», «одно правильное, другое нет» и т. д.
5. **Диаграмма причинно-следственных связей**
    
    - Показывает зависимости (причины) и результаты (следствия).
    - Можно потом преобразовать в таблицу решений.
6. **Попарное тестирование (pairwise)**
    
    - Для независимых переменных: выбираем пары значений, чтобы не дублировать проверки.
    - Сильно сокращает общее количество тестовых сценариев, когда параметров много.
7. **Выборка (sampling)**
    
    - Актуальна при больших массивах данных. Выбираем случайные записи или записи по критериям (возраст, роль, статус и т. д.), чтобы покрыть максимально репрезентативный набор.
8. **Метод угадывания ошибок**
    
    - Используем предыдущий опыт, логику и интуицию, зная «типичные» места, где возникают проблемы (например, граничные условия, обработка кодов ошибок, и т. д.).

---

### 5. **Четыре основных направления исследования функциональности**

1. **Функциональные пользовательские сценарии**
    
    - Позитивные сценарии: проверить, работают ли основные пути (например, оформление заказа).
    - Модификации сценария: разные способы оплаты, несколько товаров в корзине и т. д.
2. **Повторяющиеся сценарии**
    
    - Проверять, как система ведёт себя, если пользователь повторяет действия: повторно вводит товары, несколько раз нажимает кнопку «добавить» и т. д.
3. **Многопользовательские сценарии**
    
    - Действия разных пользователей одновременно (два человека покупают последний товар).
    - Проверять, нет ли коллизий или конфликтов при параллельном использовании.
4. **Обработка сбоев и ошибок**
    
    - Проверять отклики приложения на сетевые сбои, недоступность сервисов, отрицательные/ошибочные вводы.
    - Текст ошибок должен быть вразумительным, подсказывать пользователю решение.
5. **(Дополнительно) Внешний вид интерфейса**
    
    - Проверка корректности отображения полей, длины надписей, изображений и т. д.
    - См. главу 6 для подробного визуального тестирования.

---

### 6. **Межфункциональные аспекты**

- **Безопасность** (SQL-инъекции, защита данных и т. д.)
- **Конфиденциальность** (хранение личных данных и соблюдение соглашений)
- **Аутентификация/авторизация** (двухфакторная, блокировка при ошибках, ролевой доступ)
- **Производительность и масштабируемость** (некоторые команды проверяют это на поздних стадиях, но ранние эксперименты тоже полезны)

_(Подробнее о нефункциональных аспектах и межфункциональных требованиях — в дальнейших главах.)_

---

### 7. **Стратегия ручного исследовательского тестирования**

(Как организовать процесс)

6. **Изучить приложение**
    
    - Персона пользователя, предметная область, приоритеты бизнеса, инфраструктура/конфигурация, общая архитектура.
    - Чем лучше мы понимаем контекст, тем эффективнее тестирование.
7. **Разбить тест на «части»**
    
    - Делать блоками: фокус на конкретной функции, сценарии, аспекте (например, тестируем только «создание заказа», потом — «оплата»).
8. **Применять восемь подходов (из пункта 4)**
    
    - Использовать методы выбора тестовых данных, визуализации сценариев, чтобы осмысленно искать баги.
9. **Регулярное повторение**
    
    - Проверять на этапе «dev-box» (быстрая проверка у разработчика), после реализации, перед релизом и т. д.
    - Постоянно расширять покрытие, возвращаться к уже протестированному, если появляются новые факторы.

---

### 8. **Практика и инструменты**

#### 8.1. Тестирование API

- **Почему важно**: API часто являются «отдельным продуктом»; бизнес-логика и интеграции завязаны на них.
- **Что тестировать**: форматы запросов/ответов (контракты), коды ошибок, права доступа и авторизацию, версии API и обратную совместимость.
- **Инструменты**:
    1. **Postman**
        - Визуальный интерфейс для отправки запросов (GET, POST, PUT, DELETE).
        - Позволяет проверять параметры, тело запроса, заголовки и коды ответов.
        - Удобен для аутентификации и просмотра времени отклика.
    2. **WireMock**
        - Создание «заглушек» (stubs) для имитации сервисов, которых пока нет или временно недоступны.
        - Полезно для исследовательского тестирования негативных сценариев (например, ответ 401, 500 и т. д.).

#### 8.2. Тестирование веб-интерфейса

- **Основные инструменты**:
    1. **Разные браузеры**
        - Chrome, Safari, Edge, Firefox (покрывают 85–90% аудитории).
        - Можно использовать облачные платформы (BrowserStack, Sauce Labs) для проверки старых версий IE и т. д.
    2. **Bug Magnet** (плагин для Chrome/Firefox)
        - Готовые наборы «крайних» значений (длинные строки, спецсимволы, unicode и т. д.), чтобы быстро заполнить поля ввода.
        - Экономит время и помогает не пропустить типичные краевые случаи.
    3. **Chrome DevTools**
        - Консоль (просмотр ошибок JS/сетевых ошибок).
        - Вкладка Network (отслеживание запросов, заголовков, время отклика).
        - Эмуляция низкой скорости/отключённой сети; блокировка URL.
        - Работа с cookie, кэшем, локальным хранилищем.

---

### 9. **Гигиена тестовой среды**

- **Выделенная тестовая среда**: Не мешать другим командам исследовать, менять конфигурации и «ломать» сервисы.
- **Управление развертываниями**: Лучше вручную разворачивать новую версию, чтобы сохранить гибкость изменения конфигураций.
- **Гигиена тестовых данных**:
    - Сбрасывать/обновлять БД, когда начинаем тест новой функции.
    - Избегать старых данных, которые могут «замусорить» результаты.
- **Доступ к логам и настройкам**: Тестировщики должны иметь права видеть логи, менять конфигурации, моделировать сбои, иначе исследования затруднены.
- **Интеграция сторонних сервисов**: Либо использовать заглушки (WireMock), либо иметь тестовые аккаунты в реальных сервисах.

---

### 10. **Ключевые выводы**

10. **Исследовательское тестирование** = глубина понимания + аналитика + поиск скрытых сценариев.
11. Отличается от классического ручного: нет жёсткого чек-листа, тестировщик мыслит и ищет неожиданное.
12. **Стратегия**: сочетание структуры (подходы, методологии) и гибкости (постоянные корректировки в ходе обнаружения новых идей).
13. **Инструменты** (Postman, WireMock, Chrome DevTools, Bug Magnet) повышают эффективность поиска ошибок и экономят время.
14. **Поддержка тестовой среды** (развертывания, данные, конфигурации) — критически важна для успеха исследовательского тестирования.

---

### 11. **Итоговое замечание автора**

> «Ручное исследовательское тестирование — это искусство, требующее как дисциплины, так и творческого подхода. Правильное понимание приложения и умение «ставить под сомнение всё» — ключ к тому, чтобы находить важные баги и улучшать общее качество продукта.»