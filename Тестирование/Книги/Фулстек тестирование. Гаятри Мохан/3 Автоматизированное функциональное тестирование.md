
### 1. Общая идея главы

1. Автоматизированное тестирование снимает с команды рутинную работу и позволяет быстрее получать обратную связь о качестве приложения.
2. Важно использовать автоматизацию **вместе** с ручным исследовательским тестированием:
    - Ручное исследовательское выявляет новые идеи и тестовые сценарии.
    - Автоматизация «закрепляет» эти сценарии для быстрой проверки регресса в будущем.
3. Не стоит сосредотачиваться только на тестах UI — нужно применять тесты **на разных уровнях** приложения: модульном, интеграционном, сервисном, контрактном, а также UI/сквозные.
4. Оптимальная структура для экономии времени и обеспечения стабильности — «пирамида тестирования».

---

### 2. Типы тестов на микро- и макроуровне

**Микроуровень**

- **Модульные тесты**: проверяют отдельные методы/классы. Это самый быстрый и простой для сопровождения тип тестов, обычно пишут их разработчики.
- **Интеграционные тесты**: проверяют «стыки» между компонентами (сервис-сервис, сервис-БД).
- **Контрактные тесты**: следят за тем, чтобы форматы данных и структура API (между «потребителем» и «поставщиком») оставались согласованными.

**Макроуровень**

- **Сервисные тесты**: тестируют API в целом (проверка REST/HTTP-запросов и ответов, статус-кодов, бизнес-логики без UI).
- **Функциональные тесты UI**: имитируют действия пользователя в браузере. Крайне полезны, но их не должно быть слишком много (они «хрупкие» и более медленные).
- **Сквозные тесты (end-to-end)**: проверяют реальный бизнес-процесс с участием множества систем, например, оплату товара, взаимодействие со сторонними сервисами и т. д. Очень ресурсозатратны, поэтому пишутся только на критически важные сценарии.

---

### 3. Стратегия автоматизированного функционального тестирования

1. **Пирамида тестирования (Майк Кон)**: много модульных (и интеграционных) тестов внизу, меньше — на уровне API/сервисов, и ещё меньше на уровне UI.
2. Цель пирамиды — **быстрая** обратная связь и относительно **простое обслуживание** тестов.
3. Избегать «рожка мороженого», когда тестов UI слишком много и очень мало модульных. А также «слоёного пирога», когда те же проверки дублируются на всех уровнях.
4. Следить за охватом (coverage) и вовремя добавлять тесты для всех функциональных сценариев. Идеально, когда история разработки считается «готовой», только если все её аспекты покрыты автотестами.

---

### 4. Примеры кода на Python

Ниже — адаптированные примеры кода на Python, отражающие концепции, изначально продемонстрированные для Java.

#### 4.1. Автоматизация UI-тестов с помощью Selenium (Python)

**Структура проекта (пример):**

```
my_project/
  pages/
    login_page.py
    home_page.py
  tests/
    test_login.py
  requirements.txt
```

(В `requirements.txt` можем указать `selenium`, `pytest` и т. д.)

**login_page.py** (Page Object Model)

```
from selenium.webdriver.common.by import By

class LoginPage:
    def __init__(self, driver):
        self.driver = driver
        self.email_field = (By.ID, "user_email")
        self.password_field = (By.ID, "user_password")
        self.submit_button = (By.ID, "login_submit")

    def login(self, email, password):
        self.driver.find_element(*self.email_field).send_keys(email)
        self.driver.find_element(*self.password_field).send_keys(password)
        self.driver.find_element(*self.submit_button).click()
```

**home_page.py**

```
class HomePage:
    def __init__(self, driver):
        self.driver = driver

    def get_title(self):
        return self.driver.title
```

**test_login.py** (с использованием Pytest)

```
import pytest
from selenium import webdriver
from pages.login_page import LoginPage
from pages.home_page import HomePage

@pytest.fixture
def driver():
    driver = webdriver.Chrome()
    driver.implicitly_wait(10)
    yield driver
    driver.quit()

def test_successful_login(driver):
    driver.get("http://example.com/login")
    login_page = LoginPage(driver)
    login_page.login("example@gmail.com", "Admin123")

    home_page = HomePage(driver)
    assert "Home" in home_page.get_title()
```

---

#### 4.2. Тестирование API (Requests + Pytest)

**Пример**: Проверяем GET и POST запрос к `/items`.

```
import requests

BASE_URL = "http://localhost:1000"

def test_get_items():
    resp = requests.get(f"{BASE_URL}/items")
    assert resp.status_code == 200
    data = resp.json()
    assert isinstance(data, list)

def test_post_item():
    item = {
        "sku": "98765490",
        "color": "Green",
        "size":  "M"
    }
    resp = requests.post(f"{BASE_URL}/items", json=item)
    assert resp.status_code == 201
```

---

#### 4.3. Модульные тесты (pytest, unittest)

**Класс CustomerManagement**:

```
class CustomerManagement:
    def __init__(self):
        self.customers = []

    def get_customers(self):
        return self.customers

    def add_customer(self, first_name, last_name):
        if not first_name:
            raise ValueError("First name is required")
        self.customers.append((first_name, last_name))
```

**Модульные тесты**:

```
import pytest
from app.customer_management import CustomerManagement

def test_get_customers_empty():
    cm = CustomerManagement()
    assert cm.get_customers() == []

def test_add_customer_success():
    cm = CustomerManagement()
    cm.add_customer("John", "Doe")
    assert len(cm.get_customers()) == 1

def test_add_customer_no_first_name():
    cm = CustomerManagement()
    with pytest.raises(ValueError):
        cm.add_customer("", "Doe")
```

---

### 5. Cypress: подробности

**Cypress** — это фреймворк для E2E/функциональных тестов в браузере, заточен под JavaScript, но очень удобен:

1. Автоматические ожидания (не нужны явные `wait()`).
2. Гибкая отладка: Cypress показывает шаги выполнения и скриншоты состояния DOM.
3. Возможность перехватывать запросы (`cy.intercept`) и подменять ответы, эмулируя ошибку сервера.
4. Гибкая конфигурация (запуск в Chrome/Firefox/Electron, запись видео, и т. д.).

**Пример теста**:

```
describe('Login Flow', () => {
  beforeEach(() => {
    cy.visit('http://example.com/login');
  });

  it('logs in with valid credentials', () => {
    cy.get('#user_email').type('example@gmail.com');
    cy.get('#user_password').type('Admin123');
    cy.get('button.submit').click();
    cy.title().should('include', 'Home');
  });
});
```

---

### 6. Дополнительные инструменты (Karate, Pact, AI/ML)

1. **Pact**: контрактное тестирование (consumer-driven). Удобно при микросервисах, где каждый сервис — «поставщик»/«потребитель» данных.
2. **Karate**: BDD-фреймворк для тестирования API, где сценарии пишутся на Gherkin, минимум кода.
3. **Инструменты на базе AI/ML** (Test.ai, Functionize, ReportPortal и др.):
    - Генерация тестов «по кликам» (запись сценария).
    - «Self-healing» тестов при изменении локаторов.
    - Автоматический анализ логов и распределение причин сбоев (проблемы в коде, среде, тестах).

---

### 7. Антипаттерны и охват тестами

**Антипаттерны**

- «Рожок мороженого»: очень много UI-тестов, мало модульных. Долго ждать результатов, тесты часто падают, регресс все равно проверяют вручную.
- «Слоёный пирог»: одинаковые проверки на всех уровнях. Повтор кода, избыточность тестов, сложность сопровождения.

**Процент охвата**

- Высокие цифры не гарантируют отсутствия ошибок. Важно смотреть, какие модули и сценарии покрыты.
- 100% охвата обычно недостижимо (или нецелесообразно), остаются ситуации/фичи, когда ручное тестирование дешевле или необходимее.
- В крупных проектах автоматически тесты становятся «живой документацией», упрощающей понимание кода для новых членов команды.

---

### 8. Ключевые выводы

1. **Автоматизация** даёт быструю обратную связь, помогает обнаруживать регресс и экономит время на рутинных проверках.
2. **Пирамида тестирования** — отличный ориентир, чтобы поддерживать баланс (много лёгких модульных тестов, меньше сервисных, ещё меньше UI и E2E).
3. **Код-база тестов** требует грамотной структуры (Page Object Model для UI, отдельные модули для сервисов, data objects при тестировании API и т. д.).
4. **Cypress** отличается удобством и скоростью при тестировании веб-интерфейсов, благодаря встроенной отладке и автоожиданиям.
5. **AI/ML-инструменты** помогают генерировать тесты, автоматически чинят «упавшие» локаторы, анализируют логи, что снижает ручные трудозатраты.
6. Надо избегать «рожка мороженого» (перегрузка на уровне UI-тестов) и «слоёного пирога» (дублирование проверок).
7. **Охват** тестами — лишь метрика; важно разумно распределять тесты и не забывать про нефункциональные сценарии (безопасность, производительность и пр. — в других главах).

Таким образом, автоматизированное функциональное тестирование — это системный подход к проверкам всех аспектов приложения (от отдельных методов до сквозных сценариев). При разумном планировании и грамотном распределении тестов по уровням разработка становится быстрее и качественнее, а команда получает надёжный инструмент для контроля над изменениями и регрессом.