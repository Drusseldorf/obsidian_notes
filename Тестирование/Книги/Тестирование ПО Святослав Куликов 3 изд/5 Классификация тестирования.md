# 5. Классификация тестирования

### Виды и направления тестирования

### 2.3.1. Упрощённая классификация тестирования

Тестирование можно классифицировать по следующим ключевым критериям:

1. **По запуску кода на исполнение:**
    - **Статическое тестирование**: без запуска кода.
    - **Динамическое тестирование**: с запуском кода.
2. **По доступу к коду и архитектуре приложения:**
    - **Метод белого ящика**: доступ к коду есть.
    - **Метод чёрного ящика**: доступа к коду нет.
    - **Метод серого ящика**: частичный доступ к коду.
3. **По степени автоматизации:**
    - **Ручное тестирование**: выполняется человеком.
    - **Автоматизированное тестирование**: выполняется инструментами.
4. **По уровню детализации приложения:**
    - **Модульное тестирование**: проверка отдельных частей приложения.
    - **Интеграционное тестирование**: проверка взаимодействия частей.
    - **Системное тестирование**: проверка приложения как единого целого.
5. **По степени важности функций:**
    - **Дымовое тестирование**: проверка критической функциональности.
    - **Тестирование критического пути**: проверка основных сценариев использования.
    - **Расширенное тестирование**: проверка всех остальных функций.
6. **По принципам работы с приложением:**
    - **Позитивное тестирование**: проверка корректного поведения.
    - **Негативное тестирование**: проверка поведения в некорректных ситуациях.

---

### 2.3.2. Подробная классификация тестирования

### 2.3.2.1. Классификация по запуску кода на исполнение

- **Статическое тестирование**:
    - Анализ документов, графических прототипов, кода, параметров среды.
    - Выполняется без запуска приложения.
- **Динамическое тестирование**:
    - Проверка поведения приложения в реальных условиях выполнения.

### 2.3.2.2. Классификация по доступу к коду и архитектуре приложения

- **Метод белого ящика**:
    - Доступ к внутренней структуре и коду приложения.
    - Используются техники анализа потока управления и данных.
- **Метод чёрного ящика**:
    - Нет доступа к внутренней структуре.
    - Основной источник информации — требования и спецификации.
- **Метод серого ящика**:
    - Комбинация методов белого и чёрного ящика.

### 2.3.2.3. Классификация по степени автоматизации

- **Ручное тестирование**:
    - Выполняется человеком без использования автоматизации.
- **Автоматизированное тестирование**:
    - Используются инструменты для выполнения тестов.

### 2.3.2.4. Классификация по уровню детализации приложения

- **Модульное тестирование**:
    - Проверка отдельных функций, классов или методов.
- **Интеграционное тестирование**:
    - Проверка взаимодействия между модулями.
- **Системное тестирование**:
    - Проверка всей системы целиком.

### 2.3.2.5. Классификация по степени важности тестируемых функций (Функциональное)

- **Дымовое тестирование**:
    - Проверка ключевой функциональности.
- **Тестирование критического пути**:
    - Проверка функциональности, наиболее часто используемой пользователями.
- **Расширенное тестирование**:
    - Проверка всей остальной заявленной функциональности. Включая и негативные кейсы.

### 2.3.2.6. Классификация по принципам работы с приложением

- **Позитивное тестирование**:
    - Проверка в условиях корректного использования.
- **Негативное тестирование**:
    - Проверка поведения приложения при некорректных действиях.

### 2.3.2.7. Классификация по природе приложения

- **Тестирование веб-приложений**:
    - Проверка совместимости, производительности, безопасности.
- **Тестирование мобильных приложений**:
    - Проверка совместимости с устройствами и оптимизации производительности.
- **Тестирование настольных приложений**:
    - Проверка функциональности в зависимости от архитектуры.

### 2.3.2.8. Классификация по фокусировке на уровне архитектуры

- **Тестирование уровня представления**:
    - Проверка пользовательского интерфейса.
- **Тестирование уровня бизнес-логики**:
    - Проверка реализации бизнес-правил.
- **Тестирование уровня данных**:
    - Проверка целостности данных и работы с базой данных.

### 2.3.2.9. Классификация по привлечению конечных пользователей

- **Альфа-тестирование**:
    - Выполняется внутри организации-разработчика.
- **Бета-тестирование**:
    - Выполняется реальными пользователями.
- **Гамма-тестирование**:
    - Финальная проверка перед выпуском.

### 2.3.2.10. Классификация по степени формализации

- **Тестирование на основе тест-кейсов**:
    - Формализованный подход с использованием заранее подготовленных тестов.
- **Исследовательское тестирование**:
    - Тестирование без заранее подготовленных тест-кейсов, по сценарию.
- **Свободное тестирование**:
    - Полностью интуитивное исследование приложения.

### 2.3.2.11. Классификация по целям и задачам

- **Функциональное тестирование**:
    - Проверка работы функциональных требований.
- **Нефункциональное тестирование**:
    - Проверка удобства использования, производительности, безопасности.
- **Регрессионное тестирование**:
    - Проверка исправленных ошибок.
- **Приёмочное тестирование**:
    - Проверка соответствия требованиям заказчика.

### 2.3.2.12. Классификация по моменту выполнения

- **Восходящее тестирование**:
    - Проверка от низкоуровневых компонентов к высокоуровневым.
- **Нисходящее тестирование**:
    - Проверка от высокоуровневых компонентов к низкоуровневым.
- **Гибридное тестирование**:
    - Смешанный подход для упрощения процесса.

---

## 1. Smoke-тестирование (Smoke Testing)

**Что это такое**

- Быстрое поверхностное тестирование сборки (билда) — проверка «жизнеспособности» приложения.
- Цель: понять, не «падает» ли приложение на самых базовых функциях.
- Часто запускается на каждой новой сборке перед более глубокими тестами.

**Пример**

- Запуск приложения без ошибок.
- Возможность залогиниться, открыть главное меню/стартовую страницу.
- Нет критических ошибок (крашей, «белого экрана» и пр.).

**Когда применяется**

- При любом новом релизе или свежем билдe, чтобы решить, есть ли смысл проводить дальнейшие тесты.
- Если смоук-тест «проваливается», сборку обычно возвращают на доработку.

**Объём**

- Минимальный набор тестов, охватывающих основные, ключевые (часто самые верхнеуровневые) функции приложения.

---

## 2. Sanity-тестирование (Sanity Testing)

**Что это такое**

- Короткий «здравый» чек (проверка разумности) на работоспособность конкретного функционала или небольшой области приложения.
- Цель: убедиться, что изменения (например, новый функционал или фикс бага) действительно работают как надо и не ломают ничего вокруг **в рамках этой области**.

**Пример**

- Если разработчики починили баг в форме регистрации, sanity-тест может включать быструю проверку полей (имя, e-mail, пароль), подтверждение регистрации, и минимальный обход связанного процесса.
- Не тестируются все остальные участки приложения — только то, что «починили» или «добавили».

**Когда применяется**

- После фикса конкретного дефекта (bug fix), добавления узкого функционала.
- Когда нужно быстро проверить, что заявленная функциональность действительно работает правильно, прежде чем отдавать продукт дальше на более масштабное тестирование.

**Объём**

- Уже более точечный, чем smoke, но не такой большой, как полный набор регрессионных тестов.
- Охватывает лишь «затронутую» область приложения.

---

## 3. Тестирование критического пути (Critical Path Testing)

**Что это такое**

- Проверка наиболее важного / критичного маршрута (flow) в приложении — то есть последовательности действий, без которой приложение не имеет смысла для пользователя или бизнеса.
- Цель: убедиться, что главные пользовательские сценарии (critical path) работают корректно в различных условиях.

**Пример**

- Интернет-магазин: выбор товара → добавление в корзину → оплата → подтверждение заказа.
- Банковское приложение: авторизация → просмотр баланса → перевод денег.
- Для соцсети: регистрация → логин → создание поста → лента новостей.

**Когда применяется**

- Стабильно на каждом релизе или после крупных изменений, чтобы гарантировать, что «главная цель» пользователя не сломалась.
- Может идти после smoke-тестов, если приложение в принципе запускается и доступны основные элементы.

**Объём**

- Более широкий и глубокий, чем smoke (там чаще всего «просто зашли на страницу оплаты»), но всё же сильно сфокусирован на главном сценарии (или нескольких таких сценариях).

---

## 4. «Расширенное» тестирование (Extended Testing)

Под «расширенным» могут понимать разные вещи (часто так называют более широкий охват, не ограниченный только критическим путём или базовыми проверками). В общем случае это:

1. **Расширенный регрессионный набор**:
    - Проверка широкого спектра функционала: не только критические пути, но и вспомогательные сценарии, угловые случаи, интеграции и т.д.
2. **Функциональное тестирование** во всём объёме (all features, все входные варианты, и т.п.).

**Пример**

- Для интернет-магазина: проверка различных способов оплаты (карта, PayPal, Apple Pay), разных типов товаров (физические, виртуальные, скидки, бонусные баллы и т. п.), разных ролей пользователей (гость, зарегистрированный пользователь, администратор).

**Когда применяется**

- В больших релизах, когда нужно убедиться, что приложение в целом стабильно во всех основных и второстепенных сценариях.
- Когда есть достаточное время и ресурсы на полный прогон тестов.

**Объём**

- Самый объёмный набор тестов, могущий включать и критические пути, и негативные сценарии, и тесты совместимости, и т.д.

---

## Ключевые Отличия

3. **Smoke** – очень **быстрая и «поверхностная»** проверка базовой работоспособности (своего рода «тест на дым»: если «дым идёт», значит что-то горит, билд негоден).
4. **Sanity** – **точечное** тестирование «заявленной» или «починенной» функции, проверка «здравости» изменений (не сломало ли это что-то важное вокруг).
5. **Критический путь (Critical Path)** – **набор тестов по главным пользовательским сценариям**. Убедиться, что базовые флоу, создающие ценность продукта, работают «от и до».
6. **«Расширенное» (Extended)** – **глубокий охват** приложения или модуля, включая вспомогательные сценарии, негативные проверки, разные комбинации вводов, большую регрессию.

---

### Где и когда использовать

- **Smoke**: при каждом новом билде, чтобы быстро понять, продолжаем ли тестирование.
- **Sanity**: когда правят конкретный баг или дорабатывают небольшую функциональность — проверить, что локальные изменения ок и можно идти дальше.
- **Критический путь**: стабильно на каждом релизе, чтобы не «уронить» базовый сценарий/бизнес-функционал.
- **Расширенное**: периодически (например, перед крупным релизом), когда необходимо максимальное покрытие и уверенность в качестве.

Таким образом, каждая из техник имеет свою цель, глубину и объём проверок. В идеале все они взаимно дополняют друг друга:

- **Smoke** даёт зелёный свет на «глубокие тесты».
- **Sanity** проверяет, что отдельные фиксы или фичи в порядке.
- **Critical path** обеспечивает ключевые бизнес-процессы.
- **Расширенное** тестирование даёт полную уверенность, что продукт в целом стабильный