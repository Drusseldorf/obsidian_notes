# CI/CD

## 1. Общие сведения о CI/CD

### Что такое CI/CD?

- **CI (Continuous Integration, непрерывная интеграция)** — это практика частого слияния (merge) кода от разных разработчиков в одну основную ветку (обычно main/master), с автоматическими проверками (тестами, сборкой), чтобы выявить проблемы на ранней стадии.
- **CD (Continuous Delivery/Deployment, непрерывная доставка/развертывание)** — это практики, позволяющие быстро и надёжно доставлять изменения (исправления, новые фичи) пользователям.
    - **Continuous Delivery** подразумевает, что изменения готовы к деплою (release) в любой момент, однако выпуск (release) может делаться вручную (по кнопке).
    - **Continuous Deployment** — это более продвинутая стадия, когда каждая успешная сборка автоматически деплоится в продакшен (при условии, что все проверки прошли успешно).

### Зачем нужен CI/CD?

1. **Сокращение времени отклика**: новые фичи и фиксы быстро попадают к пользователям.
2. **Минимизация риска**: автоматические проверки (юнит-тесты, интеграционные тесты, статический анализ кода) позволяют своевременно выявлять проблемы.
3. **Прозрачность процессов**: все участники команды (разработчики, тестировщики, DevOps-инженеры, менеджеры) видят текущее состояние сборки.
4. **Удобство автоматизации**: единая система сборки, тестирования и деплоя, меньше рутины.

---

## 2. Роли и задачи тестировщика в CI/CD

1. **Написание и поддержка тестов**: хоть обычно это задача QA-инженеров или autotest-инженеров, но **тестировщик** также может участвовать в формировании сценариев, тест-кейсов, определении критических путей.
2. **Контроль качества сборки**: проверять, все ли тесты подключены к пайплайну, корректно ли они отрабатывают, передаётся ли нужная информация о тестовых отчётах (artifacts, логи).
3. **Валидация окружений**: убедиться, что тестовое окружение (staging, QA) корректно отражает продакшен при прогоне тестов, и что в пайплайне не пропущены важные шаги (миграция БД, обновление конфигураций и пр.).
4. **Отслеживание и устранение регрессий**: CI/CD подразумевает, что тесты должны запускаться часто. Тестировщик может помочь в обнаружении и анализе результатов (например, что регулярный тест стал «падать» из-за конкретного изменения в коде).

---

## 3. Компоненты и этапы CI/CD-процесса

Большинство CI/CD-систем (Jenkins, GitLab CI, GitHub Actions, CircleCI, Bamboo и т.д.) работают по схожим принципам:

1. **Источник (trigger) запуска пайплайна**
    - Коммит (push) в Git-репозиторий.
    - Открытие/изменение Pull Request/Merge Request.
    - Запланированное расписание (cron).
    - Тег (release tag) в репозитории.
    - Событие из внешней системы (например, webhook).
2. **Сборка (build)**
    - Компиляция кода (для компилируемых языков).
    - Установка зависимостей (npm, Maven, Gradle, и т.п.).
    - Статический анализ кода (lint, sonar).
    - При необходимости – генерация документации.
3. **Тестирование (test)**
    - **Юнит-тесты** (Unit) — для проверки отдельных модулей кода.
    - **Интеграционные тесты** — для проверки взаимодействия между сервисами/модулями.
    - **Функциональные/API тесты** — для валидации бизнес-логики.
    - **UI-тесты** (при необходимости) — проверка пользовательского интерфейса.
    - **Performance/Security тесты** — запускаются реже (по требованию или по расписанию).
4. **Сбор артефактов (artifacts)**
    - Артефакты — это всё, что получается в результате сборки/тестов и может понадобиться на следующих этапах:
        - Скомпилированное приложение, дистрибутив (JAR-файл, Docker-образ, .zip и т.д.).
        - Отчёты о тестах (JUnit XML, Allure, HTML-отчёты).
        - Логи выполнения.
        - Сгенерированная документация (Swagger, Sphinx, и пр.).
    - Эти артефакты могут передаваться между стадиями внутри одного пайплайна или храниться во внешнем репозитории (артефакторий).
5. **Деплой (Deploy) / Доставка (Delivery)**
    - **Staging** — предварительная среда, максимально похожая на продакшен (production).
    - **Production** — реальная боевая среда, где пользователи получают обновления.
6. **Мониторинг и обратная связь (Feedback)**
    - Системы логирования и мониторинга (ELK, Grafana, Prometheus) для контроля стабильности.
    - Alerts и уведомления, если что-то пошло не так.

---

## 4. Взаимодействие тестировщика с артефактами

**Для тестировщика** важна прозрачность в том, какие именно артефакты (artifacts) получаются после каждого шага:

1. **Отчёты о тестах**
    - Формат Allure, JUnit XML, HTML-репорты.
    - Важно: чтобы в случае провала тестов мы могли быстро открыть логи, понять, почему они упали.
2. **Логи среды**
    - Логи контейнеров (Docker logs), логи системы.
    - Помогают расследовать сложные дефекты, особенно интеграционные.
3. **Скомпилированное приложение**
    - Тестировщик может забрать готовую сборку (jar, war, zip, Docker-образ) и развернуть локально или на тестовом стенде для дополнительной проверки.
4. **Конфигурационные файлы**
    - Параметры окружения, переменные среды.
    - Нужно следить, чтобы в различных средах (Dev, Staging, Prod) конфиги не конфликтовали и позволяли корректно запускать тесты.

---

## 5. Вопросы и ответы для собеседования

Ниже приведён список наиболее частых вопросов, которые могут задать на собеседовании по теме CI/CD, и примерные ответы, которые продемонстрируют понимание у тестировщика.

### Вопрос 1. Что такое непрерывная интеграция (CI) и для чего она нужна?

**Пример ответа**:

«Непрерывная интеграция (CI) — это практика, когда код от нескольких разработчиков часто (порой несколько раз в день) сливается в общую ветку, а автоматически запускаемые тесты и проверки помогают вовремя обнаружить баги и конфликтующие изменения. Это ускоряет цикл разработки и уменьшает риск больших поломок.»

### Вопрос 2. Чем отличается непрерывная доставка (Continuous Delivery) от непрерывного развертывания (Continuous Deployment)?

**Пример ответа**:

«При непрерывной доставке (Continuous Delivery) каждая успешная сборка **готова** к релизу, но выпуск (деплой в продакшен) может быть запущен вручную по решению команды/бизнеса.

Непрерывное развертывание (Continuous Deployment) автоматизирует этот процесс, и при прохождении всех тестов сборка автоматически уходит в боевую среду без ручного вмешательства.»

### Вопрос 3. Какие инструменты CI/CD знаете и чем они отличаются?

**Пример ответа**:

«Популярные инструменты — это Jenkins, GitLab CI, GitHub Actions, CircleCI, Bamboo, TeamCity.

- Jenkins — мощный и гибкий, но требует ручной конфигурации и администрирования.
- GitLab CI и GitHub Actions интегрированы с платформами GitLab/GitHub, упрощают настройку и предоставляют пайплайн «как код» (yaml-файлы).
- CircleCI, Bamboo, TeamCity также имеют свои особенности в плане конфигурации, плагинов, ценовых моделей.»

### Вопрос 4. Как тестировщик может влиять на настройку пайплайна?

**Пример ответа**:

«Тестировщик может предложить добавить дополнительные виды тестов (интеграционные, UI, нагрузочные), следить, чтобы репорты и логи сохранялись как артефакты, и чтобы при падении тестов сборка считалась неуспешной (fail the build). Также тестировщик может добавить шаги по проверке качества кода (SonarQube, линтер).»

### Вопрос 5. Что такое «артефакты» (artifacts) в контексте CI/CD?

**Пример ответа**:

«Артефакты — это результаты работы пайплайна: скомпилированные бинарники, отчёты тестирования, логи, документы. Они могут понадобиться на следующих стадиях пайплайна (например, для деплоя) или быть сохранены в артефактори для использования командой.»

### Вопрос 6. Расскажите, какие триггеры (источники запуска) для пайплайна CI/CD вы знаете?

**Пример ответа**:

1. «Push-коммит или пул-реквест в репозиторий (самый частый сценарий).
2. Запуск по расписанию (cron job), если нужно, например, прогонять регрессионные тесты ночью.
3. Webhook или внешнее событие, когда другая система даёт сигнал на запуск (например, после релиза библиотек).
4. Ручной запуск из UI (когда нужно прогнать пайплайн вне расписания или веток).»

### Вопрос 7. Как вы проверяете, что пайплайн (pipeline) работает корректно?

**Пример ответа**:

«Обычно проверяют логи: убедиться, что все стадии прошли (build, test, deploy), что нет упавших тестов, что все артефакты корректно сформировались и сохранились. Смотрят статус каждой задачи: если одна из них красная (failed), значит пайплайн остановился. Также важно проверить, что действительно задеплоилась нужная версия кода в нужное окружение.»

### Вопрос 8. Какие метрики (KPI) CI/CD вы знаете?

**Пример ответа**:

- «Lead Time (время от коммита до деплоя).
- Mean Time to Recover (MTTR) — среднее время восстановления при сбое.
- Частота релизов (Deployment Frequency).
- Code Coverage (покрытие тестами).
- Процент успешных сборок.
- Время выполнения сборки (Pipeline Duration).»

### Вопрос 9. Какие проблемы могут возникнуть при внедрении CI/CD?

**Пример ответа**:

- «Недостаток тестового покрытия (много ручного тестирования; сборка часто красная).
- Несогласованность между командами (Dev, QA, DevOps, PM) — нет чёткого понимания, кто за что отвечает.
- Медленный пайплайн (долго идёт сборка, тесты), что снижает эффективность быстрой интеграции.
- Проблемы с безопасностью (аккуратное хранение секретов, ключей в CI/CD).»

### Вопрос 10. Как вы организуете среду для тестирования перед продакшеном?

**Пример ответа**:

«Обычно настраивается отдельная среда (Staging/QA), где деплоится сборка из CI/CD до релиза в продакшен. Там гоняются автоматизированные UI-тесты, регрессионные тесты, иногда нагрузочные. Важно, чтобы эта среда максимально совпадала с продакшеном по конфигурации (БД, middleware, сетевые настройки).»

---

## 6. Дополнительные моменты для тестировщика

1. **Контролируйте важность тестов**:
    - Критические тесты (smoke-тесты) должны выполняться при каждом коммите (быстро).
    - Расширенные регрессионные тесты можно запустить реже или по расписанию.
2. **Будьте готовы анализировать отчёты**:
    - Если тесты падают, важно уметь читать логи, чтобы определить первопричину (defect in code, flaky tests, неправильное окружение и т.д.).
3. **Следите за размером и временем работы пайплайна**:
    - Если пайплайн идёт слишком долго, команда может реже коммитить → больше конфликтов → снижение эффективности CI/CD.
    - Возможно, часть тестов стоит вынести в параллельные задачи или в nightly-билды.
4. **Коммуникация**:
    - Тестировщик является связующим звеном между разработчиками, DevOps и менеджерами.
    - Важно своевременно уведомлять команду о сбоях в пайплайне, участвовать в «post-mortem» разборе проблем.