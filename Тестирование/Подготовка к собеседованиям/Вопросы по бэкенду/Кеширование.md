# Кеширование

## 1. Общие сведения о кешировании в HTTP

### Что такое кеширование?

**Кеширование** — это механизм сохранения (кэширования) ранее загруженного ресурса для более быстрой выдачи его при повторных запросах. Проще говоря, если ресурс уже однажды загружен, то браузер (или прокси-сервер) может не обращаться к исходному серверу повторно, а взять готовую копию из кеша.

**Преимущества**:

- Сокращение времени загрузки ресурсов, повышение отзывчивости веб-сайта или приложения.
- Уменьшение сетевого трафика.
- Снижение нагрузки на исходный (origin) сервер.

**Недостатки**:

- Если настройка сделана неправильно, можно получить устаревший контент.
- Сложнее управлять изменениями и обновлениями, особенно при «агрессивном» кешировании.

### Виды кешей

1. **Приватный (private) кеш** — это кеш, «принадлежащий» конкретному пользователю/устройству/браузеру.
    - Пример: кеш браузера.
    - Преимущество: не возникает коллизий между пользователями (каждый видит свою версию страниц, в том числе с учётными данными и т.д.).
    - Недостаток: не так эффективно экономит ресурсы, как общее кеширование.
2. **Общий (shared) кеш** — это кеш, которым могут пользоваться разные пользователи.
    - Пример: кеш на прокси-сервере внутри корпоративной сети или у интернет-провайдера.
    - Преимущество: популярные ресурсы скачиваются один раз и выдаются многим пользователям.
    - Недостаток: требуется аккуратно управлять тем, что действительно можно отдавать всем, а что является приватными данными.

---

## 2. Основные заголовки и механизмы управления кешированием

### Cache-Control

Наиболее важный заголовок для управления кешем. Возможные директивы:

1. **no-store**
    - Полное отключение кеширования: ничего не сохраняется ни на стороне клиента, ни на стороне прокси.
    - Пример: `Cache-Control: no-store`
2. **no-cache**
    - Ресурс можно хранить, но **перед использованием** кеш **обязан** проверить актуальность ресурса на сервере (re-validation).
    - Пример: `Cache-Control: no-cache`
3. **must-revalidate**
    - Кеш обязан проверять истёкшие копии (с «просроченным» временем жизни), а если срок действия вышел — обязательно обращаться к серверу.
    - Часто используется совместно с max-age.
    - Пример: `Cache-Control: must-revalidate`
4. **public / private**
    - **public** — ответ может быть сохранён любыми кешами (и приватными, и общими).
    - **private** — ответ предназначен только для приватного кеша пользователя.
    - Примеры:
        - `Cache-Control: public`
        - `Cache-Control: private`
5. **max-age=<seconds>**
    - Чётко указывает, сколько секунд ресурс считается «свежим» и может отдаваться из кеша без повторной валидации.
    - Пример: `Cache-Control: max-age=31536000` (примерно 1 год)

### Expires

- Указывает точную дату и время, до которых ресурс считается «свежим».
- Уступает по приоритету `Cache-Control: max-age`.
- Пример: `Expires: Wed, 15 Jun 2025 20:00:00 GMT`

### Pragma

- «Устаревший» (HTTP/1.0) заголовок.
- В современных реалиях практически используется только для обратной совместимости, аналог `no-cache`, если нет Cache-Control.

### ETag и Last-Modified (валидация кеша)

- **ETag** — «хэш» или иное уникальное значение, генерируемое сервером.
    - При повторном запросе клиент шлёт `If-None-Match: <ETag>`; сервер решает, совпадает ли ETag. Если ресурс не изменился, возвращает `304 Not Modified`.
- **Last-Modified** — дата и время последнего изменения ресурса.
    - При повторном запросе клиент шлёт `If-Modified-Since: <timestamp>`; если ресурс не изменялся, сервер также вернёт `304 Not Modified`.

### Vary

- Указывает, по каким полям запроса (заголовкам) нужно отличать разные варианты одного и того же ресурса.
- Пример: `Vary: User-Agent`. Значит, кеш будет хранить разные версии ответа для разных значений `User-Agent`.

---

## 3. Свежесть сохранённой копии и обновление (expiration & validation)

1. **Expiration (срок действия):**
    - Использует `max-age`, `Expires` или вычисляется эвристически (на основе `Last-Modified`).
    - Пока ресурс «свежий», браузер или прокси отдают его из кеша без запроса к серверу.
2. **Validation (валидация):**
    - Когда ресурс «устарел» (статус stale), клиент отправляет условный запрос (If-None-Match или If-Modified-Since).
    - Сервер либо возвращает `304 Not Modified`, либо новый ресурс (200 OK), если он изменился.

---

## 4. Инвалидация кеша

Под **инвалидацией** кеша понимается процесс, когда закешированные данные признаются недействительными (устаревшими), даже если срок их жизни ещё не истёк или безотносительно заданных заголовков.

### Когда нужно делать инвалидацию кеша?

- **Срочное обновление контента**: если обнаружена ошибка в ресурсе, и необходимо, чтобы пользователи немедленно получили новую версию.
- **Безопасность**: если закешировались данные, которые больше не должны быть доступны (например, устаревшие токены).
- **Релиз новой версии**: меняются JS/CSS файлы, и важно, чтобы все пользователи начали использовать новую версию ресурсов.

### Способы инвалидации

1. **Изменить имя/путь к ресурсу («Revved resources»)**
    - Например, для файла `main.css` при каждом релизе указывать новую версию: `main.v2.css`.
    - Сервер и клиенты увидят «новый» URL → предыдущая копия окажется невостребованной.
    - Это самый надёжный способ заставить всех загружать обновлённую копию.
2. **С помощью заголовков**
    - Если есть доступ к конфигурации сервера, можно выставить `Cache-Control: no-cache` или уменьшить `max-age` на короткий период, чтобы «сломать» длительный кеш.
    - Сразу после обновления ресурсов вернуть настройки обратно.
3. **Очистка кеша на стороне CDN/прокси/сервера**
    - На CDN-провайдерах (Cloudflare, Akamai и т. п.) часто есть возможность «форсировать» чистку (purge) отдельных URL или целых путей.
4. **ETag/Last-Modified**
    - Обновив ETag или дату последнего изменения, можно заставить при следующем запросе клиента понять, что ресурс изменился.

---

## 5. Типичные вопросы и ответы для собеседования

Ниже приведён список наиболее частых вопросов, которые могут задать на собеседовании, и примерные ответы, которые продемонстрируют понимание механизма HTTP-кеширования.

### Вопрос 1. Что такое HTTP-кеширование и для чего оно нужно?

**Пример ответа**:

«HTTP-кеширование — это процесс сохранения ранее полученного ресурса (HTML-страницы, изображения, JS, CSS и т. д.) для более быстрого доступа в дальнейшем. Это снижает задержку (время отклика сайта) и уменьшает объём сетевого трафика, повышая производительность и улучшая пользовательский опыт.»

### Вопрос 2. В чём разница между приватным и общим (shared) кешем?

**Пример ответа**:

- «Приватный (private) кеш хранит ресурсы, доступные только одному пользователю (например, кеш браузера). Это удобно для персонализированных данных.
- Общий (shared) кеш — это кеш, которым пользуются сразу несколько клиентов (например, прокси-кеш). Он экономит трафик и время, когда несколько пользователей запрашивают одинаковые ресурсы.»

### Вопрос 3. Какие заголовки используются для управления кешированием?

**Пример ответа**:

«Основные заголовки — это `Cache-Control` (с директивами вроде `max-age`, `no-cache`, `public`, `private`, `must-revalidate` и т. д.), `Expires`, `ETag`, `Last-Modified` и `Vary`. Также существует заголовок `Pragma` для обратной совместимости с HTTP/1.0.»

### Вопрос 4. Как работает механизм `ETag` и зачем он нужен?

**Пример ответа**:

«`ETag` — это уникальная строка (хэш или другое значение), генерируемая сервером для идентификации версии контента. Клиент при повторном запросе может отправить заголовок `If-None-Match: <ETag>`. Если ресурс не изменился, сервер отвечает `304 Not Modified`, что экономит трафик и ускоряет загрузку.»

### Вопрос 5. Что произойдёт, если срок действия (max-age) ещё не истёк, а ресурс на сервере уже поменялся?

**Пример ответа**:

«Если `max-age` ещё не истёк, клиент (или прокси) будет считать ресурс «свежим» и отдаст из кеша, **если** не включены механизмы вроде `must-revalidate` или не настроена инвалидация. Именно поэтому важно либо использовать валидацию (ETag, Last-Modified), либо следить за сроком жизни и обновлять версии ресурсов (revving), чтобы исключить несоответствия.»

### Вопрос 6. Как можно принудительно («жёстко») инвалидировать кеш?

**Пример ответа**:

1. «Поменять URL ресурса (например, `style.v2.css`) — это гарантированный способ.
2. Использовать механизмы CDN (purge/invalidate).
3. Установить на сервере `Cache-Control: no-cache` или `must-revalidate`, либо другой короткий max-age на время, чтобы гарантировать обновление копий.»

### Вопрос 7. Для чего нужен заголовок `Vary`?

**Пример ответа**:

«`Vary` говорит кешу, по каким полям запроса отличать кэшированные варианты ответа. Например, `Vary: User-Agent` означает, что мобильные и десктопные версии сайта будут храниться отдельно и не будут путаться.»

### Вопрос 8. Чем отличается `no-cache` от `no-store`?

**Пример ответа**:

- «`no-store` — запрещает вообще что-либо сохранять в кеш.
- `no-cache` — позволяет сохранить, но перед использованием **обязательно** проверяет актуальность ресурса на сервере.»

### Вопрос 9. Что такое «revved resources» и зачем их используют?

**Пример ответа**:

«Это способ кеширования статических файлов (CSS, JS) с очень долгим `max-age`, при котором каждой новой версии файла дают новое уникальное имя (например, `app.12345.js`). Таким образом, клиент всегда будет получать свежую версию (новый URL), и при этом можно агрессивно кешировать старые версии, не опасаясь, что они будут использоваться вместо новых.»

### Вопрос 10. Какие ошибки в конфигурации кеша встречаются чаще всего?

**Пример ответа**:

- «Не настроены корректно заголовки `Cache-Control`, из-за чего контент не кешируется или, наоборот, кешируется слишком долго.
- Отсутствует уникальная версия (revving) для меняющихся файлов — пользователи видят старые версии.
- Игнорирование `Vary` при генерации контента под разные условия (например, язык браузера или тип устройства).»

---

## 6. Дополнительные моменты для тестировщика

- **Проверка реальной работы кеша**: с помощью вкладки «Сеть» (Network) в инструментах разработчика браузера (DevTools). Смотреть заголовки `Cache-Control`, `Expires`, `ETag`, `Last-Modified`, а также статус (200, 304, memory cache, disk cache и т. д.).
- **Тестирование инвалидации**:
    - Менять версии файлов и проверять, загружается ли новая версия после обновления страницы.
    - Проверять, как ведут себя прокси и CDN в случае «purge»-запросов.
- **Edge-cases**:
    - Если ресурс передаётся по HTTPS и имеет чувствительные данные — корректная ли политика кеширования?
    - При использовании SSR (Server-Side Rendering) либо клиентских фреймворков (React, Vue, Angular) убедиться, что заголовки не конфигурируются «по умолчанию» некорректно.