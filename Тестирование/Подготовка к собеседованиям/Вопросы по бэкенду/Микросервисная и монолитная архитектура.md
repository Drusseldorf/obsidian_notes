# Микросервисная и монолитная архитектура

## 1. Общие сведения об архитектурах

### 1.1 Монолитная архитектура

**Монолит** — это стиль разработки приложений, когда всё приложение представляет собой единый исполняемый модуль (одноцелостное приложение). Вся логика, все модули (обработка HTTP-запросов, бизнес-логика, доступ к базе данных и т.д.) связаны и разворачиваются совместно.

**Особенности монолита**:

- Единый кодовый репозиторий или один большой проект (иногда разделённый на подпроекты, но всё равно деплоится как одно целое).
- Обновление — «большой релиз»: раз в неделю/месяц (реже — при очень больших проектах).
- Проще начинать разработку, потому что все части находятся «в одном месте».
- Масштабирование — обычно вертикальное (добавление ресурсов на сервер) или развёртывание нескольких копий монолита за нагрузочным балансировщиком.
- Может приводить к «гигантскому блоку» (Big Ball of Mud), если проект растёт без чёткой модульности.

### 1.2 Микросервисная архитектура

**Микросервисы** — это стиль разработки, при котором приложение разбивается на набор мелких сервисов, каждый из которых отвечает за определённую функциональность и развёртывается независимо.

**Особенности микросервисов**:

- Каждый сервис имеет свой репозиторий/кодовую базу (или один монорепо, но всё равно сервисы отделены логически).
- Каждый сервис может использовать свой стек технологий (вплоть до разных языков программирования).
- Масштабирование — горизонтальное, избирательное (можно «поднять» больше инстансов одного сервиса, если именно он испытывает высокую нагрузку).
- Обновление сервисов независимое, часто цикл релизов короче (CI/CD).
- Более сложная инфраструктура (оркестрация, взаимодействие между сервисами, сетевая конфигурация, мониторинг, логирование).

---

## 2. Сравнение подходов к тестированию

Ниже кратко описаны ключевые отличия в том, как тестируют монолитное и микросервисное приложения.

### 2.1 Тестирование монолита

1. **Уровни тестирования**:
    - Юнит-тесты (Unit Tests)
    - Интеграционные тесты (Integration Tests)
    - Системные/End-to-End (E2E) тесты
2. **Особенности**:
    - При тестировании монолита проще воспроизвести окружение: вся логика в одном приложении, не нужно эмулировать другие сервисы.
    - Регрессионное тестирование может быть большим (один релиз → полный прогон тестов).
    - Подход «большого релиза» часто означает, что QA проводит обширную проверку перед выкладкой в продакшен.
3. **Основные проблемы**:
    - Большой объём изменений за релиз может приводить к множеству регрессий (весь код связан).
    - Долгое время сборки и тестового прогона.

### 2.2 Тестирование микросервисов

1. **Уровни тестирования**:
    - Юнит-тесты в каждом микросервисе.
    - Контрактное тестирование (Contract Testing) между сервисами.
    - Интеграционное тестирование микросервисов (в составе «наборов» или всей системы).
    - E2E-тестирование, проверяющее цепочки запросов, проходящих через несколько сервисов.
2. **Особенности**:
    - Каждый сервис имеет свой отдельный набор тестов и пайплайн CI/CD.
    - За счёт независимых релизов у разных микросервисов QA-команда должна следить за «совместимостью» версий.
    - Контрактное тестирование помогает избежать ситуаций, когда изменения в одном сервисе «ломают» другой (проверяются «контракты» — форматы запросов и ответов).
    - При интеграционных или E2E-тестах может быть сложно развернуть целую «мини-продакшен» среду (особенно если десятки сервисов).
3. **Основные проблемы**:
    - Повышенная сложность инфраструктуры (оркестраторы Docker/Kubernetes, внешние сервисы, сервис-меш и т.д.).
    - Необходимость в системах распределённого логирования и трейсинга (ELK, Jaeger, Zipkin), чтобы отлавливать ошибки «по цепочке» сервисов.
    - Возможны «флейки» (flaky tests), связанные с сетевыми задержками, временем ответа сервисов и сложным пайплайном.

---

## 3. Детальный блок: Отличия в подходах к тестированию

В табличной форме:

| Аспект | Монолит | Микросервисы |
| --- | --- | --- |
| **Структура кода** | Единый проект (часто один репозиторий) | Набор независимых сервисов (много репозиториев) |
| **Сборка и деплой** | Общий билд и единый релиз | Раздельные билды и частые релизы (per-service) |
| **Тестовые окружения** | 1-2 окружения (Staging / Prod) | Множество окружений, для каждого набора сервисов (Dev, Staging, QA, Prod) |
| **Интеграционное тестирование** | Преимущественно внутри одного приложения | Нужно эмулировать/разворачивать несколько сервисов, плюс контрактное тестирование |
| **Тестирование «под нагрузкой»** | Тестируем всё приложение целиком | Тестируем отдельные сервисы (нагрузка), а также систему целиком |
| **Локальное воспроизведение проблем** | Обычно проще, код в одном месте | Сложнее, надо поднять несколько сервисов и их зависимости (БД, очереди, сторонние API) |
| **Общее время тестирования** | Может быть дольше, так как релиз «большой» | Быстрее для одного сервиса, но общее E2E тестирование может быть сложнее |
| **Команда QA** | Может быть одна команда, ответственная за весь продукт | Могут быть QA-специалисты, закреплённые за каждым сервисом, плюс команда, которая отвечает за интеграционные/сквозные тесты |

---

## 4. Роль тестировщика в монолите и микросервисах

### 4.1 Монолит

- **Фокус**: регрессионное, системное тестирование.
- **Автоматизация**: обычно есть один набор автоматизированных тестов (юнит/интеграция/GUI) на весь продукт.
- **Коммуникации**: QA тесно взаимодействует с одной (или небольшой) командой разработчиков.

### 4.2 Микросервисы

- **Фокус**: контрактные тесты, интеграционные тесты на уровне каждого сервиса, сквозные (E2E) тесты.
- **Автоматизация**: обычно распределённая: в каждом сервисе есть юнит-тесты и минимальный набор интеграционных тестов; сквозные тесты запускаются в отдельном пайплайне.
- **Коммуникации**: QA должен общаться с несколькими командами (каждая разрабатывает свой сервис), знать «контракты» между ними.
- **Отдельная роль**: может существовать «QA-координатор» или «Integration QA», который следит за связями между сервисами.

---

## 5. Вопросы и ответы для собеседования

Ниже приводятся вопросы, которые могут встретиться на интервью, а также примерные ответы, показывающие понимание различий между монолитной и микросервисной архитектурой и подходами к тестированию.

### Вопрос 1. Что такое монолитная архитектура, и каковы её преимущества?

**Пример ответа**:

«Монолит — это когда всё приложение — единое целое. Плюсы: единый код, проще развернуть и настроить окружение, проще на старте разработки. Минусы: труднее масштабировать, большие релизы, возможен «эффект снежного кома» при внесении изменений.»

### Вопрос 2. Зачем переходить к микросервисам, если есть монолит?

**Пример ответа**:

«Микросервисы позволяют независимо развивать и масштабировать части приложения. Они упрощают поддержку больших систем, так как каждая команда может работать над своим сервисом, используя удобный ей стек. Но при этом усложняется инфраструктура и взаимодействие между сервисами.»

### Вопрос 3. Как отличается процесс тестирования в монолитах и микросервисах?

**Пример ответа**:

«В монолитах у нас единый проект, где тесты гонятся «всё вместе»: юнит, интеграционные, E2E. В микросервисах у каждого сервиса свой набор тестов и есть отдельное контрактное тестирование, чтобы при изменении одного сервиса не «сломался» другой. Сложнее организовать E2E-тесты, ведь нужно поднять несколько сервисов и обеспечить их совместимость.»

### Вопрос 4. Что такое «контрактное тестирование» и почему оно важно в микросервисах?

**Пример ответа**:

«Контрактное тестирование проверяет, что сервис А и сервис Б согласованы по формату запросов и ответов. Если разработчик меняет структуру ответа в сервисе А, у сервиса Б не должно всё сломаться. Контрактные тесты помогают найти проблемы на стадии сборки, а не в продакшене.»

### Вопрос 5. Как тестировщику локально воспроизвести ошибки в микросервисной архитектуре?

**Пример ответа**:

«Нужно поднять нужные сервисы в Docker-контейнерах или Minikube/другой локальной среде. Иногда используют mock-сервисы (заглушки) вместо реальных зависимостей. Также важно иметь доступ к логам, настройкам и документации, чтобы понять, как сервисы взаимодействуют.»

### Вопрос 6. Какие особенности нагрузочного (performance) тестирования в микросервисах?

**Пример ответа**:

«Можно отдельно нагружать конкретные сервисы, выявляя «узкие места» (bottlenecks), а также проводить сквозной тест, чтобы проверить общую пропускную способность системы. При этом приходится учитывать сетевые задержки, балансировку нагрузки и мониторинг каждого сервиса в отдельности.»

### Вопрос 7. Как организовать тестовые окружения при микросервисном подходе?

**Пример ответа**:

«Часто есть несколько стендов (Dev, Test/Staging, Pre-Prod, Prod). Каждый сервис деплоится в эти окружения с разными конфигурациями, но важно, чтобы версии сервисов были совместимы. Иногда для каждой фичи поднимается короткоживущий стенд (on-demand environment) для интеграционных тестов.»

### Вопрос 8. Есть ли смысл использовать микросервисы для маленького проекта?

**Пример ответа**:

«Микросервисы дают выигрыш при сложных системах и больших командах. Для небольшого проекта они могут оказаться избыточно сложными. Важно соизмерять масштабы приложения и затраты на поддержку распределённой системы.»

### Вопрос 9. Какие метрики или инструменты мониторинга чаще всего используются в микросервисах?

**Пример ответа**:

«Например, Prometheus + Grafana для метрик, ELK (Elasticsearch, Logstash, Kibana) для логов, Jaeger/Zipkin для распределённого трейсинга. Это помогает отследить прохождение запроса через несколько сервисов и найти точку сбоя.»

### Вопрос 10. Как уменьшить регрессионные риски в большой микросервисной системе?

**Пример ответа**:

«Использовать мощный набор автоматизированных тестов — от юнит-тестов до E2E, внедрить контрактное тестирование. Организовать CI/CD с понятными «гейтами» (где, если тесты не прошли, сборка не идёт дальше). Стараться выкатывать изменения мелкими порциями, а не «одним махом».»

---

## 6. Дополнительные советы для тестировщика

1. **Чётко знать структуру системы**:
    - Для монолита — понимать основные модули, их взаимосвязи.
    - Для микросервисов — какие сервисы есть, каково их назначение, где находятся API, где документация.
2. **Контрактное тестирование — ключ к успеху** (в микросервисах):
    - Изучить инструменты вроде Pact, Spring Cloud Contract (в Java) или иные аналоги, позволяющие описывать и проверять «контракты».
3. **Инфраструктура и окружения**:
    - Разобраться, как поднимается локальное окружение (Docker Compose, Kubernetes Helm Charts и т.п.).
    - Понимать, как сервисы конфигурируются, что такое Service Discovery, как применяются объекты Kubernetes (Pod, Deployment, Service, Ingress).
4. **Избегать «флейков» (flaky tests)**:
    - При микросервисах тесты могут падать из-за сетевых ошибок, таймаутов, нестабильных зависимостей. Внедрять повторные прогоны (retries), грамотно настраивать таймауты, пользоваться моками, когда нужно проверить сервис «в изоляции».
5. **Логирование и мониторинг**:
    - Наличие распределённого трейсинга упрощает поиск проблем в больших микросервисных системах.
    - Тестировщику полезно уметь работать с Kibana, Grafana, чтобы подтверждать или опровергать гипотезу о системных сбоях.