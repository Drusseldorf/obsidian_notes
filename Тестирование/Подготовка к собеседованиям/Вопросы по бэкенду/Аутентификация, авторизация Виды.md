# Аутентификация, авторизация. Виды.

# 1. Термины и их значения

## Идентификация

Это процесс определения личности пользователя или системы. Например, когда пользователь вводит своё имя пользователя (username) в форме входа — мы его «идентифицируем» как потенциального пользователя с таким именем. Сам по себе этот процесс не даёт уверенности, что пользователь действительно тот, за кого себя выдаёт.

**Пример с точки зрения пользователя**:

Пользователь вводит логин «ivan_123» в поле «Имя пользователя». Система «узнаёт», что есть аккаунт с таким именем.

**Технический аспект**:

На серверной стороне происходит поиск в БД по имени «ivan_123». Если запись найдена, система понимает, что пользователь хочет действовать от имени конкретного аккаунта. Но это ещё не аутентификация — нужно проверить пароль или иной способ подтверждения личности.

## Аутентификация

Это процесс подтверждения личности. Система проверяет, действительно ли вы тот, кем представлялись на этапе идентификации.

Чаще всего это делается через проверку пароля, одноразового кода (2FA), ключа API или иного фактора.

**Пример с точки зрения пользователя**:

Пользователь вводит пароль для «ivan_123». Система сверяет введённый пароль с хэшем пароля в БД. Если совпадает, то пользователь «подтверждён».

**Технический аспект**:

- Если пароль верен, сервер генерирует сессию или токен, который привязывает к учётной записи.
- Если пароль неверен, сервер возвращает ошибку и не выдаёт ни сессию, ни токен.

## Авторизация

Это процесс определения, что пользователь может делать в системе. После того как пользователь аутентифицирован, система решает, какие ресурсы и действия ему доступны.

**Пример с точки зрения пользователя**:

«ivan_123» имеет роль «user» и может просматривать свой профиль, но не может, к примеру, менять настройки других пользователей или просматривать их данные.

**Технический аспект**:

На серверной стороне могут проверяться права пользователя (роль, permissions), и на основании этого предоставляется или не предоставляется доступ к запрашиваемым ресурсам.

## В контексте HTTP

В контексте HTTP-ответов обычно используется следующая логика:

1. **Не аутентифицирован** (пользователь не прошел процесс входа / не предоставил корректные учетные данные) — код **401 Unauthorized**.
    
    - Несмотря на название «Unauthorized» («не авторизован»), исторически сложилось, что **401** означает именно отсутствие корректной аутентификации. То есть запрос требует авторизации (логина), но она не была предоставлена или неверна.
2. **Не авторизован** (пользователь аутентифицирован, но не имеет прав для доступа к ресурсу) — код **403 Forbidden**.
    
    - Сервер понимает, кто вы, но отказывает в доступе, потому что у вас недостаточно прав.
---

# 2. Обзор основных методов

Существует несколько основных способов аутентификации и передачи данных для авторизации. Ниже мы разберём самые популярные:

- **HTTP Basic**
- **OAuth2**
- **JWT** (JSON Web Token)
- **Сессии**
- **API-ключи**

Каждый метод обладает своими плюсами и минусами, которые важно понимать.

---

## 2.1 HTTP Basic

**Что это такое?**

HTTP Basic — простой способ аутентификации, при котором логин и пароль передаются в заголовке запроса (после кодирования base64). Технически это не очень безопасно, если не используется HTTPS, потому что логин и пароль могут быть перехвачены «как есть» (base64 легко декодировать).

**Когда применяется?**

- Для простых внутренних сервисов, где нет сложных требований к безопасности
- Для автоматизации и скриптов (когда сервис недоступен публично или используется VPN)

**Чем опасно?**

- Если нет HTTPS, логин/пароль легко «подсмотреть»
- Не очень удобно отзывать доступ: придётся менять пароль и передавать новый

**Что могут спросить на интервью?**

- Чем отличается Basic-авторизация от других типов (Bearer, Digest)?
- Безопасно ли хранить логин/пароль в заголовках без HTTPS?
- Как тестировать Basic-авторизацию (проверка кодировки base64, корректность обработки неправильных учётных данных)?

---

## 2.2 Сессии (Session-based)

**Как работает?**

1. Пользователь вводит логин/пароль и отправляет запрос на сервер.
2. Если данные верны, сервер создаёт сессию и сохраняет в своей БД (или другом хранилище) пару ключ-значение: `session_id` -> данные о пользователе.
3. Сервер отправляет клиенту cookie (обычно `session_id` и еще какие либо данные о юзере)
4. При каждом последующем запросе браузер автоматически добавляет этот cookie. Сервер сверяется со своей БД: если сессия действительна, пользователь идентифицируется и аутентифицируется.

**Где хранится информация?**

- На сервере в БД (ключ `session_id`, значение — информация о пользователе или ссылка на неё).
- У клиента в виде куки (только идентификатор, без приватных данных).

**Тонкие моменты**:

- Нужно использовать атрибуты `HttpOnly`, `Secure`, `SameSite` для куки, чтобы снизить риск XSS-атак и утечек.
- Обычно для публичного API сессии не применяются, потому что REST сервисы чаще идут по Token-based или OAuth2 схемам.
- Возможна «привязка» сессии к отпечатку (fingerprint): ip-адрес, user-agent и др., чтобы сессию не угнали на другом устройстве.

**Что могут спросить на интервью?**

- Как сервер «понимает», что разные запросы принадлежат одному пользователю?
- Зачем нужны `HttpOnly` и `Secure`?
- Как тестировать механизмы истечения (expiration) сессии?
- Что будет, если сессию украдут?

---

## 2.3 Токены и JWT (JSON Web Token)

### 2.3.1 Токены: общий подход

**Идея**: Вместо хранения состояния на сервере (как в сессиях) само удостоверение пользователя «упаковывается» в токен, который клиент передаёт при каждом запросе.

- Токен может быть любым форматом, но часто выбирают JWT, т.к. он популярен и стандартно описан.

**Сценарии использования**:

- Публичные API
- Микросервисная архитектура (удобно, когда один сервис выдает токен, а другой сервис его проверяет)
- SPA-приложения (Single Page Application), где фронтенд и бэкенд часто разделены

**Основные преимущества**:

- Нет необходимости хранить состояние сессии на сервере (хотя иногда делают «чёрный список» для отозванных токенов).
- Легко масштабировать, так как любую копию сервера можно настроить на валидацию подписи токена.

### 2.3.2 JWT: структура и особенности

JWT (JSON Web Token) обычно состоит из трёх частей, разделённых точками (`.`):

1. **Header** (заголовок) — указывает тип токена (`JWT`) и алгоритм подписи (`HS256`, `RS256` и т.д.).
2. **Payload** (полезная нагрузка) — содержит «претензии» (claims): данные о пользователе, сроки действия (exp), issuer (iss) и другие поля.
3. **Signature** (подпись) — формируется путём шифрования (точнее, хеширования с ключом) первых двух частей (header и payload). Подпись позволяет проверить целостность и аутентичность данных в токене.

**Как работает JWT**:

1. При успешной аутентификации сервер формирует JWT с подписью (секретным ключом или с использованием приватного ключа при асимметричных алгоритмах).
2. Клиент получает JWT (часто в заголовке `Authorization: Bearer <токен>` или в cookie).
3. При каждом запросе клиент отправляет токен.
4. Сервер валидирует подпись и срок действия токена, и в случае успеха «узнаёт» пользователя и даёт доступ к ресурсам.

**Refresh-токен и Access-токен**:

- **Access-токен** (короткоживущий) — позволяет выполнять операции от имени пользователя. Обычно действует несколько минут/часов.
- **Refresh-токен** (долгоживущий) — используется для запроса нового Access-токена без повторного логина. Хранится более аккуратно, т.к. его кража может дать длительный доступ.
- При использовании пары «access + refresh» кража Access-токена менее критична, так как он действует недолго, а Refresh-токен, например, может храниться в HttpOnly-cookie и использоваться только с защищённым соединением.

**Безопасность и ограничения**:

- JWT по умолчанию «неотзываемый» — если вы скомпрометировали токен, то отозвать его невозможно без дополнительных механизмов. Могут использоваться «чёрные списки» или хранение «токен версии» в базе пользователя.
- Не рекомендуется хранить чувствительные данные (например, пароль) в payload, потому что любая сторона, получившая JWT, может декодировать payload (base64 не шифрует, а лишь кодирует).
- Важно следить за сроком действия токена (`exp`), чтобы предотвратить долгосрочные утечки.

**Что могут спросить на интервью?**

- Чем JWT отличается от сессий?
- Как устроена подпись JWT, что будет если изменить payload?
- Как тестировать expiry (истечение) токена?
- Почему JWT по умолчанию не отзывные и как это решается?
- Безопасно ли хранить JWT в localStorage?

---

## 2.4 OAuth2

**Что это такое?**

OAuth2 — это протокол авторизации, который позволяет одной системе предоставить ограниченный доступ к ресурсам пользователя другой системе (клиенту) без раскрытия логина и пароля. Часто используется при «входе через социальную сеть» (Google, Facebook и т.д.).

**Основные роли**:

1. **Владелец ресурса (Resource Owner)** — это пользователь, чьи данные нужно расшарить.
2. **Сервер ресурсов (Resource Server)** — хранит эти данные и отдаёт их только при наличии валидных «токенов доступа».
3. **Клиент (Client)** — сторонний сервис, которому нужны данные.
4. **Сервер авторизации (Authorization Server)** — выдаёт токены после согласия пользователя.

**Как это выглядит для пользователя**:

1. Пользователь заходит на сторонний сайт и видит кнопку «Войти через Google».
2. Его перенаправляет на страницу авторизации Google.
3. Google спрашивает: «Разрешить ли этому приложению доступ к вашим данным?»
4. Если пользователь соглашается, Google выдаёт приложению токен (или код, который обменивается на токен).
5. Приложение использует этот токен для доступа к API Google.

**Варианты использования**:

- Авторизация клиентов на сайтах через социальные сети (OAuth2 — базис для OpenID Connect).
- Предоставление доступа к API третьим сторонам (например, сервис планировщика постов в соцсетях).

**Что могут спросить на интервью?**

- Какие есть Grant Types (Authorization Code, Implicit, Password, Client Credentials)?
- Как происходит передача токенов при OAuth2?
- Разница между OAuth2 и OpenID Connect?
- Как тестировать flow OAuth2 (перенаправления, проверка валидности токенов, отзыв разрешений)?

---

## 2.5 API-ключи (API Keys)

**Что это такое?**

API-ключ — это простой ключ (строка), который передаётся клиенту для использования при запросах к API. Обычно применяется для серверного взаимодействия и ограниченного доступа (например, к публичным сервисам с ограничением по тарифам).

**Особенности**:

- Могут просто передаваться в заголовках (например, `x-api-key: <key>`).
- Плохо подходят, если нужно знать конкретного пользователя. API-ключ часто «привязан» к аккаунту или роли на стороне сервиса.
- Нужно держать в секрете, иначе злоумышленники могут использовать API-ключ для бесплатного доступа или атак.

**Когда применяется**:

- Бесплатные/публичные сервисы, где нужна просто идентификация клиента (например, Google Maps API, Weather API).
- Мобильные приложения (но там иногда удобнее использовать OAuth2).

**Что могут спросить на интервью?**

- Как обеспечить безопасность хранения API-ключа?
- Чем отличается API-ключ от Bearer-токена (JWT)?
- Нужно ли для API-ключа механизм отзыва/ротации?

---

# 3. Сравнительный анализ

| Метод | Где часто используется | Преимущества | Недостатки |
| --- | --- | --- | --- |
| **HTTP Basic** | Внутренние сервисы, быстрое прототипирование | Простота реализации (стандарт HTTP), не нужны куки | Небезопасно без HTTPS, данные легко скомпрометировать |
| **Сессии** | Классические веб-сайты | Удобно контролировать состояние, легко «разлогинить» | Нужно хранить сессии на сервере, хуже масштабируется |
| **JWT** | Публичные API, микросервисы, SPA | Не хранит состояние на сервере, легко масштабировать | Сложнее отозвать, необходимо бережно относиться к безопасности |
| **OAuth2** | Доступ к сторонним ресурсам, соц. сети | Гибкая модель, даёт ограниченный доступ, не выдавая пароль | Сложность реализации, особенно при работе с разными типами Grant |
| **API-ключи** | Публичные API, сервисы по подписке | Простая передача, нет необходимости в логине/пароле | Не привязан к конкретному пользователю, нет тонких прав доступа |

**Когда что использовать?**

- **Сессии**: классические многостраничные веб-приложения, где пользователь (через браузер) постоянно ходит по разным страницам.
- **JWT**: микроcервисы, REST API, мобильные и SPA-приложения. Легко работать при больших нагрузках и при разделении фронтенда и бэкенда.
- **OAuth2**: когда нужно авторизовать доступ к ресурсам от имени пользователя, не раскрывая логин/пароль. Особенно актуально при «входе через…» и интеграциях.
- **HTTP Basic**: простые внутренние сервисы, когда защита не критична или всегда есть HTTPS, плюс используется VPN/внутренняя сеть.
- **API-ключи**: открытые или публичные API (например, сервис погоды), где нужно лишь определить «кто ты», но не нужно знать конкретного пользователя.

---

# 4. Тонкости, важные для тестировщика

1. **Проверка безопасности (Security testing)**:
    - Передаются ли данные только по HTTPS?
    - Есть ли защита от XSS/CSRF (особенно важна для сессионной аутентификации)?
    - Правильно ли настроены заголовки (например, `SameSite`, `HttpOnly`, `Content-Security-Policy` и т.п.)?
2. **Проверка истечения (expiration)**:
    - Как ведёт себя приложение при просроченном токене/сессии?
    - Удобен ли механизм обновления сессии или токена (refresh-токен/продление сессии)?
3. **Проверка отзыва (revocation)**:
    - Можно ли отозвать токен? (особенно важно для JWT, где по умолчанию нет такого механизма)
    - При разлогине (logout) действительно ли пользователь теряет доступ?
4. **Правильность ролей и прав**:
    - Проверять, что пользователь с ролью «user» не может получить доступ к ресурсам для «admin» и наоборот.
    - Тестировать негативные сценарии (когда токен неверный, когда нет токена и т.д.).
5. **Load/Performance-тесты**:
    - Как сервер обрабатывает множество сессий или JWT-проверок?
    - Есть ли кеширование публичных ключей (при RS256), не падает ли сервер при большом количестве проверок подписей?
6. **Граничные случаи**:
    - Токен истёк ровно в момент запроса.
    - Сессия просрочена, но клиент продолжает слать куки.
    - Ошибки в дате на клиентской или серверной стороне (несовпадение временных поясов).

---

# 5. Типичные вопросы на собеседовании

1. **Объясните разницу между идентификацией, аутентификацией и авторизацией.**
2. **Что такое `HttpOnly` и `Secure` атрибуты для cookie, зачем их применять?**
3. **Чем JWT лучше или хуже сессий?**
4. **Как работать с отзывом (инвалидацией) JWT?**
5. **Объясните flow OAuth2 (Authorization Code, Client Credentials и т.д.).**
6. **Как протестировать истечение сессии / токена, какие сценарии проверить?**
7. **Можно ли хранить JWT в localStorage и почему это может быть небезопасно?**
8. **Какие уязвимости возможны при использовании рефреш-токена?**
9. **Как настроить тестовое окружение для проверки аутентификации/авторизации?**
10. **Что делать при переходе от одной схемы авторизации к другой (например, с сессий на токены)?**

## Ответы

Ниже приведены ответы на вопросы, которые обычно задают на собеседованиях при обсуждении идентификации, аутентификации и авторизации, а также методов их реализации. Ответы сформулированы с учётом того, что вы — тестировщик (QA-инженер), и вам важно понимать как общие концепции, так и нюансы тестирования.

---

## 1. Объясните разницу между идентификацией, аутентификацией и авторизацией

**Идентификация** – это определение субъекта (пользователя или системы), который обращается к ресурсу. На практике: пользователь вводит логин (username). Система «понимает», что к ней пытается обратиться «user123», но пока не знает, действительно ли это он.

**Аутентификация** – проверка, действительно ли пользователь является тем, за кого себя выдаёт. Чаще всего это проверка пароля, но также могут использоваться и другие механизмы: одноразовые коды (2FA), ключи API, токены, биометрия и т. д.

**Авторизация** – определение уровня прав/доступа после успешной аутентификации. Например, пользователь «user123» может просматривать только свои данные, а администратор может видеть и изменять данные всех.

---

## 2. Что такое `HttpOnly` и `Secure` атрибуты для cookie, зачем их применять?

- **`HttpOnly`** – атрибут, который запрещает доступ к cookie из JavaScript. Это помогает защититься от XSS-атак (Cross-Site Scripting), при которых злоумышленник может попытаться считать cookie через скрипты на странице.
- **`Secure`** – атрибут, который указывает, что cookie следует передавать только по HTTPS-соединению. Это защищает от перехвата cookie в незащищённом трафике (HTTP).

**Зачем применять?**

1. Уменьшить риск кражи сессионных идентификаторов и токенов.
2. Повысить общую безопасность приложения и защитить пользователя от распространённых веб-уязвимостей.

---

## 3. Чем JWT лучше или хуже сессий?

**Лучше**:

1. **Масштабирование** – JWT не требует хранения состояния (session) на сервере. При большой нагрузке можно балансировать запросы на разные серверы, просто проверяя подпись токена.
2. **Упрощённая интеграция** – легко использовать во многих микросервисах или сторонних сервисах, когда есть общий секрет/публичный ключ.
3. **Удобство** – payload токена может содержать нужные данные (роли, срок действия, userId и т. д.), которые быстро извлекаются без дополнительных запросов к базе.

**Хуже**:

1. **Отзыв токена** – JWT по умолчанию «неотзываемый». Если токен украли, отозвать его без спецмеханизмов (блэк-листы, версии токена и т. п.) невозможно.
2. **Безопасность хранения** – нужно аккуратно хранить JWT, чтобы не допустить утечки. При этом часто обсуждается, можно ли хранить JWT в localStorage и насколько это безопасно.
3. **Размер** – из-за base64 и payload токен может быть длиннее, чем session_id-строка.

---

## 4. Как работать с отзывом (инвалидацией) JWT?

1. **Списки отозванных токенов (блэк-листы)** – сервер хранит идентификаторы скомпрометированных JWT до их истечения. При каждом запросе проверяется, нет ли этого токена в «чёрном списке». Минус – надо вести учёт, плюс возрастает нагрузка на сервер.
2. **Хранить «версию токена» (token version) в профиле пользователя** – при каждой проверке токена сверять версию в payload с версией в БД. Если пользователь сделал «выход» или администратор отозвал доступ, версия в БД меняется, и все ранее выданные токены становятся невалидными.
3. **Минимизация TTL (времени жизни)** – сделать короткий срок жизни access-токена и использовать refresh-токен. Если украли access-токен, он скоро истечёт. Но если украдут refresh-токен, понадобится дополнительная защита (HttpOnly-cookies, безопасное хранение).

---

## 5. Объясните flow OAuth2 (Authorization Code, Client Credentials и т.д.)

OAuth2 – протокол авторизации, позволяющий предоставить стороннему приложению ограниченный доступ к ресурсам пользователя без передачи логина и пароля.

### Основные Grant Types:

1. **Authorization Code**
    - Сценарий для серверных приложений (или SPA с backend).
    - Пользователь перенаправляется на страницу авторизации (например, Google).
    - После успешной аутентификации Google возвращает «код», который сервер обменивает на токен.
    - Наиболее безопасный способ, т.к. клиентский секрет хранится на сервере, а «код» одноразовый.
2. **Implicit**
    - Устаревший сценарий для SPA (когда нет backend-сервера).
    - Токен выдают сразу, без «кода».
    - Менее безопасно, так как токен виден в URL и может быть перехвачен. Сейчас рекомендуют использовать PKCE (Proof Key for Code Exchange) вместо этого подхода.
3. **Resource Owner Password Credentials**
    - Когда доверенное приложение просит у пользователя логин/пароль и напрямую получает токен.
    - Чаще используется во внутренних системах, где приложение «доверенное».
    - Не подходит для публичных приложений, так как пользователь фактически выдаёт пароль стороннему сервису.
4. **Client Credentials**
    - Используется для взаимодействия «сервер-сервер», когда нет реального пользователя, но сервисы обмениваются данными (например, микросервисы).
    - Приложение (client) аутентифицируется своими «учётными данными» (client_id + client_secret) и получает токен.

---

## 6. Как протестировать истечение сессии / токена, какие сценарии проверить?

1. **Обычный сценарий истечения**:
    - Дождаться (или программно подделать время) конца «времени жизни» сессии/токена.
    - Отправить запрос от имени пользователя. Убедиться, что сервер отвечает «401 Unauthorized» или аналогичной ошибкой.
2. **Рефреш-сценарий** (если есть refresh-токен):
    - Сымитировать истечение access-токена, но при этом проверить, что с помощью refresh-токена можно получить новый access-токен.
3. **Принудительный логаут**:
    - Пользователь нажимает «Выйти» – нужно проверить, что сессия/токен тут же перестаёт работать, даже если срок не истёк.
4. **Пограничные случаи**:
    - Если время на клиенте сильно отличается от времени на сервере.
    - Запрос ровно в ту же секунду, когда «exp» у токена истекает.

---

## 7. Можно ли хранить JWT в localStorage и почему это может быть небезопасно?

Технически – **можно**, но **это небезопасно**, потому что:

1. При XSS-уязвимости злоумышленник может считать значения из `localStorage`.
2. Если в localStorage хранится refresh-токен, это даёт злоумышленнику длительный доступ (можно сгенерировать новые access-токены).
3. Рекомендуется хранить токены в **HttpOnly-cookie** (и при необходимости использовать механизм SameSite, CSRF-токены), чтобы затруднить кражу токенов через JavaScript.

Однако на практике многие SPA-приложения хранят токены именно в localStorage. Это всегда компромисс между удобством и безопасностью. При этом важно:

- Минимизировать срок жизни access-токена
- Продумывать защиту от XSS
- Стараться не хранить там refresh-токен или делать это очень осторожно

---
