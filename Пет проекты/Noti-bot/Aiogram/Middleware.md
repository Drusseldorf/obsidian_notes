# Middleware

Мидлварь - промежуточная логика в коде между какими-то двумя другими. 

Применяется, когда нам нужны какие то действия, при этом они не имеют непосредственного отношения к конкретному хэндлеру. По сути это способ разделения логики, разделения ответственности. (Сингл респособилити, мать его!)

В чем то они в Аиограм похожи на декораторы.

В Аиограм есть outter и inner

**outter** - выполняются до фильтра (до момента когда начинается поиск хэндлера)

**inner** - после того, как диспетчер по фильтру уже нашел хэндлер. То есть мы тут можем написать логику, которая выполняется до или после выполнения логики конкретного хэндлера. 

Они не обязательны, в том плане, что можно и реализовать это иным способом, но в некоторых кейсах это может оказаться удобным инструментом. 

Примеры использования на практике:
Сбор статистики, отправка данных в БД, авторизация пользователей  и тд

Обязательные импорты

```python
from aiogram import BaseMiddleware
```

Пример кода

```python
from aiogram import BaseMiddleware
from aiogram.types import TelegramObject
from typing import Callable, Dict, Any, Awaitable
```

```python
class TestMiddleware(BaseMiddleware):
# метод колл, принимает обработчик
# event - тип объекта. TelegramObject - любой объект. Но могут быть Message, callbackdata и тд
# data - доп инфа, напрример FSM
		async def __call__(self, handler: Callable[[TelegramObject, Dict[str, Any]], 
		Awaitable[Any]],
		event: TelegramObject,
		data: Dict[str, Any]) -> Any:
				print('Некие действия ДО обработчика')
				result = await handler(event, data)  # тут собсна выполняется сам обработчик
				print('Некие действия ПОСЛЕ обработчика')
				return result
```

Пишем класс, наследуемся от BaseMiddleware

Определяем метод  __call__, принимает хэндлер (для внутренней мидлвари, так как внешний не знает еще какой будет хэндлер), 

далее - event - это типа объекта. TelegramObject - это любой объект, который вообще может прийти в телеге. Можно указать конкретный объект, например message.

data - например FSM

Собственно в примере принты - это наши действия до и после хэндлера

result = await handler(event, data) - выполняется наш хэндлер, результат записываем

В конце обязательно возвращаем результат

Как теперь запустить мидлварь?

Импортируем наш класс и передаем для роутера:

```python
router.message.middleware(TestMiddleware())
```

Теперь при каждом сообщении (message - только сообщения) в роутер будет срабатывать наша мидлварь, при условии что сообщение попадет в какой то фильтр.

Как сделать outer?

```python
router.message.outer_middleware(TestMiddleware())
```

Теперь он будет срабатывает вообще всегда (при поступлении сообщения), так как действия срабатывают до поиска хэндлера