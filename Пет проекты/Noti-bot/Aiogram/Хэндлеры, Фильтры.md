# Хэндлеры, Фильтры

Хэндлеры - это функции, которые обрабатывают определенные события, такие как приходящие колбэки, или ввод команд, или просто текст. Любые события, которые происходят в чате с ботом.
Хэндлеры принимают в качестве аргументов фильтры, которые определяют конкретные события, которые должны быть обработаны данным хэндлером

```python
		# чтобы отловить команду /start:

			@dp.message(CommandStart())
			async def cmd_start(message: Message)
				await message.answer('Hi!')

		# тут мы используем dp, так как мы не использовали роутеров (о них будет в другой подглаве)

		# Нужные импорты (примеры):

			from aiogram.filters import CommandStart, Command
			from aiogram.types import Message

		# Message - используется для типизации аргумента функции хэндлера. Представляет собой сообщение, которое пришло в бота. Объект сообщения содержит кучу разных полей, в том числе ИД пользователя, всю его доступную информацию, сам текст сообщения, время, дату и тд и тп (на практике чаще всего используем message.from_user - тут хранится все по пользователю, который написал сообщение)

		# метод answer у объекта message - готовое решение фреймворка, чтобы ответить пользователю, от которого пришло сообщение (событие, в данном примере - это команда /start)

		# так же есть message.reply - ответить на сообщение

		# Пример работы с фильтром, где можно определить любую команду:

			@dp.message(Command('example_command'))
			async def cmd_start(message: Message)
				await message.answer('Hi!')

		# MagicFilter - фильтр, который позволяет гибко настроить фильтрацию событий для хэндлера

		# Импортировать:

			from aiogram import F

		# Например, фильтруем по событию, когда пользователь написал строку 'Как дела?'

			@dp.message(F.text == 'Как дела?')
			async def get_text(message: Message):
			    await message.answer('Да нормалек все')

		# С помощью этого фильтра можно ловить вообще все, что отправляет пользователь - картинки, видео, стикеры, локации, контакты и тд.

		# Пример с фотографией:

			@dp.message(F.photo)
			async def get_photo(message: Message):
				await message.answer(message.photo[-1].file_id)

		# @dp.message(F.photo) - ловим событие, когда в чат приходит любое изображение

		# message.photo[-1].file_id - достаем уникальный ID картинки (самый последний в списке - самое лучшее качество в списке. ТГ хранит картинки в нескольких вариантах)

```

Отдельно укажу, что магический фильтр умеет в in, у него есть встроенный метод. И в целом можно и лямбду передать. Главное чтобы возвращался bool
Далее вырезка из курса:

Больше всего вас могли заинтересовать вот эти конструкции:

```python
@dp.message(CommandStart())

@dp.message(F.text.lower().in_(['да', 'давай', 'сыграем', 'игра', 'играть', 'хочу играть']))

@dp.message(F.text.lower().in_(['нет', 'не', 'не хочу', 'не буду']))

@dp.message(lambda x: x.text and x.text.isdigit() and 1 <= int(x.text) <= 100)
```

В декораторах появились: фильтр `CommandStart`, сложнозаписанный магический фильтр `F` и анонимная функция `lambda`. Подозреваю, что вы уже догадались, что это просто разные способы указать фильтры. Сначала про `CommandStart`. Aiogram предлагает ряд уже готовых фильтров и `CommandStart` один из них. Он предназначен для фильтрации апдейтов с командой /start. Можно было записать фильтр на эту команду так, как мы это делали в предыдущих уроках, то есть `Command(commands='start')`, но раз есть готовый фильтр, то почему бы им не пользоваться?

Далее про магический фильтр. В нашем боте конструкция `F.text.lower().in_(['да', 'давай', 'сыграем', 'игра', 'играть', 'хочу играть'])` проверяет текст на полное совпадение строк без учета регистра. То есть через фильтр пройдут сообщения "Да", "ДА", "да", "дА", "ДаВаЙ" и так далее. Тоже самое про фильтрацию по тексту отказа от игры: `F.text.lower().in_(['нет', 'не', 'не хочу', 'не буду'])`. Сейчас не буду подробно заострять внимание на том, как работают магические фильтры, потому что об этом будет полноценный рассказ в следующем уроке.

А что здесь делает `lambda`? В качестве фильтра может выступать любая функция, возвращающая `True` или `False`, в том числе и анонимная. Можно было бы записать неанонимную функцию где-нибудь выше по коду и при регистрации хэндлера указать ее имя. Например, такой код

```python
def if_numbers_filter(message: Message):
    return message.text and message.text.isdigit() and 1 <= int(message.text) <= 100

# ...

@dp.message(if_numbers_filter)
# ...
```

эквивалентен тому, что мы использовали в программе нашего бота: `@dp.message(lambda x: x.text and x.text.isdigit() and 1 <= int(x.text) <= 100)`. Сначала мы проверяем, что в апдейте вообще есть поле text, а оно есть далеко не у всех апдейтов типа `Message`, затем проверяем, что текст состоит из цифр и что число находится в диапазоне от 1 до 100 включительно.

А вот так можно по типу контента

```jsx
@dp.message(F.content_type == ContentType.PHOTO)
```

## **Собственные фильтры**

Для собственного фильтра нужно реализовать класс, наследуемый от BaseFilter. Необходимо в нем определить дандер метод  __call__ (асинхронный, конечно же)

Фреймворк `aiogram` предписывает нам создавать свои фильтры, наследуясь от классa `BaseFilter`, который находится в `aiogram.filters`. Магический метод `__call__` должен быть асинхронным и должен возвращать либо `True`/`False`, либо словарь. А словарь почему? Оказывается, с помощью фильтра можно не только что-то сделать с апдейтом и вернуть булево значение, но также можно из фильтра в хэндлер передать какую-то информацию. 

```python
from aiogram.filters import BaseFilter

class IsAdmin(BaseFilter):
    def __init__(self, admin_ids: list[int]) -> None:
        self.admin_ids = admin_ids

    async def __call__(self, message: Message) -> bool:
        return message.from_user.id in self.admin_ids
```

## Интересные моменты

Если нужно инвертировать результат работы фильтра - используется знак `~` перед фильтром.

**Пример.** Хэндлер должен получать апдейты с любым типом контента, но при этом, если тип контента текст, то он не должен начинаться со слова "привет".

```python
@dp.message(~F.text.startswith('привет'))
```