### 1. Запуск контейнеров из образа с указанием версии (tag)

- **По умолчанию** при выполнении команды:
    
    `docker run redis`
    
    запускается образ Redis с тегом `latest` (в примере это была версия 6.0.9).
    
- **Выбор конкретной версии**:
    
    `docker run redis:5.0`
    
    После двоеточия (`:`) указывается нужная версия (tag). Docker скачает и запустит именно эту версию.

> **Где посмотреть доступные версии**  
> На [Docker Hub](https://hub.docker.com/) можно найти имя нужного образа, увидеть все теги и выбрать нужную версию.

---

### 2. Взаимодействие со стандартным вводом (stdin) и терминалом

#### 2.1. Почему контейнер “не слушает” stdin по умолчанию?

- При запуске простым `docker run <image>` контейнер не имеет привязки к **стандартному вводу** хоста и **терминалу**.
- Если внутри контейнера есть скрипт, ожидающий ввода (например, `read` в shell-скрипте), без специальных флагов Docker не передаст ему наши данные.

#### 2.2. Флаг `-t` (pseudo-tty)

- Создаёт псевдотерминал внутри контейнера, позволяя более дружелюбно отображать вывод.
- Но **без** подключения стандартного ввода (`-i`) этот терминал “зависнет”, потому что контейнер всё ещё не получает данные с клавиатуры.

#### 2.3. Флаг `-i` (interactive)

- Подключает **стандартный ввод** хоста к контейнеру.
- Используется для передачи любых данных (включая команды, текст и т.д.) внутрь контейнера.

#### 2.4. Комбинация `-it`

- Часто применяют вместе:
    
    `docker run -it <image>` 
    
    - `-i` даёт интерактивность (способность получать stdin контейнером)
    - `-t` обеспечивает полноценный терминал для пользователя

> **Для запоминания**: чтобы _“подключиться к контейнеру”_, будь “из IT” – т.е. ставь флаги `-i` и `-t`.

---

### 3. Передача данных в контейнер с помощью pipe

- Когда не нужно полноценное взаимодействие в терминале, а нужно просто передать строку или поток в stdin контейнера, то можно использовать пайпы:
    
    `echo "Rotoro" | docker run -i rotorocloud/simple-prompt-docker`
    
    - Здесь `echo` посылает данные в контейнер через pipe, а флаг `-i` даёт контейнеру возможность читать их.

---

### 4. Публикация (проброс) портов

- **Задача**: сделать контейнер доступным извне (например, для веб-приложения).
- **По умолчанию** контейнер слушает на своём внутреннем IP (например, `172.17.0.2`) и нужном порту (допустим, `5000`), что доступно только на хосте Docker.
- **Флаг `-p`** позволяет сопоставить порт докер-хоста с портом контейнера:
    
    `docker run -p 80:5000 <image>`
    
    - Порт `80` хоста будет перенаправляться на порт `5000` внутри контейнера.
    - Пользователи получат доступ, обращаясь к IP хоста на порту `80`.
    - Обрати внимание, что флаг `-p` нужно указывать **до** образа

> **Пример**:  
> Если хост имеет IP `10.0.0.13`, то приложение доступно по адресу `http://10.0.0.13:80`, а внутри контейнера оно всё так же работает на порту `5000`.

---

### 5. Хранение постоянных данных (volumes)

- **Проблема**: данные внутри контейнера (например, базы данных в `/var/lib/mysql`) исчезнут при удалении контейнера.
- **Решение**: монтировать (пробрасывать) папку с хоста внутрь контейнера через флаг `-v`.
    
    `docker run -v /opt/datadir/:/var/lib/mysql <image>`
    
    - `/opt/datadir/` на хосте будет соответствовать `/var/lib/mysql` внутри контейнера.
    - Удаление контейнера не затронет данные, так как они физически лежат на хосте.

---

### 6. Дополнительные команды

#### 6.1. `docker inspect`

`docker inspect <container_name_or_id>`

- Даёт подробный JSON-отчёт о конфигурации контейнера: состояние, смонтированные тома, сети и проч.

#### 6.2. `docker logs`

`docker logs <container_name_or_id>`

- Отображает логи контейнера (стандартный вывод `stdout` и `stderr`).
- Чтобы контейнер работал в фоновом (detach) режиме, добавляют флаг:
    
    `docker run -d <image>`
    
    Тогда контейнер не “занимает” наш терминал, и логи смотрят отдельной командой `docker logs`.

> **Примечание**: частая практика — **писать логи в stdout**, чтобы их собирала система мониторинга или чтобы быстро просматривать через `docker logs`.

---

### 7. Список основных команд из статьи

1. **Запуск нужной версии образа**
    
    `docker run <image>:<tag>`
    
2. **Запуск с привязкой к терминалу**
    
    `docker run -it <image> <command>`
    
3. **Флаги для интерактивного режима**
    - `-i` (stdin), `-t` (tty)
      
4. **Передача данных через pipe**
    
    `echo 'qwe' | docker run -i <image>`
    
5. **Проброс портов**
    
    `docker run -p 80:5000 <image>`
    
6. **Монтирование (volumes)**
    
    `docker run -v /opt/datadir/:/var/lib/mysql <image>`
    
7. **Просмотр полной информации о контейнере**
    
    `docker inspect <container_name_or_id>`
    
8. **Вывод логов контейнера**
    
    `docker logs <container_name_or_id>`
    
9. **Фоновый режим**
    
    `docker run -d <image>`
    

---

### Дополнительные замечания

- Если не указывать тег, Docker автоматически берёт `latest` (при наличии).
- Один порт хоста нельзя использовать для нескольких разных контейнеров одновременно.
- Данные в контейнере (без volume) считаются **непостоянными** и удаляются вместе с контейнером.
- Для автоматизированных сценариев обычно достаточно `-i`, а для прямого взаимодействия “из консоли” нужен `-it`.

---

**ИТОГ**:  
Команда `docker run` — один из базовых инструментов работы с Docker, позволяющий:

- выбирать версию образа,
- управлять вводом/выводом (флаги `-i`, `-t`),
- пробрасывать порты (`-p`),
- монтировать каталоги (`-v`),
- запускать контейнер в фоне (`-d`),
- получать детальную информацию и логи (`docker inspect`, `docker logs`).